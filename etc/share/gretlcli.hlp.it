headings 10
Tests 22
add
adf
chow
coeffsum
coint
coint2
cusum
difftest
hausman
kpss
leverage
levinlin
meantest
modtest
normtest
omit
qlrtest
reset
restrict
runs
vartest
vif
Graphs 7
boxplot
gnuplot
graphpg
qqplot
rmplot
scatters
textplot
Statistics 13
anova
corr
corrgm
fractint
freq
hurst
mahal
pca
pergm
spearman
summary
xcorrgm
xtab
Dataset 18
append
data
dataset
delete
genr
info
join
labels
markers
nulldata
open
rename
setinfo
setmiss
setobs
smpl
store
varlist
Estimation 34
ar
ar1
arbond
arch
arima
biprobit
dpanel
duration
equation
estimate
garch
gmm
heckit
hsk
intreg
kalman
lad
logistic
logit
mle
mpols
negbin
nls
ols
panel
poisson
probit
quantreg
system
tobit
tsls
var
vecm
wls
Programming 17
break
catch
clear
debug
elif
else
end
endif
endloop
foreign
function
if
include
loop
makepkg
run
set
Transformations 9
diff
discrete
dummify
lags
ldiff
logs
orthdev
sdiff
square
Printing 7
eqnprint
modprint
outfile
print
printf
sprintf
tabprint
Prediction 1
fcast
Utilities 5
help
modeltab
pvalue
quit
shell

# add Tests

Argomento:  lista-variabili 
Opzioni:    --lm (effettua un test LM (solo OLS))
            --quiet (non mostra le stime del modello aumentato)
            --silent (non mostra nulla)
            --vcv (mostra la matrice di covarianza)
            --both (aggiunge come regressore e come strumento, solo per TSLS)
Esempi:     add 5 7 9
            add xx yy zz --quiet

Va invocato dopo un comando di stima. Esegue un test congiunto per
l'aggiunta delle variabili specificate all'ultimo modello stimato; si può
avere accesso ai risultati del test tramite $test e $pvalue.

Di default, aggiunge al modello precedente le variabili nella
lista-variabili e stima il nuovo modello. Il test è un test di Wald sul
modello aumentato, che rimpiazza quello originale come "ultimo modello" per
quanto riguarda,ad esempio, il contenuto di $uhat o test ulteriori.

Alternativamente, con l'opzione --lm (disponibile solo per i modelli stimati
via OLS), viene effettuato un test LM. Viene eseguita una regressione
ausiliaria in cui la variabile dipendente è il residuo dell'ultimo modello
e le variabili indipendenti sono quello del modello originale più
lista-variabili. Sotto l'ipotesi nulla che le variabili aggiuntive non hanno
potere esplicativo, il prodotto fra l'R-quadro non aggiustato della
regressione ausiliaria e il numero di osservazioni si distribuisce come una
chi quadro con tanti gradi di libertà quante sono le variabili in
lista-variabili. In questo caso, il modello originale non viene rimpiazzato.

L'opzione --both è specifica per le stime con i minimi quadrati a due
stadi: essa indica che le nuove variabili vanno aggiunte sia alla lista dei
regressori che a quella degli strumenti; di default, infatti, la
lista-variabili viene aggiunta soltanto ai regressori.

Accesso dal menù:    Finestra del modello, /Test/ADD - Aggiungi variabili

# adf Tests

Argomenti:  ordine lista-variabili 
Opzioni:    --nc (test senza costante)
            --c (solo con la costante)
            --ct (con costante e trend)
            --ctt (con costante, trend e trend al quadrato)
            --seasonals (include variabili dummy stagionali)
            --gls (rimuove la media o il trend usando GLS)
            --verbose (mostra i risultati della regressione)
            --quiet (non mostra i risultati)
            --difference (usa la differenza prima della variabile)
            --test-down[=criterio] (ordine di ritardo automatico)
Esempi:     adf 0 y
            adf 2 y --nc --c --ct
            adf 12 y --c --test-down
            Vedi anche jgm-1996.inp

Le opzioni precedenti e la discussione seguente si riferiscono all'uso del
comando adf con serie storiche regolari. La discussione dell'uso con dati
panel è esposta più avanti.

Calcola una serie di test Dickey-Fuller sulle variabili specificate,
assumendo come ipotesi nulla che le variabili abbiano una radice unitaria.
Se si usa l'opzione --difference, i test vengono condotti sulla differenza
prima delle variabili e la discussione che segue va riferita a questa
trasformazione delle variabili.

Per impostazione predefinita, vengono mostrate due varianti del test: una
basata su una regressione che contiene solo una costante, e una che include
la costante e un trend lineare. È possibile controllare le varianti
specificando una o più opzioni.

In tutti i casi, la variabile dipendente è la differenza prima della
variabile specificata, y, e la variabile dipendente più importante è il
ritardo (di ordine uno) di y. Il modello è costruito in modo che il
coefficiente della variabile ritardata y è pari a 1 meno la radice. Ad
esempio, il modello con una costante può essere scritto come

  (1 - L)y(t) = b0 + (a-1)y(t-1) + e(t)

Sotto l'ipotesi nulla di radice unitaria il coefficiente della y ritardata
è nullo; sotto l'alternativa che y sia stazionaria il coefficiente è
negativo.

Se l'ordine di ritardi, k, è maggiore di 0, ai regressori di ognuna delle
regressioni calcolate per il test saranno aggiunti k ritardi della variabile
dipendente. Se l'ordine è -1, k è impostato secondo la raccomandazione di
Schwert (1989), ossia 12(T/100)^0.25, dove T è l'ampiezza campionaria. In
tutti e due i casi, comunque, se si usa l'opzione --test-down, k viene
interpretato come ritardo massimo, mentre l'ordine di ritardo effettivamente
usato viene ottenuto testando "all'indietro". Il criterio per effettuare il
test all'indietro può essere selezionato usando il parametro opzionale e
deve essere uno fra MAIC, MBIC o tstat. I metodi MAIC e MBIC sono descritti
in Ng and Perron (2001); l'ordine dei ritardi viene scelto in modo da
ottimizzare rispettivamente una versione modificata del Criterio di
Informazione di Akaike o del Criterio Bayesiano di Schwartz. Il metodo MAIC
è quello applicato di default quando non viene esplicitamente dichiarato un
metodo. Il metodo tstat è il seguente:

1. Stima la regressione Dickey-Fuller con k ritardi della variabile
   dipendente.

2. Se questo ordine di ritardi è significativo, esegue il test con l'ordine
   di ritardo k. Altrimenti, prova il test con k = k - 1; se k = 0, esegue
   il test con ordine di ritardo 0, altrimenti va al punto 1.

Durante il punto 2 spiegato sopra, "significativo" significa che la
statistica t per l'ultimo ritardo abbia un p-value asintotico a due code per
la distribuzione normale pari a 0.10 o inferiore.

L'opzione --gls può essere usata insieme a una delle altre due opzioni --c
e --ct (il modello con costante o quello con costante e trend). L'effetto di
questa opzione è di rimuovere la media o il trend della variabile da
testare, usando la procedura GLS suggerita da Elliott, Rothenberg and Stock
(1996), che fornisce un test di potenza maggiore rispetto a quell'approccio
standard di Dickey-Fuller. Questa opzione non è compatibile con le opzioni
--nc, --ctt o --seasonals.

I p-value per questo test sono basati su MacKinnon (1996). Il codice
rilevante è incluso per gentile concessione dell'autore. Nel caso del test
con trend lineare usando la procedura GLS questi P-value non sono
utilizzabili; vengono usati i valori critici contenuti nella Tabella 1 di
Elliott, Rothenberg and Stock (1996).

Panel data

Quando il comando adf è usato con dati panel per calcolare un test panel di
radici unitarie le opzioni applicabili sono leggermente diverse.

In primo luogo, mentre nel caso di serie storiche regolari è possibile
indicare un elenco di variabili da testare, con dati panel ciascun comando
può esaminare una sola variabile alla volta. Secondo, le opzioni che
governano l'inclusione di trend deterministici diventano mutualmente
esclusive: è necessario scegliere fra il caso senza costante, quello con
solo la costante, e quello che la costante e il trend; il default è il
secondo. L'opzione --seasonals, inoltre, non è disponibile. Terzo,
l'opzione --verbose ha un significato diverso: produce un breve resoconto
del test per ciascuna singola serie storica (il default prevede di mostrare
solo il risultato complessivo).

Il test complessivo (ipotesi nulla: la variabile in questione ha una radice
unitaria per tutte le unità panel) viene calcolata in uno o in entrambi i
modi disponibili: usando il metodo di Im, Pesaran and Shin (Journal of
Econometrics, 2003) oppure quello di Choi (Journal of International Money
and Finance, 2001).

Accesso dal menù:    /Variabile/Test Dickey-Fuller aumentato

# anova Statistics

Argomenti:  response treatment [ block ] 
Opzione:    --quiet (non stampare i risultati)

Analisi della varianza: response è una serie che misura un effetto di
interesse e treatment deve essere una variabile discreta che identifica due
o più tipi di trattamento (o non trattamento). Nel caso dell'ANOVA a due
vie, la variabile block (anch'essa discreta) identifica i valori di qualche
variabile di controllo.

Se non è stata selezionata l'opzione --quiet, questo comando stampa una
tabella che mostra le somme e le medie dei quadrati, nonché un test F. Il
test F e il suo p-value possono essere recuperati rispettivamente con gli
accessori $test e $pvalue.

L'ipotesi nulla del test F è che la risposta media sia invariante rispetto
al tipo di trattamento; in altre parole, che il trattamento non abbia alcun
effetto. Formalmente, la validità del test richiede che la varianza della
risposta sia la stessa per tutti i tipi di trattamento.

Si noti che i risultati prodotti da questo comando costituiscono in realtà
un sottoinsieme dell'informazione fornita dalla procedura seguente,
facilmente implementabile in gretl. Create un insieme di variabili dummy
associate a tutti i tipi di trattamento, tranne uno. Nel caso dell'ANOVA a
due vie, create anche un insieme di variabili dummy associate a tutti i
"blocchi", tranne uno. Una volta fatto questo, regredite response su una
costante e le dummy usando "ols". Per un'analisi a una via la tabella ANOVA
può essere creata ricorrendo all'opzione --anova del comando ols. Nel caso
di un'analisi a due vie il test F può essere calcolato usando il comando
"omit". Per esempio, se assumiamo che y sia la risposta, xt identifichi il
trattamento e xb identifichi i blocchi:

	# analisi a una via
	list dxt = dummify(xt)
	ols y 0 dxt --anova
	# analisi a due vie
	list dxb = dummify(xb)
	ols y 0 dxt dxb
	# test di significatività congiunta di dxt
	omit dxt --quiet

Accesso dal menù:    /Model/Other linear models/ANOVA

# append Dataset

Argomento:  file-dati 
Opzione:    --time-series (si veda oltre)

Apre un file di dati e aggiunge il suo contenuto al dataset attuale, se i
nuovi dati sono compatibili. Il programma cerca di riconoscere il formato
del file di dati (interno, testo semplice, CSV, Gnumeric, Excel, ecc.).

I dati aggiunti possono avere la forma di osservazioni aggiuntive su
variabili già presenti nel dataset, o di nuove variabili. In quest'ultimo
caso occorre che il numero delle nuove osservazioni sia pari a quello delle
osservazioni presenti nel dataset, oppure che i nuovi dati includano
informazioni precise sulle osservazioni in modo che gretl possa capire come
aggiungere i valori.

Nel caso di aggiunta di dati a un dataset panel, c'è una possibilità
speciale. Detti n il numero di unità cross-section, T il numero di periodi
temporali, e m il numero di nuove osservazioni da aggiungere. Se m = n i
nuovi dati saranno considerati invarianti nel tempo, e saranno copiati per
ognuno dei periodi temporali. D'altra parte, se m = T i dati saranno
trattati come invarianti tra le unità. Se il panel è "quadrato", ed m è
pari sia ad n che a T, il comportamento predefinito consiste nel trattare i
nuovi casi come invarianti nel tempo, ma è possibile forzare
l'interpretazione dei nuovi dati come serie storiche usando l'opzione
--time-series (che verrà ignorata in tutti gli altri casi).

Vedi anche "join" per una gestione più sofisticata di più di un file di
dati esterno.

Accesso dal menù:    /File/Aggiungi dati

# ar Estimation

Argomenti:  ritardi ; variabile-dipendente variabili-indipendenti 
Opzione:    --vcv (mostra la matrice di covarianza)
Esempio:    ar 1 3 4 ; y 0 x1 x2 x3

Calcola le stime parametriche usando la procedura iterativa generalizzata di
Cochrane-Orcutt (si veda il Capitolo 9.5 di Ramanathan (2002). La procedura
termina quando le somme dei quadrati degli errori consecutivi non
differiscono per più dello 0.005 per cento, oppure dopo 20 iterazioni.

"ritardi" è una lista di ritardi nei residui, conclusa da un punto e
virgola. Nell'esempio precedente, il termine di errore è specificato come

  u(t) = rho(1)*u(t-1) + rho(3)*u(t-3) + rho(4)*u(t-4)

Accesso dal menù:    /Modello/Serie storiche/AR - Stima autoregressiva

# ar1 Estimation

Argomenti:  depvar indepvars 
Opzioni:    --hilu (usa la procedura di Hildreth-Lu)
            --pwe (usa lo stimatore di Prais-Winsten)
            --vcv (mostra la matrice di covarianza)
            --no-corc (non affinare i risultati con Cochrane-Orcutt)
Esempi:     ar1 1 0 2 4 6 7
            ar1 y 0 xlist --hilu --no-corc
            ar1 y 0 xlist --pwe

Calcola stime feasible GLS per un modello in cui il termine di errore segue
un processo autoregressivo del prim'ordine.

Il metodo predefinito è la procedura iterativa di Cochrane-Orcutt (si veda
ad esempio il capitolo 9.4 di Ramanathan, 2002). La procedura termina quando
le stime successive del coefficiente di autocorrelazione non differiscono
per più di 0.001, oppure dopo 20 iterazioni.

Se si usa l'opzione --hilu, verrà usata la procedura di ricerca di
Hildreth-Lu. I risultati sono quindi ottimizzati con la procedura iterativa
di Cochrane-Orcutt, a meno che non si usi l'opzione --no-corc (che viene
ignorata se non viene specificata --hilu).

Se si usa l'opzione --pwe, viene usato lo stimatore di Prais-Winsten, che
prevede una procedura simile a quella di Cochrane-Orcutt; la differenza è
che mentre Cochrane-Orcutt tralascia la prima osservazione, Prais-Winsten ne
fa uso. Per i dettagli, si veda per esempio il capitolo 13 di Econometric
Analysis di Greene (2000).

Accesso dal menù:    /Modello/Serie storiche/Cochrane-Orcutt
Accesso dal menù:    /Modello/Serie storiche/Hildreth-Lu
Accesso dal menù:    /Modello/Serie storiche/Prais-Winsten

# arbond Estimation

Argomento:  p [ q ] ; variabile-dipendente variabili-indipendenti [ ; strumenti ] 
Opzioni:    --quiet (non mostra il modello stimato)
            --vcv (mostra matrice di covarianza)
            --two-step (usa stima GMM 2-step)
            --time-dummies (aggiunge variabili dummy temporali)
            --asymptotic (calcola gli errori standard asintotici nel modo standard)
Esempi:     arbond 2 ; y Dx1 Dx2
            arbond 2 5 ; y Dx1 Dx2 ; Dx1
            arbond 1 ; y Dx1 Dx2 ; Dx1 GMM(x2,2,3)
            Vedi anche arbond91.inp

Esegue la stima di modelli panel dinamici (ossia, modelli panel che
includono uno o più ritardi della variabile dipendente) usando il metodo
GMM proposto da Arellano and Bond (1991). Vedi, tuttavia, il comando
"dpanel" per una alternativa più avanzata e più flessibile, che offre lo
stimatore GMM-SYS oltre al GMM-DIF.

Il parametro p rappresenta l'ordine dell'autoregressione per la variabile
dipendente. Il parametro opzionale q indica il massimo ritardo del livello
della variabile dipendente da usare come strumento; se si omette questo
argomento, o lo si pone uguale a 0, vengono usati tutti i ritardi
disponibili.

La variabile dipendente andrebbe specificata in livelli; viene differenziata
automaticamente, visto che lo stimatore usa la differenziazione per
eliminare gli effetti individuali. Le variabili indipendenti invece non
vengono differenziate automaticamente: se si intende usare le differenze
(tipicamente lo si vorrà fare per le variabili quantitative, ma non ad
esempio per le dummy temporali), occorrerà prima creare le variabili
differenziate e poi specificarle come regressori.

L'ultimo campo (opzionale) del comando consente di specificare gli
strumenti. Se non viene usato, si assumerà che tutte le variabili
indipendenti sono strettamente esogene. Se si specifica uno strumento,
occorre includere nell'elenco tutte le variabili indipendenti strettamente
esogene. Per i regressori predeterminati, è possibile usare la funzione GMM
per includere un intervallo specifico di ritardi in stile "diagonale".
Questo modo di procedere è illustrato nel terzo esempio visto sopra. Il
primo argomento di GMM è il nome della variabile in questione, il secondo
è il ritardo minimo da usare, mentre il terzo è quello massimo. Se il
terzo argomento è pari a 0, vengono usati tutti i ritardi disponibili.

Per impostazione predefinita, vengono mostrati i risultati della stima a un
passo (con errori standard robusti), ma è possibile scegliere una stima a
due passi. In entrambi i casi, vengono mostrati i testi per
l'autocorrelazione di ordine 1 e 2, oltre al test di sovraidentificazione di
Sargan. Si noti che in questo modello differenziato l'autocorrelazione del
prim'ordine non contrasta con la validità del modello, mentre quella di
ordine 2 viola le ipotesi statistiche che ne sono alla base.

Nel caso della stima in due passi, gli errori standard sono calcolati usando
la correzione per campioni finiti suggerita daWindmeijer (2005). Gli errori
standard asintotici calcolati nel modo consueto non sono generalmente
ritenuti affidabili nel caso dello stimatore a due passi, ma se per qualche
motivo si vuole usarli, è possibile usare l'opzione --asymptotic per
disabilitare la correzione di Windmeijer.

Se si usa l'opzione --time-dummies, viene aggiunto ai regressori un insieme
di variabili dummy temporali. Il numero di variabili dummy è pari al numero
massimo dei periodi usati nella stima meno uno, per evitare la perfetta
collinearità in presenza della costante. Le dummy sono specificate in
livelli; se si intende usare variabili dummy sotto forma di differenze
temporali, occorre definirle ed aggiungerle manualmente.

Accesso dal menù:    /Model/Panel

# arch Estimation

Argomenti:  ordine variabile-dipendente variabili-indipendenti 
Esempio:    arch 4 y 0 x1 x2 x3

Questo comando è attualmente mantenuto per ragioni di compatibilità con le
versioni precedenti, ma è preferibile usare lo stimatore di massima
verosimiglianza disponibile mediante il comando "garch"; per un modello ARCH
puro, fissate a 0 il primo parametro GARCH.

Stima il modello specificato tenendo conto della possibile
eteroschedasticità condizionale autoregressiva (ARCH, Autoregressive
Conditional Heteroskedasticity). Per prima cosa il modello viene stimato con
OLS, quindi viene eseguita una regressione ausiliaria, in cui i quadrati dei
residui della prima regressione vengono regrediti sui loro valori ritardati.
Il passo finale è una stima con minimi quadrati ponderati, in cui i pesi
sono i reciproci delle varianze dell'errore della regressione ausiliaria (se
la varianza prevista di qualche osservazione nella regressione ausiliaria
non risulta positiva, viene usato il corrispondente residuo al quadrato).

I valori alpha mostrati sotto i coefficienti sono i parametri del processo
ARCH stimati nella regressione ausiliaria.

Si veda anche "garch" e "modtest" (l'opzione --arch).

Accesso dal menù:    /Modello/Serie storiche/ARCH

# arima Estimation

Argomenti:  p d q [ ; P D Q ] variabile-dipendente ; [ variabili-indipendenti ] 
Opzioni:    --verbose (mostra i dettagli delle iterazioni)
            --vcv (mostra la matrice di covarianza)
            --hessian (si veda sotto)
            --opg (si veda sotto)
            --nc (non include l'intercetta)
            --conditional (usa la massima verosimiglianza condizionale)
            --x-12-arima (usa X-12-ARIMA per la stima)
            --lbfgs (usa il massimizzatore L-BFGS-B)
            --y-diff-only (speciale per ARIMAX, si veda sotto)
            --save-ehat (si veda sotto)
Esempi:     arima 1 0 2 ; y
            arima 2 0 2 ; y 0 x1 x2 --verbose
            arima 0 1 1 ; 0 1 1 ; y --nc

Se non viene fornita una lista di variabili-indipendenti, stima un modello
autoregressivo integrato a media mobile (ARIMA: Autoregressive, Integrated,
Moving Average) univariato. I valori p, d e q rappresentano rispettivamente
gli ordini dei termini autoregressivi (AR), l'ordine di differenziazione, e
quello dei termini a media mobile (MA). Questi valori possono essere
indicati in forma numerica o con i nomi di variabili scalari preesistenti.
Ad esempio, un valore d pari a 1 significa che prima di stimare i parametri
ARMA occorre prendere la differenza della variabile dipendente.

Se si vuole includere solo alcuni specifici ritardi AR o MA (invece che
tutti i ritardi fino all'ordine specificato) è possibile sostituire p e/o q
in due modi: col nome di una matrice predefinita che contiene un insieme di
valori interi, oppure con un'espressione come {1 4}, ossia un insieme di
ritardi separati da spazi e racchiusi tra parentesi graffe.

I valori interi opzionali P, D e Q rappresentano rispettivamente, l'ordine
dei termini AR stagionali, l'ordine di differenziazione stagionale e
l'ordine dei termini MA stagionali. Essi sono rilevanti solo la frequenza
dei dati è superiore a 1 (ad esempio, dati trimestrali o mensili). Questi
valori devono essere indicati in forma numerica o come variabili scalari.

Nel caso univariato la scelta predefinita include un'intercetta nel modello,
ma questa può essere soppressa con l'opzione --nc. Se vengono aggiunte
delle variabili-indipendenti, il modello diventa un ARMAX: in questo caso
occorre indicare esplicitamente la costante se si desidera un'intercetta
(come nel secondo degli esempi proposti).

È disponibile una sintassi alternativa per questo comando: se non si
intende applicare alcuna operazione di differenziazione (stagionale o non
stagionale), è possibile omettere totalmente i termini d e D, invece che
impostarli esplicitamente pari a 0. Inoltre, arma è un sinonimo di arima,
quindi ad esempio il comando seguente è un modo valido per specificare un
modello ARMA(2,1):

	arma 2 1 ; y

Il funzionamento predefinito utilizza la funzionalità ARMA "interna" di
gretl, che usa la stima di massima verosimiglianza esatta usando il filtro
di Kalman; come opzione è possibile usare la stima di massima
verosimiglianza condizionale. Se è stato installato il programma X-12-ARIMA
è possibile usare questo al posto del codice interno di gretl. Per i
dettagli su queste opzioni si veda la la guida all'uso di gretl.

Quando si usa il codice ARMA interno, le deviazioni standard sono stimate
basandosi su un'approssimazione numerica all'inversa negativa dell'Hessiana,
passando automaticamente al prodotto esterno del gradiente (OPG) in caso di
problemi numerici. Se si usa l'opzione --opg il prodotto esterno del
gradiente viene usato in ogni caso. L'opzione --hessian, invece, disabilita
il passaggio automatico all'OPG in caso di problemi. Si noti, peraltro, che
l'impossibilità di calcolare numericamente l'hessiana è per solito indice
di un modello mal specificato.

L'opzione --lbfgs è riservata alla stima basata su codice ARMA nativo e MV
esatta; quando viene indicata, la stima usa l'algoritmo L-BFGS a "memoria
limitata" anziché l'ottimizzatore BFGS consueto. Questa variante può
essere utile in alcune situazioni nelle quali la convergenza all'ottimo è
problematica.

L'opzione --y-diff-only è riservata alla stima di modelli ARIMAX (modelli
con ordine di integrazione non nullo e che includono regressori esogeni), e
si applica solo con la stima di MV esatta nativa di gretl. Per questi
modelli il comportamento di default consiste nel differenziare sia la
variabile dipendente che i regressori, ma quando viene indicata questa
opzione viene differenziata solo la variabile dipendente, mentre i
regressori restano nei livelli.

L'opzione --save-ehat è applicabile solo alla stima nativa di MV esatta. Il
suo effetto è quello di rendere disponibile un vettore contenente la stima
ottimale alla data t del disturbo o innovazione alla stessa data: questo
valore può essere recuperato grazie all'accessore $ehat. Questi valori sono
diversi dalla variabile dei residui ($uhat) che contiene gli errori di
previsione un passo in avanti.

Il valore AIC mostrato nei modelli ARIMA è calcolato secondo la definizione
usata in X-12-ARIMA, ossia

  AIC = -2L + 2k

dove L è la log-verosimiglianza e k è il numero totale di parametri
stimati. Si noti che X-12-ARIMA non produce criteri di informazione come
l'AIC quando la stima è effettuata col metodo della massima verosimiglianza
condizionale.

Le radici AR e MA mostrate in occasione delkla stima ARMA sono basate sulla
seguente rappresentazione di un processo ARMA(p,q):

	(1 - a_1*L - a_2*L^2 - ... - a_p*L^p)Y =
          c + (1 + b_1*L + b_2*L^2 + ... + b_q*L^q) e_t

Di conseguenza le radici AR sono la soluzione di

         1 - a_1*z - a_2*z^2 - ... - a_p*L^p = 0

e la stazionarietà del processo richiede che queste radici si trovino al di
fuori del cerchio di raggio unitario.

Il valore di "frequenza" mostrato insieme alle radici AR e MA è il valore
di lambda che risolve z = r * exp(i*2*pi*lambda)dove z è la radice in
questione e r è il suo modulo.

Accesso dal menù:    /Modello/Serie Storiche/ARIMA
Accesso alternativo: Menù pop-up nella finestra principale (selezione singola)

# biprobit Estimation

Argomenti:  depvar1 depvar2 indepvars1 [ ; indepvars2 ] 
Opzioni:    --vcv (stampa la matrice di covarianze)
            --robust (errori standard robusti)
            --cluster=clustvar (vedi "logit" per una spiegazione)
            --opg (vedi sotto)
            --save-xbeta (vedi sotto)
            --verbose (stampa informazione extra)
Esempi:     biprobit y1 y2 0 x1 x2
            biprobit y1 y2 0 x11 x12 ; 0 x21 x22
            Vedi anche biprobit.inp

Stima un modello probit bivariato massimizzando la verosimiglianza con il
metodo di Newton-Raphson.

L'elenco degli argomenti inizia con due variabili dipendenti (binarie),
seguite da una lista di regressori. Un'eventuale seconda lista, separata
dalla precedente da un punto e virgola, viene interpretata come contenente
l'insieme dei regressori specifici alla seconda equazione, mentre indepvars1
è specifica alla prima equazione; in caso contrario il comando assume che
indepvars1 rappresenti un insieme di regressori comuni alle due equazioni.

Per default, gli errori standard sono calcolati usando un'approssimazione
numerica dell'Hessiana calcolata in corrispondenza delle stime dei
parametri. L'opzione --opg permette di stimare la matrice di covarianza
usando il prodotto esterno del gradiente (Outer Product of the Gradient,
OPG); l'opzione --robust permette di calcolare gli standard error QML a
partire dalla matrice di covarianza "sandwich" che usa sia l'inversa
dell'Hessiana che la matrice OPG.

Una volta completata con successo la stima, l'accessore $uhat consente di
recuperare una matrice di due colonne contenente i residui generalizzati
delle due equazioni; in altre parole, i valori attesi degli errori
condizionali ai valori osservati delle variabili dipendenti e delle
covariate. Di default $yhat restituisce una matrice di quattro colonne
contenente le stime delle probabilità dei quattro possibili esiti congiunti
per (y_1, y_2), nell'ordine (1,1), (1,0), (0,1), (0,0). In alternativa, se
il comando è seguito dall'opzione --save-xbeta , $yhat ha due colonne
contenenti i valori delle funzioni indice delle rispettive equazioni.

L'output comprende un test del rapporto di verosimiglianza dell'ipotesi
nulla che gli errori delle due equazioni siano incorrelati fra loro.

# boxplot Graphs

Argomento:  lista-variabili 
Opzioni:    --notches (mostra l'intervallo di confidenza al 90 per cento per la mediana)
            --factorized (vedi sotto)
            --panel (vedi sotto)
            --matrix=name (opera su colonne di una matrice)
            --output=filename (manda l'output a un file specificato)

Questo tipo di grafici (da Tukey e Chambers) mostra la distribuzione di una
variabile. La "scatola" centrale (box) racchiude il 50 per cento centrale
dei dati, ossia è delimitato dal primo e terzo quartile. I "baffi"
(whiskers) si estendono fino un valore dato da una volta e mezzo il range
interquartile a partire dai bordi della scatola. Valori esterni a tale
intervallo sono considerati "outlier" e rappresentati con dei punti. Una
linea trasversale sulla scatola indica la mediana, mentre un segno "+"
indica la media. Se viene selezionata l'opzione di mostrare un intervallo di
confidenza per la mediana, quetso viene calcolato via bootstrap e mostrato
sotto forma di lnee tratteggiate orizzontali sopra e sotto la mediana.

L'opzione "factorized" permette di esaminare la distribuzione di una
variabile condizionata ai valori di un fattore discreto. Ad esempio, se un
dataset contiene salari e una variable binaria per il genere, si può
scegliere di analizzare la distribuzione del salario condizionata al genere
e visualizzare boxplot dei salri per i maschi e per le femmine uno di fianco
all'altro, come ad esempio

	boxplot wage gender --factorized

Si noti che, in questo caso, bisogna specificare esattamente due variabili,
col fattore per secondo.

Se il dataset corrente è un panel ed è stata specificata una sola
variabile, l'opzione --panel produce una serie di grafici boxplot
affiancati, uno per ogni "unità" o gruppo panel.

In generale l'argomento varlist è necessario e deve indicare una o più
variabili nel dataset corrente (usando il nome o il numero di ID). Se viene
fornita una matrice usando l'opzione --matrix, tuttavia, questo argomento
diventa opzionale: di default viene mostrato un grafico per ciascuna delle
colonne della matrice specificata.

Il grafici boxplot di gretl sono generati usando gnuplot, ed è possibile
arricchire il grafico specificando altri comandi gnuplot, includendoli fra
parentesi graffa. Per maggiori dettagli consultate per favore l'help del
comando "gnuplot".

In modalità interattiva il risultato viene mostrato immediatamente. In
batch il comportamento di default di gretl è di scrivere nella directory di
lavoro dell'utente un file di comandi gnuplot chiamato gpttmpN.plt,
iniziando da N = 01. I grafici veri e propri possono essere generati in
seguito usando gnuplot (in MS Windows, wgnuplot). Questo comportamento può
essere modificato usando l'opzione --output=filename. Per ulteriori
dettagli, si veda il comando "gnuplot".

Accesso dal menù:    /Visualizza/Grafico/Boxplot

# break Programming

Esce da un ciclo. Questo comando può essere usato solo all'interno di un
ciclo e causa l'immediata interruzione dell'esecuzione del ciclo (o di
quello più interno, nel caso di cicli nidificati). Si veda anche il comando
"loop".

# catch Programming

Sintassi:   
        catch command

Non si tratta di un vero e proprio comando, quanto piuttosto di un prefisso
applicabile alla maggior parte dei comandi consueti; il suo effetto è
quello di prevenire l'interruzione di uno script nel caso in cui si
verifichi un errore nell'esecuzione di un comando. Un eventuale errore viene
registrato in un codice d'errore interno cui è possibile accedere con
$error (un valore nullo indica che l'esecuzione ha avuto successo). Il
valore di $error dovrebbe sempre essere controllato subito dopo aver usato
catch, in modo da adottare le misure più opportune nel caso in cui il
comando non dovesse aver avuto successo.

catch non può essere usato prima di if, elif o endif.

# chow Tests

Argomento:  osservazione 
Opzione:    --quiet (non mostra le stime del modello aumentato)
Esempi:     chow 25
            chow 1988:1

Va eseguito dopo una regressione OLS e fornisce un test per l'ipotesi nulla
che non esista un break strutturale del modello in corrispondenza del punto
di rottura specificato. La procedura consiste nel creare una variabile dummy
che vale 1 a partire dal punto di rottura specificato da osservazione fino
alla fine del campione, 0 altrove; inoltre vengono creati dei termini di
interazione tra questa dummy e i regressori originali. Viene quindi stimata
una regressione che include questi termini.

Per impostazione predefinita viene calcolata una statistica F, prendendo la
regressione aumentata come non vincolata e la regressione originale come
vincolata. Se il modello originale usa uno stimatore robusto per la matrice
di covarianza, come statistica test viene usato un valore chi-quadro di
Wald, basato su uno stimatore robusto della matrice di covarianza della
regressione aumentata.

Accesso dal menù:    Finestra del modello, /Test/CHOW

# clear Programming

Opzioni:    --dataset (cancella solo il dataset)
            --other (cancella tutto fuorché il dataset)

Senza alcuna opzione, cancella dalla memoria tutti gli oggetti salvati,
compreso l'eventuale campione corrente. Si noti che anche aprire un nuovo
dataset o usare il comando "nulldata" per creare un dataset vuoto ha lo
stesso effetto; per questo motivo di solito non è necessario usare "clear".

Con l'opzione --dataset viene cancellato dalla memoria solo il dataset;
tutti gli altri oggetti, come matrici e scalari salvati in precedenza,
vengono conservati.

# coeffsum Tests

Argomento:  lista-variabili 
Esempio:    coeffsum xt xt_1 xr_2
            Vedi anche restrict.inp

Deve essere usato dopo una regressione. Calcola la somma dei coefficienti
delle variabili nella lista-variabili e ne mostra l'errore standard e il
p-value per l'ipotesi nulla che la loro somma sia zero.

Si noti la differenza tra questo test e "omit", che assume come ipotesi
nulla l'uguaglianza a zero di tutti i coefficienti di un gruppo di variabili
indipendenti.

Accesso dal menù:    Finestra del modello, /Test/Somma dei coefficienti

# coint Tests

Argomenti:  ordine variabile-dipendente variabili-indipendenti 
Opzioni:    --nc (non include la costante)
            --ct (include la costante e il trend)
            --ctt (include la costante e il trend quadratico)
            --skip-df (non esegue i test DF sulle variabili individuali)
            --test-down (scelta automatica dell'ordine dei ritardi)
            --verbose (mostra dettagli extra sulle regressioni)
Esempi:     coint 4 y x1 x2
            coint 0 y x1 x2 --ct --skip-df

Test di cointegrazione di Engle-Granger. La procedura predefinita è la
seguente: (1) eseguire dei test Dickey-Fuller aumentati, sull'ipotesi nulla
che ognuna delle variabili elencate abbia una radice unitaria; (2) stimare
la regressione di cointegrazione; (3) eseguire un test DF sui residui della
regressione di cointegrazione. Se si usa l'opzione --skip-df, il passo (1)
viene saltato.

Se l'ordine di ritardo specificato è positivo, tutti i test Dickey-Fuller
utilizzano questo ordine. Se l'ordine indicato viene preceduto da un segno
meno, viene interpretato come l'ordine massimo, e l'ordine utilizzato
effettivamente viene ricavato con la stessa procedura di test "all'indietro"
descritta per il comando "adf".

L'impostazione predefinita consiste nell'includere una costante nella
regressione di cointegrazione; se si vuole omettere la costante, basta usare
l'opzione --nc. Se si vuole aggiungere all'elenco dei termini deterministici
della regressione un trend lineare o quadratico, basta usare le opzioni --ct
o --ctt. Queste opzioni sono mutualmente esclusive.

Test di cointegrazione di Engle-Granger. La procedura predefinita è la
seguente: (1) eseguire dei test Dickey-Fuller aumentati, sull'ipotesi nulla
che ognuna delle variabili elencate abbia una radice unitaria; (2) stimare
la regressione di cointegrazione; (3) eseguire un test DF sui residui della
regressione di cointegrazione. Se si attiva la casella Salta i test DF
iniziali, il passo (1) viene saltato.

I pvalue per questo test si basano su MacKinnon (1996). Il codice relativo
è stato incluso per gentile concessione dell'autore.

Accesso dal menù:    /Modello/Serie storiche/Test di cointegrazione/Engle-Granger

# coint2 Tests

Argomenti:  ordine lista-y [ ; lista-x ] [ ; lista-rx ] 
Opzioni:    --nc (senza costante)
            --rc (costante vincolata)
            --uc (costante non vincolata)
            --crt (costante e trend vincolato)
            --ct (costante e trend non vincolato)
            --seasonals (include dummy stagionali centrate)
            --asy (registra i p-value asintotici)
            --silent (non mostra nulla)
            --quiet (mostra solo i test)
            --verbose (mostra i dettagli delle regressioni ausiliarie)
Esempi:     coint2 2 y x
            coint2 4 y x1 x2 --verbose
            coint2 3 y x1 x2 --rc

Esegue il test di Johansen per la cointegrazione tra le variabili della
lista-y per l'ordine specificato di ritardi. Per dettagli, si veda la guida
all'uso di gretl oppure Hamilton (1994), capitolo 20. I valori critici sono
calcolati con l'approssimazione gamma di J. Doornik (Doornik, 1998). Per il
test traccia, vengono formiti due set di valori critici: asintotici e
aggiustati per l'ampiezza campionaria. Di default, l'accessore $pvalue
riporta la variante aggiustata, ma i valori asintotici possono essere
ottenuti usando l'opzione --asy

L'inclusione di trend deterministici nel modello è controllata dalle
opzioni del comando. Se non si indica alcuna opzione, viene inclusa una
"costante non vincolata", che permette la presenza di un'intercetta diversa
da zero nelle relazioni di cointegrazione e di un trend nei livelli delle
variabili endogene. Nella letteratura originata dal lavoro di Johansen (si
veda ad esempio il suo libro del 1995), si fa riferimento a questo come al
"caso 3". Le prime quattro opzioni mostrate sopra, che sono mutualmente
esclusive, producono rispettivamente i casi 1, 2, 4 e 5. Il significato di
questi casi e i criteri per scegliere tra di essi sono spiegati nella la
guida all'uso di gretl.

Le liste opzionali lista-x e lista-rx permettono di controllare per
specifiche variabili esogene che entrano nel sistema in modo non vincolato
(lista-x) o vincolate allo spazio di cointegrazione (lista-rx). Queste liste
vanno separate tra di loro e dalla lista-y usando il carattere punto e
virgola.

L'opzione --seasonals, che può accompagnare una qualsiasi delle altre
opzioni, specifica l'inclusione di un gruppo di variabili dummy stagionali
centrate. Questa opzione è disponibile solo per dati trimestrali o mensili.

La tabella seguente fornisce un esempio di interpretazione dei risultati del
test nel caso di 3 variabili. H0 denota l'ipotesi nulla, H1 l'ipotesi
alternativa e c il numero delle relazioni di cointegrazione.

                 Rango    Test traccia       Test Lmax
                          H0     H1          H0     H1
                 ---------------------------------------
                  0      c = 0  c = 3       c = 0  c = 1
                  1      c = 1  c = 3       c = 1  c = 2
                  2      c = 2  c = 3       c = 2  c = 3
                 ---------------------------------------

Si veda anche il comando "vecm".

Accesso dal menù:    /Modello/Serie storiche/Test di cointegrazione/Johansen

# corr Statistics

Argomento:  [ lista-variabili ] 
Opzioni:    --uniform (assicura l'uniformità del campione)
            --spearman (Rho di Spearman)
            --kendall (Tau di Kendall)
            --verbose (mostra i ranghi)
Esempi:     corr y x1 x2 x3
            corr ylist --uniform
            corr x y --spearman

Per impostazione predefinita, mostra le coppie di coefficienti di
correlazione (la correlazione del prodotto dei momenti di Pearson) per le
variabili date nella lista-variabili, o per tutte le variabili del dataset
se non viene specificata alcuna lista-variabili. Il comportamento
predefinito consiste nell'usare tutte le osservazioni disponibili per
calcolare ognuno dei coefficienti, ma se si usa l'opzione --uniform il
campione verrà limitato (se necessario) in modo che per tutti i
coefficienti venga usato lo stesso insieme di osservazioni. Questa opzione
ha effetto solo se le diverse variabili contengono un numero diverso di
valori mancanti.

Le opzioni (mutualmente esclusive) --spearman e --kendall producono
rispettivamente, la correlazione di rango di Spearman (rho) e la
correlazione di rango di Kendall (tau), invece del solito coefficiente di
Pearson. Quando si usa una di queste opzioni, la lista-variabili deve
contenere solo due variabili.

Quando viene calcolata la correlazione di rango, si può usare l'opzione
--verbose per mostrare i dati originali e ordinati (altrimenti questa
opzione verrà ignorata).

Accesso dal menù:    /Visualizza/Matrice di correlazione
Accesso alternativo: Menù pop-up nella finestra principale (selezione multipla)

# corrgm Statistics

Argomenti:  variabile [ max-ritardo ] 
Opzione:    --plot=mode-or-filename (si veda sotto)
Esempio:    corrgm x 12

Mostra i valori della funzione di autocorrelazione per la variabile
specificata (dal nome o dal numero). I valori sono definiti come rho(u_t,
u_t-s) dove u_t è la t-esima osservazione della variabile u e s è il
numero dei ritardi.

Vengono mostrate anche le autocorrelazioni parziali (calcolate con
l'algoritmo di Durbin-Levinson), ossia al netto dell'effetto dei ritardi
intermedi. Il comando produce anche un grafico del correlogramma e mostra la
statistica Q di Ljung-Box per testare l'ipotesi nulla che la serie sia
"white noise" (priva di autocorrelazione). La statistica si distribuisce
asintoticamente come chi-quadro con gradi di libertà pari al numero di
ritardi specificati.

Se viene specificato un valore max-ritardo, la lunghezza del correlogramma
viene limitata al numero di ritardi specificato, altrimenti viene scelta
automaticamente in funzione della frequenza dei dati e del numero di
osservazioni.

Di default viene mostrato un grafico del correlogramma: un grafico gnuplot
in modalità interattiva o un grafico ASCII in modalità batch. Questo
comportamento può essere modificato con l'opzione --plot. Per questa
opzione i parametri accettabili sono none (per eliminare il grafico); ascii
(per produrre un grafico in formato testo anche in modalità interattiva);
display (per produrre un grafico gnuplot anche in modalità batch); oppure
il nome di un file. In quest'ultimo caso l'effetto è quello descritto per
l'opzione --output del comando "gnuplot".

Se il comando va a buon fine, gli accessori $test e $pvalue conterranno i
valori corrispondenti per la statistica di Ljung-Box, per l'ordine
max-ritardo. Peraltro, se si vuole semplicemente calcolare la statistica Q
senza che il programma produca alcun output, consigliamo di usare la
funzione "ljungbox" anziché questo comando.

Accesso dal menù:    /Variabile/Correlogramma
Accesso alternativo: Menù pop-up nella finestra principale (selezione singola)

# cusum Tests

Opzioni:    --squares (esegue il test CUSUMSQ)
            --quiet (stampa solamente il test di Harvey-Collier)

Va eseguito dopo la stima di un modello OLS. Esegue il test CUSUM (o, se si
usa l'opzione --squares, il test CUSUMSQ ) per la stabilità dei parametri.
Viene calcolata una serie di errori di previsione per il periodo successivo,
attraverso una serie di regressioni: la prima usa le prime k osservazioni e
viene usata per generare la previsione della variabile dipendente per
l'osservazione k + 1; la seconda usa le prime k + 1 osservazioni per
generare una previsione per l'osservazione k + 2 e cos via (dove k è il
numero dei parametri nel modello originale).

Viene mostrata, anche graficamente, la somma cumulata degli errori scalati
di previsione (o dei quadrati degli errori). L'ipotesi nulla della
stabilità dei parametri è rifiutata al livello di significatività del 5
per cento se la somma cumulata va al di fuori delle bande di confidenza al
95 per cento.

Nel caso di test CUSUM, viene mostrata anche la statistica t di
Harvey-Collier per testare l'ipotesi nulla della stabilità dei parametri.
Si veda il Capitolo 7 di Econometric Analysis di Greene, per i dettagli. Per
il test CUSUMSQ, la banda di confidenza al 95% è calcolata usando
l'algoritmo descritto in Edgerton e Wells (1994).

Accesso dal menù:    Finestra del modello, /Test/CUSUM(SQ)

# data Dataset

Argomento:  lista-variabili 
Opzione:    --quiet (non mostra i risultati tranne che in caso di errore)

Legge le variabili nella lista-variabili da un database (gretl, RATS 4.0 o
PcGive), che deve essere stato precedentemente aperto con il comando "open".
La frequenza dei dati l'intervallo del campione possono essere impostati
usando i comandi "setobs" e "smpl" prima di questo comando. Ecco un esempio
completo:

	open macrodat.rat 
	setobs 4 1959:1 
	smpl ; 1999:4 
	data GDP_JP GDP_UK

Questi comandi aprono un database chiamato macrodat.rat, impostano un
dataset trimestrale che inizia nel primo trimestre del 1959 e finisce nel
quarto trimestre del 1999 e infine importano le serie GDP_JP e GDP_UK.

Se non si specificano setobs e smpl nel modo descritto, la frequenza dei
dati e l'intervallo del campione vengono impostati usando la prima variabile
letta dal database.

Se le serie da leggere hanno frequenza maggiore di quella impostata nel
dataset, è possibile specificare un metodo di compattamento, come mostrato
di seguito

	data (compact=average) LHUR PUNEW

I quattro metodi di compattamento disponibili sono "average" (usa la media
delle osservazioni ad alta frequenza), "last" (usa l'ultima osservazione),
"first" e "sum". Se non si specifica alcun metodo, verrà usata la media
delle osservazioni.

Accesso dal menù:    /File/Database

# dataset Dataset

Argomenti:  parola-chiave parametri 
Esempi:     dataset addobs 24
            dataset compact 1
            dataset compact 4 last
            dataset expand interp
            dataset transpose
            dataset sortby x1
            dataset resample 500
            dataset renumber x 4
            dataset clear

Esegue varie operazioni sull'intero dataset, a seconda della parola-chiave
usata, che può essere addobs, insobs, clear, compact, expand, transpose,
sortby, dsortby, resample o renumber. Nota: questi comandi non sono
disponibili quando sul dataset è definito un sotto-campione ottenuto
selezionando le osservazioni con un criterio Booleano.

addobs: deve essere seguito da un intero positivo. Aggiunge il numero
specificato di osservazioni alla fine del dataset, tipicamente a scopo di
ottenere delle previsioni. I valori della maggior parte delle variabili
nell'intervallo aggiunto sono impostati come valori mancanti, ma alcune
variabili deterministiche, ad esempio le tendenze lineari e le variabili
dummy periodiche, sono riconosciute ed estese.

insobs: Deve essere seguito da un intero positivo inferiore o uguale al
numero corrente di osservazioni. Inserisce una singola ossrevazione nella
posizione specificata. Tutti i dati successivi sono spostati di una
posizione e il dataset è allungato di un'osservazione. In corrispondenza
della nuova osservazione a tutte le variabili, a parte la costante, vengono
assegnati valori mancanti. Questa azione non è disponibile in dataset
panel.

clear: Non richiede parametri. Elimina il campione corrente e riporta gretl
al suo stato iniziale senza dati.

compact: deve essere seguito da un intero positivo che rappresenta la nuova
frequenza dei dati, che dovrebbe essere minore di quella attuale (ad esempio
un valore 4 quando la frequenza attuale è 12 significa che si compatterà
un dataset mensile in uno trimestrale). Questo comando è disponibile solo
se il dataset contiene serie storiche: compatta tutte le serie del dataset
alla nuova frequenza. È possibile dare un secondo parametro, tra sum, first
o last, per specificare, rispettivamente, di compattare usando la somma dei
valori alla frequenza maggior, i valori di inizio periodo, o di fine
periodo. Il comportamento predefinito consiste nel prendere la media dei
valori sul periodo.

expand: Questo comando è disponibile solo per serie storiche annuali o
trimestrali. I dati annuali vengono espansi a trimestrali, quelli
trimestrali a mensili. Per default, tutte le serie nel dataset verranno
espanse assegnando alle nuove osservazioni i valori del periodo
corrispondente nel vecchio dataset, ma con il modificatore interp le serie
vengono espanse usando l'interpolazione di Chow-Lin (si veda Chow e Lin,
1971): i regressori sono costante e trend quadratico; il disturbo è assunto
AR(1).

transpose: non richiede parametri aggiuntivi. Traspone il dataset attuale:
ogni osservazione (riga) del dataset attuale diventerà una variabile
(colonna), e ogni variabile un'osservazione. Questo comando è utile quando
si importano da fonti esterne dei dati organizzati con le variabili disposte
per riga.

sortby: richiede il nome di una variabile o di una lista. Con una variabile,
questa viene usata come criterio di ordinamento. Le osservazioni di tutte le
altre variabili del dataset sono riordinate secondo valori crescenti della
variabile indicata. Nel caso di una lista, il comando procede
gerarchicamente: il primo criterio di rdinamento è la prima variabile, e
così via. Questo comando è disponibile solo per dati non datati.

dsortby: funziona come sortby ma riordina le osservazioni secondo i valori
decrescenti della variabile specificata.

resample: costruisce un nuovo dataset attraverso un campionamento causale,
con reimmissione, delle righe del dataset attuale. È richiesto un
argomento, ossia il numero di righe da includere, che può essere minore,
uguale o maggiore del numero di osservazioni nei dati originali. Il dataset
originale può essere recuperato usando il comando smpl full.

renumber: Richiede il nome di una variabile esistente seguito da un intero
compreso fra 1 e il numero delle variabili nel campione meno 1. Sposta la
serie specificata nel dataset nella posizione indicata, rinumerando le altre
variabili di conseguenza. (La posizione 0 è occupata dalla costante che non
può essere spostata.)

Accesso dal menù:    /Dati

# debug Programming

Argomento:  function 

Un debugger sperimentale per funzioni definite dall'utente, disponibile a
partire dalla linea di comando, gretlcli e dalla console GUI. Il comando
debug dovrebbe essere utilizzato dopo aver definito la funzione in questione
ma prima di chiamarla. Il suo effetto è quello di sospendere l'esecuzione
quando la funzione viene chiamata; la sospensione è segnalata dalla
presenza di un prompt speciale.

Una volta attivato il prompt di debug è possibile digitare next per
eseguire il comando successivo della funzione, o continue per far proseguire
l'esecuzione della funzione senza ulteriori arresti. Questi comandi possono
essere rispettivamente abbreviati con n e c. Al prompt di debug è anche
possibile interpolare un'istruzione, per esempio un comando print per
esaminare il valore corrente di qualche variabile di interesse.

# delete Dataset

Argomento:  [ lista-variabili ] 
Opzioni:    --db (rimuove dal database aperto)
            --type=nome di tipo (tutte le variabili di un dato tipo)

Questo comando è uno strumento multi-uso per eliminare variabili con un
nome (serie, scalari, matrici, stringhe o bundle). Deve essere usato con
cautela: non viene chiesta alcuna conferma.

Nel caso di variabili, varname può essere il nome di una lista, e in questo
caso vengono eliminate tutte le variabili incluse in essa, oppure può
essere una lista esplicita di variabili indicate per nome o numero ID. Si
noti che quando cancellate variabili, quelle con numeri ID maggiori di
quelli inclusi nella lista da cancellare saranno rinumerati.

Se si usa l'opzione --db, il comando rimuove le variabili elencate non dal
dataset attuale ma da un database gretl, assumendo che questo sia stato
aperto in precedenza e che l'utente abbia il permesso di scrittura sul file
che contiene il database. Si veda anche il comando "open".

Se viene indicata l'opzione --type è necessario accompagnarla con uno dei
nomi di tipi seguenti: matrix, bundle, string, list o scalar. L'effetto è
quello di cancellare tutte le variabili di un certo tipo. Solo in questo
caso non è necessario fornire l'argomento varname.

Accesso dal menù:    Pop-up nella finestra principale (selezione singola)

# diff Transformations

Argomento:  lista-variabili 

Calcola la differenza prima di ogni variabile nella lista-variabili e la
salva in una nuova variabile il cui nome è prefissato con d_. Quindi "diff
x y" crea le nuove variabili

	d_x = x(t) - x(t-1)
        d_y = y(t) - y(t-1)

Accesso dal menù:    /Aggiungi/Differenze

# difftest Tests

Argomenti:  var1 var2 
Opzioni:    --sign (Test del segno, scelta predefinita)
            --rank-sum (Test "rank-sum" di Wilcoxon)
            --signed-rank (Test "signed-rank" di Wilcoxon)
            --verbose (Mostra informazioni aggiuntive)

Esegue un test non parametrico per la differenza tra due popolazioni o
gruppi; il tipo di test dipende dall'opzione usata.

Con l'opzione --sign, viene eseguito il test del segno, che si basa sul
fatto che per due campioni x e y estratti casualmente dalla stessa
distribuzione, la probabilità che valga x_i > y_i per ogni osservazione i
dovrebbe valere 0.5. La statistica test è w, ossia il numero di
osservazioni per cui vale x_i > y_i. Sotto l'ipotesi nulla, questa grandezza
si distribuisce come una binomiale con parametri (n, 0.5), dove n è il
numero di osservazioni.

Con l'opzione --rank-sum, viene eseguito il test "rank-sum" di Wilcoxon.
Questo test procede ordinando le osservazioni estratte da entrambi i
campioni dalla più piccola alla più grande, e quindi calcolando la somma
dei ranghi delle osservazioni da uno dei campioni. I due campioni non devono
necessariamente avere la stessa dimensione: se sono diversi, viene usato il
campione più piccolo per calcolare la somma dei ranghi. Sotto l'ipotesi
nulla che i campioni siano estratti da popolazioni con la stessa mediana, la
distribuzione di probabilità della somma dei ranghi può essere calcolata
per ogni valore dell'ampiezza dei due campioni, mentre per campioni
abbastanza ampi essa approssima la distribuzione normale.

Con l'opzione --signed-rank, viene eseguito il test "signed-rank" di
Wilcoxon. Questo test è valido per "coppie di campioni", come possono
essere ad esempio i valori di una variabile in un gruppo di individui prima
e dopo un certo trattamento. Il test procede calcolando le differenze tra le
coppie di osservazioni x_i - y_i, ordinando queste differenze per valore
assoluto e assegnando ad ogni coppia un valore di rango con segno, in cui il
segno rispecchia il segno della differenza. Quindi viene calcolato W_+, la
somma di tutti i ranghi con segno positivo. Come avviene per il test
rank-sum, questa statistica ha una distribuzione precisa nell'ipotesi nulla
che la differenza mediana sia zero, distribuzione che converte alla normale
nel caso di campioni abbastanza ampi.

Usando l'opzione --verbose con i test di Wilcoxon viene mostrato
l'ordinamento delle osservazioni (l'opzione non ha effetto se usata con il
test del segno).

# discrete Transformations

Argomento:  lista-variabili 
Opzione:    --reverse (marca le variabili come continue)

Marca ogni variabile della lista-variabili come discreta. In modalità
predefinita, tutte le variabili sono considerate come continue; marcando una
variabile come discreta, essa viene trattata in modo speciale nei diagrammi
di frequenza, e può esere usata con il comando "dummify".

Usando l'opzione --reverse, l'operazione viene invertita, ossia, le
variabili nella lista-variabili sono marcate come continue.

Accesso dal menù:    /Variabile/Modifica attributi

# dpanel Estimation

Argomento:  p ; depvar indepvars [ ; instruments ] 
Opzioni:    --quiet (non mostra il modello stimato)
            --vcv (mostra la matrice di covarianza)
            --two-step (calcola la stima GMM a due passi)
            --system (aggiunge equazioni nei livelli)
            --time-dummies (aggiunge variabili dummy temporali)
            --dpdstyle (emula il pacchetto DPD per Ox)
            --asymptotic (errori standard asintotici non modificati)
Esempi:     dpanel 2 ; y x1 x2
            dpanel 2 ; y x1 x2 --system
            dpanel {2 3} ; y x1 x2 ; x1
            dpanel 1 ; y x1 x2 ; x1 GMM(x2,2,3)
            Vedi anche bbond98.inp

Stima modelli dinamici per dati di panel (in altre parole, modelli panel con
uno o più ritardi della variabile dipendente) usando il metodo GMM-DIF o
quello GMM-SYS.

Il paramtro p rappresenta l'ordine autoregressivo della variabile
dipendente. Nel caso più semplice si tratta di uno scalare, ma per
specificare un insieme di ritardi (non consecutivi) da è possibile indicare
una matrice definita in precedenza.

La variabile dipendente e i regressori dovrebbero essere indicati in
livelli; il comando provvede autonomamente a differenziarli (dato che questo
stimatore usa le differenze per eliminare gli effetti individuali).

L'ultimo campo (opzionale) nel comando serve a specificare strumenti. Se
questi ultimi non vengono indicati si assume che tutte le variabili
indipendenti siano strettamente esogene. Se si sceglie di specificare alcuni
strumenti è opportuno includere nell'elenco anche le variabili indipendenti
strettamente esogene. Nel caso di regressori predeterminati è possibile
usare la funzione GMM per includere uno specifico intervallo di ritardi
seguendo uno schema diagonale a blocchi. Una situazione di questo tipo è
stata illustrata in precedenza nel terzo esempio. Il primo argomento di GMM
è il nome della variabile in questione, il secondo è il ritardo minimo da
usare come strumento e il terzo è il ritardo massimo. La stessa sintassi
può essere utilizzata con la funzione GMMlevel per specificare strumenti di
tipo GMM per le equazioni nei livelli.

Di default vengono riportati (con errori standard robusti) i risultati della
stima al primo stadio; la stima al secondo stadio può essere richiesta
indicato l'opzione corrispondente. In entrambi i casi vengono forniti i test
di autocorrelazione del primo e del secondo ordine, così come il test di
sovraidentificazione di Sargan e un test di Wald della significatività
congiunta dei regressori. Si noti che in questo modello nelle differenze
l'autocorrelazione del primo ordine non impedisce che il modello sia valido;
l'autocorrelazione al secondo ordine, tuttavia, viola le ipotesi statistiche
che ne sono alla base.

Nel caso della stima a due passi, gli errori standard sono per default
calcolati usando la correzione per campioni finiti suggerita da Windmeijer
(2005). In generale l'inferenza basata sugli errori standard asintotici
associati allo stimatore al secondo stadio è considerata inaffidabile, ma
se per qualche ragione desiderate conoscere il loro valore potete usare
l'opzione --asymptotic per disattivare la correzione di Windmeijer.

Se viene indicata l'opzione --time-dummies il comando aggiunge ai regressori
specificati un insieme di variabili dummy. Il numero di queste ultime è
pari al numero massimo di periodi usati nella stima meno uno, allo scopo di
evitare di avere collinearità perfetta con la costante. Le dummy vengono
incluse in differenza, a meno che non sia indicata l'opzione --dpdstyle; in
questo caso le dummy sono incluse in livello.

Per ulteriori dettagli ed esempi, si veda la guida all'uso di gretl.

Accesso dal menù:    /Model/Panel/Dynamic panel model

# dummify Transformations

Argomento:  lista-variabili 
Opzioni:    --drop-first (omette dalla codifica il valore minimo)
            --drop-last (omette dalla codifica il valore massimo)

Per ogni variabile rilevante nella lista-variabili, crea un insieme di
variabili dummy che codificano i valori distinti di quella variabile. Le
variabili rilevanti sono quelle che sono state marcate esplicitamente come
discrete, o quelle che assumono un numero limitato di valori che devono
essere "abbastanza arrotondati" (multipli di 0.25).

Per impostazione predefinita, viene aggiunta una variabile dummy per ognuno
dei valori distinti della variabile in questione. Ad esempio, se una
variabile discreta x ha 5 valori distinti, verranno create 5 variabili
dummy, di nome Dx_1, Dx_2 e così via. La prima variabile dummy avrà valore
1 per le osservazioni in cui x assume il suo valore minimo, e 0 altrove; la
successiva variabile dummy avrà valore 1 dove x assume il secondo tra i
suoi valori, e così via. Se viene usata una delle opzioni --drop-first o
--drop-last, il più basso o il più alto dei valori della variabile viene
omesso dalla codifica (questa funzione può essere utile per evitare la
cosiddetta "trappola delle variabili dummy").

Questo comando può anche essere usato nel contesto di una regressione. Ad
esempio, la riga seguente specifica un modello in cui y viene regredita
sull'insieme di variabili dummy che codificano x (in questo contesto non è
possibile passare opzioni al comando "dummify").

	ols y dummify(x)

# duration Estimation

Argomenti:  depvar indepvars [ ; censvar ] 
Opzioni:    --exponential (usa la distribuzione esponenziale)
            --loglogistic (usa la distribuzione log-logistica)
            --lognormal (usa la distribuzione log-normale)
            --medians (i valori previsti sono mediane)
            --robust (errori standard robusti (QML))
            --cluster=clustvar (v. "logit" per una spiegazione)
            --vcv (mostra la matrice di covarianza)
            --verbose (mostra dettagli delle iterazioni)
Esempi:     duration y 0 x1 x2
            duration y 0 x1 x2 ; cens

Stima un modello di durata: la variabile dipendente (che deve essere
positiva) rappresenta la durata di un certo fenomeno, per esempio la
lunghezza di un periodo di disoccupazione per una cross-section di
intervistati. Di default viene utilizzata una distribuzione Weibull, ma sono
disponibili anche le distribuzioni esponenziale, log-logistica e
log-normale.

Se alcune delle durate misurate sono censurate a destra (e.g. il periodo di
disoccupazione di un individuo non si è concluso all'interno del periodo di
osservazione), deve essere specificato l'argomento accessorio censvar che
indica una variabile i cui valori positivi segnalano osservazioni censurate
a destra.

Di default i valori stimati ottenuti mediante l'accessore $yhat
rappresentano le medie condizionali delle durate; se tuttavia viene indicata
l'opzione --medians, $yhat fornisce le mediane condizionali.

Vedi la guida all'uso di gretl per ulteriori dettagli.

Accesso dal menù:    /Model/Nonlinear models/Duration data...

# elif Programming

Si veda "if".

# else Programming

Si veda "if". Si noti che "else" dev'essere su un linea a sé stante, prima
del comando corrispondente. Si può aggiungere un commento, come ad esempio

	else # OK, fa' un'altra cosa

ma nn si può aggiungere un comando, come in

	else x = 5 # wrong!

# end Programming

Termina un blocco di comandi di qualsiasi tipo. Ad esempio, "end system"
termina un "system" (sistema di equazioni).

# endif Programming

Si veda "if".

# endloop Programming

Indica la fine di un ciclo (loop) di comandi. Si veda "loop".

# eqnprint Printing

Argomento:  [ -f nomefile ] 
Opzione:    --complete (crea un documento completo)

Va eseguito dopo la stima di un modello. Stampa il modello stimato sotto
forma di equazione LaTeX. Se viene specificato un nome di file usando
l'opzione -f, il risultato viene scritto in quel file, altrimenti viene
scritto in un file il cui nome ha la forma equation_N.tex, dove N è il
numero di modelli stimati finora nella sessione in corso. Si veda anche
"tabprint".

Usando l'opzione --complete, il file LaTeX è un documento completo, pronto
per essere processato; altrimenti il file va incluso in un documento.

Accesso dal menù:    Finestra del modello, /LaTeX

# equation Estimation

Argomenti:  variabile-dipendente variabili-indipendenti 
Esempio:    equation y x1 x2 x3 const

Specifica un'equazione all'interno di un sistema di equazioni (si veda
"system"). La sintassi per specificare un'equazione in un sistema SUR è la
stessa usata ad esempio in "ols". Per un'equazione in un sistema con minimi
quadrati a tre stadi, invece è possibile usare una specificazione simile a
quella usata per OLS e indicare una lista di strumenti comuni usando
l'istruzione "instr" (si veda ancora "system"), oppure si può usare la
stessa sintassi di "tsls".

# estimate Estimation

Argomenti:  [ nome-sistema ] [ stimatore ] 
Opzioni:    --iterate (itera fino alla convergenza)
            --no-df-corr (nessuna correzione per i gradi di libertà)
            --geomean (si veda oltre)
            --quiet (non mostra i risultati)
            --verbose (mostra i dettagli delle iterazioni)
Esempi:     estimate "Klein Model 1" method=fiml
            estimate Sys1 method=sur
            estimate Sys1 method=sur --iterate

Esegue la stima di un sistema di equazioni, che deve essere stato definito
in precedenza usando il comando "system". Per prima cosa va indicato il nome
del sistema, racchiuso tra virgolette se contiene spazi, quindi il tipo di
stimatore, preceduto dalla stringa method=. Gli stimatori disponibili sono:
"ols", "tsls", "sur", "3sls", "fiml" o "liml". Questi argomento sono
opzionali si il sistema in questione è già stato stimato e occupa il posto
dell'"ultimo modello"; in tal caso, per default viene usato il metodo di
stima precedente.

Se al sistema in questione sono stati imposti dei vincoli (si veda il
comando "restrict"), la stima sarà soggetta a tali vincoli.

Se il metodo di stima è "sur" o "3sls" e viene usata l'opzione --iterate,
lo stimatore verrà iterato. Nel caso di SUR, se la procedura converge, i
risultati saranno stime di massima verosimiglianza. Invece l'iterazione
della procedura dei minimi quadrati a tre stadi non produce in genere
risultati di massima verosimiglianza a informazione completa. L'opzione
--iterate viene ignorata con gli altri metodi di stima.

Se vengono scelti gli stimatori "equazione per equazione" "ols" o "tsls",
nel calcolo degli errori standard viene applicata in modo predefinito una
correzione per i gradi di libertà, che può essere disabilitata usando
l'opzione --no-df-corr. Questa opzione non ha effetti nel caso vengano usati
altri stimatori, che non prevedono correzioni per i gradi di libertà.

La formula usata in modo predefinito per calcolare gli elementi della
matrice di covarianza tra equazioni è

  sigma(i,j) = u(i)' * u(j) / T

Se viene usata l'opzione --geomean, viene applicata una correzione per i
gradi di libertà secondo la formula

  sigma(i,j) = u(i)' * u(j) / sqrt((T - ki) * (T - kj))

dove i k indicano il numero di parametri indipendenti in ogni equazione.

Se si usa l'opzione --verbose e un metodo iterativo, vengono mostrati i
dettagli delle iterazioni.

# fcast Prediction

Argomenti:  [ oss-iniziale oss-finale ] [ passi-avanti ] [ nome-variabile ] 
Opzioni:    --dynamic (crea previsioni dinamiche)
            --static (crea previsioni statiche)
            --out-of-sample (genera previsioni fuori dal campione)
            --no-stats (non mostra le statistiche di previsione)
            --quiet (non mostra le previsioni)
            --rolling (vedi sotto)
            --plot=nome di file (vedi sotto)
Esempi:     fcast 1997:1 2001:4 f1
            fcast fit2
            fcast 2004:1 2008:3 4 rfcast --rolling

Deve seguire un comando di stima. Calcola previsioni per l'intervallo
specificato. A seconda del tipo di modello, calcola anche gli errori
standard (si veda oltre).

Deve seguire un comando di stima. Calcola previsioni per un certo intervallo
delle osservazioni. L'intervallo può essere specificato indicando
oss-iniziale e oss-finale, oppure con l'opzione --out-of-sample (in questo
caso la previsione sarà per le osservazioni successive a quelle su cui è
stato stimato il modello); se non si usa alcuna opzione, l'intervallo sarà
quello attualmente impostato. Se si sceglie una previsione fuori dal
campione ma non sono disponibili osservazioni, viene segnalato un errore. A
seconda del tipo di modello, calcola anche gli errori standard (si veda
oltre). L'opzione --rolling produce un comportamento speciale spiegato
oltre.

Se l'ultimo modello stimato consiste in un'equazione singola, l'argomento
opzionale nome-variabile ha l'effetto seguente: i valori della previsione
non sono mostrati, ma vengono salvati nel dataset con il nome di variabile
indicato. Se l'ultimo modello stimato è un sistema di equazioni,
nome-variabile ha un effetto diverso, ossia seleziona una particolare
varabile endogena per cui effettuare la previsione (l'impostazione
predefinita consiste nel produrre previsioni per tutte le variabili
endogene). Nel caso del sistema, o se non viene specificata nome-variabile,
i valori della previsione possono essere recuperati usando la varaiabile
accessoria $fcast, mentre gli errori standard, se disponibili, con $fcerr.

La scelta tra previsione statica e dinamica è rilevante solo nel caso di
modelli dinamici, che comprendono un processo di errore autoregressivo, o
che comprendono uno o più valori ritardati della variabile dipendente come
regressori. Le previsioni statiche sono per il periodo successivo, basate
sui valori effettivi nel periodo precedente, mentre quelle dinamiche usano
la regola della previsione a catena. Ad esempio, se la previsione per y nel
2008 richiede come input il valore di y nel 2007, non è possibile calcolare
una previsione statica se non si hanno dati per il 2007. È possibile
calcolare una previsione dinamica per il 2008 se si dispone di una
precedente previsione per y nel 2007.

La scelta predefinita consiste nel fornire una previsione statica per ogni
porzione dell'intervallo di previsione che fa parte dell'intervallo del
campione su cui il modello è stato stimato, e una previsione dinamica (se
rilevante) fuori dal campione. L'opzione dynamic richiede di produrre
previsioni dinamiche a partire dalla prima data possibile, mentre l'opzione
static richiede di produrre previsioni statiche anche fuori dal campione.

L'opzione rolling al momento è disponibile solo per i modelli composti da
una singola equazione e stimati via OLS. Quando si usa questa opzione, le
previsioni calcolate sono ricorsive, ossia: ogni previsione è generata da
una stima del modello che usa i dati a partire da un certo punto fisso
(ossia l'inizio dell'intervallo del campione usato per la stima originaria)
fino alla data di previsione meno k osservazioni, dove k è il numero di
passi-avanti specificato come argomento. Le previsioni sono sempre dinamiche
quando è possibile. Si noti che l'argomento passi-avanti deve essere
utilizzato solo insieme all'opzione rolling.

L'opzione --plot (disponibile solo nel caso della stima di un modello
uniequazionale) consente di ottenere un file con un grafico delle
previsioni. L'estensione dell'argomento filename di questa opzione controlla
il formato del grafico: .eps per EPS, .pdf per PDF, .png per PNG, .plt per
un file di comandi gnuplot. Il nome di file dummy display può essere usato
per mostrare il grafico in una finestra. Per esempio,

	fcast --plot=fc.pdf

genererà un grafico in formato PDF. Vengono rispettati gli indirizzi di
file assoluti; in caso contrario i fail vengono scritti nella directory di
lavoro di gretl.

La natura degli errori standard della previsione (se disponibili) dipende
dalla natura del modello e della previsione. Per i modelli lineari statici,
gli errori standard sono calcolati seguendo il metodo delineato in Davidson
and MacKinnon (2004); essi incorporano sia l'incertezza dovuta al processo
d'errore, sia l'incertezza dei parametri (sintetizzata dalla matrice di
covarianza delle stime dei parametri). Per modelli dinamici, gli errori
standard della previsione sono calcolati solo nel caso di previsione
dinamica, e non incorporano incertezza dei parametri. Per modelli non
lineari, al momento non sono disponibili errori standard della previsione.

Accesso dal menù:    Finestra del modello, /Analisi/Previsioni

# foreign Programming

Sintassi:   foreign language=lang
Opzioni:    --send-data (pre-carica il dataset attuale)
            --quiet (sopprime l'output dal programma esterno)

Questo comando apre una modalità speciale, in cui vengono accettati comandi
che verranno eseguiti da un programma esterno. Con il comando end foreign si
esce da questa modalità e i comandi verranno eseguiti.

Al momento, i programmi esterni compatibili con questa modalità sono
(language=R), Ox di Jurgen Doornik Ox (language=Ox), GNU Octave
(language=Octave), Python e, in minor misura, Stata. I nomi dei programmi
esterni sono case-insensitive.

Con R, Octave e Stata l'opzione --send-data ha l'effetto di rendere
disponibile all'interno del programma di destinazione l'intero dataset
corrente.

Si veda la la guida all'uso di gretl per dettagli ed esempi.

# fractint Statistics

Argomenti:  series [ order ] 
Opzioni:    --gph (calcola il test di Geweke e Porter-Hudak)
            --all (calcola entrambi i test)
            --quiet (non mostra i risultati)

Verifica la presenza di integrazione frazionale ("long memory") per la
variabile specificata. L'ipotesi nulla è che l'ordine di integrazione della
variabile sia zero. Di default viene utilizzato lo stimatore locale di
Whittle (Robinson, 1995), ma se si indica l'opzione --gph il comando usa il
test GPH (Geweke and Porter-Hudak, 1983). L'opzione --all permette di
ottenere i risultati di entrambi i test.

Per maggiori dettagli su questo tipo di test, v. Phillips e Shimotsu (2004).

Se non si specifica l'argomento opzionale order, l'ordine del test (o dei
test) è automaticamente fissato al più piccolo fra T/2 e T^0.6.

I risultati possono essere recuperati usando gli accessori $test e $pvalue.
Questi valori sono basati sullo stimatore locale di Whittle a meno che non
sia stata indicata l'opzione --gph.

Accesso dal menù:    /Variable/Unit root tests/Fractional integration

# freq Statistics

Argomento:  variabile 
Opzioni:    --nbins=n (specifica il numero di intervalli)
            --min=minval (specifica il valore minimo, v. oltre)
            --binwidth=width (specifica l'ampiezza degli intervalli, v. oltre)
            --quiet (non mostra il grafico)
            --normal (test per la distribuzione normale)
            --gamma (test per la distribuzione gamma)
            --silent (non mostra nulla)
            --show-plot (v. oltre)
            --matrix=nome (usa una colonna di una matrice indicata per nome)
Esempi:     freq x
            freq x --normal
            freq x --nbins=5
            freq x --min=0 --binwidth=0.10

Se non vengono indicate opzioni, mostra la distribuzione di frequenza per la
variabile (indicata con il nome o il numero).

Se viene indicata l'opzione --matrix, var (che deve essere un intero) viene
invece interpretato come un indice di base 1 che individua una colonna in
una matrice indicata per nome.

Per controllare la presentazione della distribuzione è possibile
specificare o il numero di intervalli o il valore minimo più l'ampiezza
degli intervalli, come illustrato negli ultimi due esempi precedenti.
L'opzione --min fissa il limite inferiore dell'intervallo più a sinistra.

Usando l'opzione --normal, vengono mostrati i risultati del test chi-quadro
di Doornik-Hansen per la normalità. Usando l'opzione --gamma, al posto del
test di normalità viene eseguito il test non parametrico di Locke per
l'ipotesi nulla che la variabile segua la distribuzione gamma; si veda Locke
(1976), Shapiro e Chen (2001). Si noti che la parametrizzazione della
distribuzione gamma in gretl è (forma, scala).

In modalità interattiva viene mostrato anche un grafico della
distribuzione, a meno che non si usi l'opzione --quiet. Per converso, il
grafico non viene mostrato quando il comando è invocato da script, a meno
che non venga usata l'opzione --show-plot. (Questo non si applica alla
versione di gretl a linea di comando, gretlcli.)

L'opzione --silent sopprime interamente l'output mostrato di solito. Ha
senso usarla insieme a una delle opzioni riguardanti la distribuzione: in
questo modo la statistica test e il suo p-value verranno salvati nelle
variabili accessorie $test e $pvalue.

Accesso dal menù:    /Variabile/Distribuzione di frequenza

# function Programming

Argomento:  nome_funzione 

Apre un blocco di istruzioni che definiscono una funzione. Il blocco va
chiuso con end function. Per i dettagli, si veda la la guida all'uso di
gretl.

# garch Estimation

Argomenti:  p q ; variabile-dipendente [ variabili-indipendenti ] 
Opzioni:    --robust (errori standard robusti)
            --verbose (mostra i dettagli delle iterazioni)
            --vcv (mostra la matrice di covarianza)
            --nc (non include una costante)
            --stdresid (standardizza i residui)
            --fcp (usa l'algoritmo di Fiorentini, Calzolari e Panattoni)
            --arma-init (parametri di varianza iniziale da ARMA)
Esempi:     garch 1 1 ; y
            garch 1 1 ; y 0 x1 x2 --robust

Stima un modello GARCH (Generalized Autoregressive Conditional
Heteroskedasticity) univariato, o, se sono specificate delle
variabili-indipendenti, includendo delle variabili esogene. I valori interi
p e q (che possono essere indicati in forma numerica o col nome di variabili
scalari preesistenti) rappresentano gli ordini di ritardo nell'equazione
della varianza condizionale.

  h(t) = a(0) + somma(per i da 1 a q) a(i)*u(t-i)^2 + somma( per j da 1 a p) b(j)*h(t-j)

Il parametro p rappresenta quindi l'ordine generalizzato (o "AR"), mentre q
rappresenta il consueto ordine ARCH (o "MA"). Se p è diverso da zero, anche
q deve essere diverso da zero, altrimenti il modello non è identificato.
Comunque, è possibile stimare un modello ARCH consueto impostando q a un
valore positivo e p a zero. La somma di p e q non deve superare 5. Si noti
che nell'equazione della media viene automaticamente inclusa una costante, a
meno che non si usi l'opzione --nc.

Per impostazione predefinita, i modelli GARCH vengono stimati usando il
codice nativo gretl, ma è anche possibile usare l'algoritmo di Fiorentini,
Calzolari e Panattoni (1996). Il primo usa il massimizzatore BFGS, mentre il
secondo usa la matrice di informazione per massimizzare la verosimiglianza,
con un raffinamento usando l'Hessiana.

Sono disponibili varie stime della matrice di covarianza dei coefficienti.
Il metodo predefinito è quello dell'Hessiana, a meno che non si usi
l'opzione --robust, nel qual caso viene usata la matrice di covarianza QML
(White). Altre possibilità (ad es. la matrice di informazione, o lo
stimatore di Bollerslev-Wooldridge) possono essere specificate con il
comando "set".

In modalità predefinita, le stime dei parametri di varianza sono
inizializzate usando la varianza dell'errore non condizionale, ottenuta
dalla stima OLS iniziale, per la costante, e piccoli valori positivi per i
coefficienti dei valori passati dell'errore al quadrato e per la varianza
dell'errore. L'opzione --arma-init fa in modo che i valori iniziali per
questi parametri siano ricavati da un modello ARMA iniziale, sfruttando la
relazione tra GARCH e ARMA mostrata nel capitolo 21 di Time Series Analysis
di Hamilton. In alcuni casi, questo metodo può aumentare le probabilità di
convergenza.

I residui GARCH e la varianza condizionale stimata sono memorizzate
rispettivamente nelle variabili $uhat e $h. Ad esempio, per ottenere la
varianza condizionale è possibile scrivere:

        genr ht = $h

Con l'opzione --stdresid, i valori di $uhat vengono divisi per la radice di
h_t.

Accesso dal menù:    /Modello/Serie storiche/GARCH

# genr Dataset

Argomenti:  nuova-variabile = formula 

NOTA: questo comando ha subito molti cambiamenti e migliorie da quando
l'help seguente è stato scritto, per cui per informazioni complete e
aggornate consigliamo di far riferimento alla la guida all'uso di gretl.
D'altro canto, il testo che segue non contiene informazioni erronee, per cui
può essere interpretato come "questo ed altro".

In contesti appropriati, series, scalar e matrix sono sinonimi per questo
comando.

Crea nuove variabili, di solito per mezzo di trasformazioni di variabili
esistenti. Si veda anche "diff", "logs", "lags", "ldiff", "sdiff" e "square"
per alcune scorciatoie. Nel contesto di una formula genr, le variabili
esistenti devono essere referenziate per nome, non per numero
identificativo. La formula dev'essere una combinazione ben definita di nomi
di variabile, costanti, operatori e funzioni (descritte oltre). Ulteriori
dettagli su alcuni aspetti di questo comando si possono trovare nella la
guida all'uso di gretl.

Il comando genr può produrre come risultato una serie o uno scalare. Ad
esempio, la formula x2 = x * 2 produce una serie se la variabile x è una
serie e uno scalare se x è uno scalare. Le formule x = 0 e mx = mean(x)
producono degli scalari. In alcune circostanze, può essere utile che un
risultato scalare sia espanso in una serie o in un vettore: è possibile
ottenere questo risultato usando series come "alias" per il comando genr. Ad
esempio, series x = 0 produce una serie con tutti i valori pari a 0. Allo
stesso modo, è possibile usare scalar come alias per genr, ma non è
possibile forzare un risultato vettoriale in uno scalare: con questa parola
chiave si indica che il risultato dovrebbe essere uno scalare; se non lo è,
viene emesso un messaggio di errore.

Quando una formula produce una serie o un vettore come risultato,
l'intervallo su cui essi sono definiti dipende dall'impostazione attuale del
campione. È quindi possibile definire una serie a pezzi, alternando l'uso
dei comandi smpl e genr.

Gli operatori aritmetici supportati sono, in ordine di precedenza: ^
(esponenziale); *, / e % (modulo o resto); + e -.

Gli operatori Booleani disponibili sono (ancora in ordine di precedenza): !
(negazione), && (AND logico), || (OR logico), >, <, =, >= (maggiore o
uguale), <= (minore o uguale) e != (disuguale). Gli operatori Booleani
possono essere usati per costuire variabili dummy: ad esempio (x > 10)
produce 1 se x > 10, 0 altrimenti.

Le costanti predefinite sono pi e NA. L'ultima rappresenta il codice per i
valori mancanti: è possibile inizializzare una variabile con valori
mancanti usando scalar x = NA.

Il comando genr supporta un'ampia gamma di funzioni matematiche e
statistiche, da quelle più comuni a quelle di uso specifico in econometria.
Inoltre offre l'accesso a numerose variabili interne che vengono definite
nel corso della stima di regressioni, dell'esecuzione di test, e così via.
Per un elenco delle funzioni e degli accessori, eseguire: "help functions".

Oltre agli operatori e alle funzioni mostrati, ci sono alcuni usi speciali
del comando "genr":

  "genr time" crea una variabile trend temporale (1,2,3,...) chiamata
  "time". "genr index" fa la stessa cosa, ma chiamando la variabile index.

  "genr dummy" crea una serie di variabili dummy a seconda della
  periodicità dei dati. Ad esempio, nel caso di dati trimestrali
  (periodicità 4) il programma crea dq1, che vale 1 nel primo trimestre e 0
  altrove, dq2 che vale 1 nel secondo trimestre e 0 altrove, e così via.
  Nel caso di dati mensili, le dummy si chiamano dm1, dm2 e così via. Con
  altre frequenze dei dati, i nomi delle dummy sono dummy_1, dummy2, ecc.

  "genr unitdum" e "genr timedum" creano insiemi di variabili dummy speciali
  da usare in un dataset di tipo panel. Il primo comando crea dummy che
  rappresentano le unità cross section, il secondo i periodi di
  osservazione.

Nota: nella versione a riga di comando del programma, i comandi "genr" che
estraggono dati relativi al modello si riferiscono sempre al modello stimato
per ultimo. Questo vale anche per la versione grafica del programma se si
usa "genr" nel "terminale di gretl" o si immette una formula usando
l'opzione "Definisci nuova variabile" nel menù Variabile della finestra
principale. Usando la versione grafica, però, è possibile anche estrarre i
dati da qualunque modello mostrato in una finestra (anche se non è il
modello più recente) usando il menù "Analisi" nella finestra del modello.

La variabile speciale t serve da indice per le osservazioni (obs è un
sinonimo). Ad esempio, genr dum = (t=15) crea una variabile dummy che vale 1
per l'osservazione 15 e 0 altrove. È anche possibile usare questa variabile
per selezionare alcune osservazioni particolari secondo la data o il nome.
Ad esempio genr d = (obs>1986:4), genr d = (obs>"2008/04/01"), genr d =
(obs="CA"). Quando si usa una data o un nome dell'osservazione, questi vanno
racchiusi tra virgolette doppie, mentre non è strettamente necessario farlo
per le date trimestrali e mensili.

Nota: quando si usa t e obs con serie storiche annuali, il valore
corrisponde sempre all'anno dell'osservazione. Quindi se si hanno dati
annuali che iniziano nel 1970, l'osservazione per il 1980 corrisponde a
t=1980, non a t=10. Con dati trimestrali o mensili, invece, t=10 corrisponde
alla decima osservazione.

È possibile estrarre dei valori scalari da una serie usando una formula
genr con la sintassi nome-variabile[osservazione]. Il valore di osservazione
può essere specificato con un numero o una data. Esempi: x[5],
CPI[1996:01]. Per i dati giornalieri occorre usare la forma AAAA/MM/GG, ad
esempio ibm[1970/01/23].

È possibile modificare una singola osservazione in una serie usando genr.
Per farlo, occorre aggiungere un numero di osservazione o una data valida
tra parentesi quadre al nome della variabile nel lato sinistro della
formula. Ad esempio: genr x[3] = 30 o genr x[1950:04] = 303.7.

Ecco un esempio di utilizzo delle variabili dummy: si supponga che x abbia
valori 1, 2, o 3 e si desiderino tre variabili dummy, d1 = 1 se x = 1, e 0
altrove, d2 = 1 se x = 2 e così via. Per crearle, basta usare i comandi:

	    genr d1 = (x=1)
	    genr d2 = (x=2)
	    genr d3 = (x=3)

  Formula                Commento
  -------                -------
  y = x1^3               x1 al cubo
  y = ln((x1+x2)/x3)     
  z = x>y                z(t) = 1 se x(t) > y(t), 0 altrove
  y = x(-2)              x ritardata di 2 periodi
  y = x(+2)              x anticipata di 2 periodi
  y = diff(x)            y(t) = x(t) - x(t-1)
  y = ldiff(x)           y(t) = log x(t) - log x(t-1), il tasso di crescita 
                         istantaneo di x
  y = sort(x)            ordina x in senso crescente e la salva in y
  y = dsort(x)           ordina x in senso decrescente
  y = int(x)             tronca x e salva il valore intero in y
  y = abs(x)             salva il valore assoluto di x
  y = sum(x)             somma i valori di x escludendo i valori mancanti NA
  y = cum(x)             cumulativa: y(t) = somma di x(s) per s da 1 a t 
  aa = $ess              imposta aa uguale alla somma dei quadrati degli 
                         errori dell'ultima regressione
  x = $coeff(sqft)       estrae il coefficiente stimato per la variabile sqft 
                         nell'ultima regressione
  rho4 = $rho(4)         estrae il coefficiente di autoregressione del quarto 
                         ordine dall'ultimo modello (presume un modello ar 
                         model)
  cvx1x2 = $vcv(x1, x2)  estrae il coefficiente di covarianza stimato tra le 
                         variabili x1 e x2 dall'ultimo modello
  foo = uniform()        variabile pseudo-casuale uniforme nell'intervallo 0-1
  bar = 3 * normal()     variabile pseudo-casuale normale con mu = 0, sigma = 
                         3
  samp = ok(x)           vale 1 per le osservazioni dove il valore di x non è 
                         mancante.

Accesso dal menù:    /Variabile/Definisci nuova variabile
Accesso alternativo: Menù pop-up nella finestra principale

# gmm Estimation

Opzioni:    --two-step (Stima a due passi)
            --iterate (GMM iterato)
            --vcv (Mostra la matrice di covarianza)
            --verbose (Mostra i dettagli delle iterazioni)
            --lbfgs (usa il massimizzatore L-BFGS-B anziché il BFGS standard)

Esegue la stima col metodo dei momenti generalizzato (Generalized Method of
Moments, GMM) usando l'algoritmo BFGS (Broyden, Fletcher, Goldfarb, Shanno).
Occorre specificare uno o più comandi per aggiornare le quantità rilevanti
(tipicamente i residui GMM), una o più condizioni di ortogonalità, una
matrice iniziale dei pesi e un elenco dei parametri da stimare, il tutto
racchiuso tra le parole chiave gmm e end gmm.

Si veda la la guida all'uso di gretl per i dettagli. Quello che segue è un
semplice esempio illustrativo.

	gmm e = y - X*b
	  orthog e ; W
	  weights V
	  params b
	end gmm

Nell'esempio si assume che y e X siano matrici di dati, b sia un vettore con
i valori dei parametri, W sia una matrice di strumenti, e V un'appropriata
matrice dei pesi. La dichiarazione

	orthog e ; W

indica che il vettore dei residui e è in linea di principio ortogonale ad
ognuno degli strumenti che compongono le colonne di W.

Accesso dal menù:    /Modello/GMM

# gnuplot Graphs

Argomenti:  variabili-y variabile-x [ variabile-dummy ] 
Opzioni:    --with-lines[=varspec] (usa linee invece che punti)
            --with-lp[=varspec] (usa linee e punti)
            --with-impulses[=varspec] (usa linee verticali)
            --time-series (mostra rispetto al tempo)
            --suppress-fitted (non mostra la linea stimata)
            --single-yaxis (forza l'uso di un solo asse delle ordinate)
            --linear-fit (mostra fit minimi quadrati)
            --inverse-fit (mostra fit inverso)
            --quadratic-fit (mostra fit quadratico)
            --cubic-fit (mostra fit cubico)
            --loess-fit (mostra fit non-parametrico)
            --semilog-fit (mostra fit semilogaritmico)
            --dummy (si veda sotto)
            --matrix=name (mostra le colonne di una data matrice)
            --output=filename (ridirige l'output su file)
            --input=filename (prende l'input da file)
Esempi:     gnuplot y1 y2 x
            gnuplot x --time-series --with-lines
            gnuplot wages educ gender --dummy
            gnuplot y1 y2 x --with-lines=y2

Le variabili nella lista variabili-y vengono mostrate rispetto alla
variabile variabile-x. Per avere un grafico storico è possibile usare time
come variabile-x, oppure usare l'opzione --time-series.

Per default, i dati sono mostrati come punti; ma questa scelta può essere
modificata usando una delle opzioni --with-lines, --with-lp or
--with-impulses. Se il grafico contiene più di una serie, l'effetto di
queste opzioni può essere limitato ad un sottoinsieme delle variabili
usando il parametro varspec. Esso deve essere dato sotto forma di una lista
separata da virgole dei nomi (o dei numeri) delle variabili da tracciare con
linee e/o con impulsi. L'esempio più sotto mostra come tracciare y1 e y2
contro x, in modo tale che y2 sia rappresentata da una linea ma y1 da punti.

Usando l'opzione --dummy, occorre fornire esattamente tre variabili: una
variabile y, una variabile x, e una variabile dummy dumvar. L'effetto è
quello di mostrare y rispetto a x colorando in modo diverso i vari punti, a
seconda che dumvar valga 1 o 0.

In generale è necessario specificare sia l'argomento yvars che quello xvar;
entrambi devono indicare variabili nel dataset corrente (per nome o numero
identificativo). Se tuttavia viene specificata con l'opzione --matrix una
matrice definita in precedenza questi argomenti diventano opzionali: se la
matrice specificata ha k colonne, di default le prime k - 1 sono considerate
come yvars, e l'ultima come xvar. Se viene indicata l'opzione --time-series,
tuttavia, il comando fornisce il grafico di tutte le k variabili rispetto al
tempo. Se si desidera il grafico solo di alcune colonne della matrice è
necessario identificare yvars e xvar fornendo l'indice delle colonne
corrispondenti, dove la prima colonna ha indice 1. Per esempio, se si
desidera un grafico a dispersione della colonna 2 della matrice M rispetto
alla colonna 1, il comando da digitare è:

	gnuplot 2 1 --matrix=M

In modalità interattiva il risultato è mostrato immediatamente. In
modalità "batch", viene scritto un file di comandi gnuplot, chiamato
gpttmpN.plt, a partire da N = 01; il grafico vero e proprio può essere
generato usando il programma gnuplot (su MS Windows: wgnuplot). Questo
comportamento può essere modificato usando l'opzione --output=filename, che
controlla il nome del file utilizzato e contemporaneamente permette di
specificare un particolare formato di output usando l'estensione del nome
del file (le tre lettere che seguono il .): .eps produce un file
Encapsulated PostScript (EPS); .pdf produce un file PDF; .png produce un
formato PNG, .emf un formato EMF (Enhanced MetaFile), .fig un file Xfig, e
.svg uno SVG (Scalable Vector Graphics). Se come nome del file si indica
"display", il grafico è inviato allo schermo come nella modalità
interattiva. Se si indica un nome del file con un'estensione diversa da
quelle appena citate viene prodotto un file di comandi gnuplot.

Le varie opzioni "fit" si applicano solo nel caso di un diagramma a
dispersione bivariato. Il comportamento predefinito consiste nel mostrare la
linea con le stime OLS, se e solo se il coefficiente di pendenza è
significativo almeno al 10 per cento. Se si usa l'opzione suppress non viene
mostrata alcuna linea. Se si usa l'opzione linear, la linea OLS viene
mostrata a prescindere dalla sua significatività. Le altre opzioni
(inverse, quadratic e loess) mostrano rispettivamente un fit inverso (la
regressione di y su 1/x), un fit quadratico o un fit loess (chiamato a volte
anche "lowess", una regressione robusta con pesi locali).

È disponibile un'ulteriore opzione per questo comando: dopo la
specificazione delle variabili e le eventuali opzioni, è possibile
aggiungere direttamente dei comandi gnuplot per modificare l'aspetto visivo
del grafico (ad esempio, impostando il titolo e o gli intervalli degli
assi). Questi comandi aggiuntivi vanno inclusi tra parentesi graffe e ogni
comando va separato con un punto e virgola; è possibile usare una barra
rovesciata (\) per continuare un gruppo di comandi gnuplot sulla riga
successiva. Ecco un esempio della sintassi:

	{ set title 'Il mio titolo'; set yrange [0:1000]; }

Accesso dal menù:    /Visualizza/Grafico
Accesso alternativo: Menù pop-up nella finestra principale, pulsante grafico sulla barra degli strumenti

# graphpg Graphs

Varianti:   graphpg add
            graphpg fontscale value
            graphpg show
            graphpg free
            graphpg --output=filename

La "pagina dei grafici" funzionerà solo se si è installato il sistema di
composizione LaTeX e si è in grado di generare e visualizzare file in
formato postscript.

Nella finestra della sessione, è possibile trascinare fino a otto grafici
sull'icona della pagina dei grafici. Facendo doppio clic sull'icona della
pagina dei grafici (o facendo clic col tasto destro e selezionando
"Mostra"), la pagina contenente i grafici selezionati verrà composta e
aperta con il proprio visualizzatore di file postscript, da cui sarà
possibile stamparla.

Per pulire la pagina dei grafici, fare clic col tasto destro sull'icona e
selezionare "Pulisci".

Su sistemi diversi da MS Windows, può essere necessario modificare
l'impostazione del programma per visualizzare il postscript, che si trova
nella sezione "Programmi" della finestra di dialogo delle Preferenze di
gretl (nel menù Strumenti della finestra principale).

E' anche possibile operare sulla pagina del grafico usanod uno script oppure
usando la console (nel programma GUI). Sono disponibili i comandi seguenti:

Per aggiungere un grafico alla pagina dei grafici, digitate il comando
graphpg add dopo aver salvato un grafico con un nome, come in

	grf1 <- gnuplot Y X
	graphpg add

Per aprire la pagina dei grafici: graphpg show.

Per svuotare la pagina dei grafici: graphpg free.

Per modificare la dimensione del font usato nella pagina dei grafici usate
graphpg fontscale scale, dove scale è un moltiplicatore (con un valore di
default pari a 1.0). Per rendere il fonto più grande del 50 per cento,
dunque, è possibile scrivere

	graphpg fontscale 1.5

Per stampare su un file la pagina dei grafici usate l'opzione --output=
seguita dal nome di un file; questo nome deve avere il suffisso ".pdf",
".ps" o ".eps". Per esempio:

	graphpg --output="myfile.pdf"

In questo contesto l'output usa linee colorate di default; per usare linee
punteggiate o tratteggiate al posto dei colori è possibile aggiungere
l'opzione --monochrome.

# hausman Tests

Questo test è disponibile solo dopo aver stimato un modello OLS su dati
panel (si veda anche "setobs"). Testa il semplice modello "pooled" (con
tutte le osservazioni mescolate indistintamente) contro le principali
alternative: il modello a effetti fissi e quello a effetti casuali.

Il modello a effetti fissi permette all'intercetta della regressione di
variare per ogni unità cross section. Viene eseguito un test F per
l'ipotesi nulla che le intercette non differiscano tra loro. Il modello a
effetti casuali scompone la varianza dei residui in due parti: una specifica
all'unità cross section e una specifica all'osservazione particolare (la
stima può essere eseguita solo se il numero delle unità cross section nel
dataset è maggiore del numero dei parametri da stimare). La statistica LM
di Breusch-Pagan testa l'ipotesi nulla che il modello pooled OLS sia
adeguato contro l'alternativo modello a effetti casuali.

Può accadere che il modello pooled OLS sia rifiutato nei confronti di
entrambe le alternative, a effetti fissi o casuali. A patto che gli errori
specifici di unità o di gruppo siano non correlati con le variabili
indipendenti, lo stimatore a effetti casuali è più efficiente dello
stimatore a effetti fissi; nel caso contrario lo stimatore a effetti casuali
non è consistente e deve essergli preferito lo stimatore a effetti fissi.
L'ipotesi nulla per il test di Hausman è che l'errore specifico di gruppo
non sia correlato con le variabili indipendenti (e quindi che il modello a
effetti casuali sia preferibile). Un basso p-value per questo test
suggerisce di rifiutare il modello a effetti casuali in favore del modello a
effetti fissi.

Accesso dal menù:    Finestra del modello, /Test/HAUSMAN - Diagnosi panel

# heckit Estimation

Argomenti:  variabile-dipendente variabili-indipendenti ; equazione di selezione 
Opzioni:    --quiet (non mostra i risultati)
            --robust (errori standard QML)
            --two-step (esegue la stima in due passi)
            --vcv (mostra la matrice di covarianza)
            --verbose (mostra risultati aggiuntivi)
Esempio:    heckit y 0 x1 x2 ; ys 0 x3 x4
            Vedi anche heckit.inp

Modello di selezione di tipo Heckman. Nella specificazione, la lista che
precede il punto e virgola rappresenta l'equazione principale, mentre la
seconda lista rappresenta l'equazione di selezione. La variabile dipendente
nell'equazione di selezione (ys nell'esempio visto sopra) deve essere una
variabile binaria.

Per impostazione predefinita, i parametri sono stimati per massima
verosimiglianza. La matrice di covarianza dei parametri è calcolata usando
l'inversa negativa dell'Hessiana. Se si vuole usare la procedura di stima in
due passi, basta usare l'opzione --two-step. In questo caso, la matrice di
covarianza dei parametri dell'equazione principale è corretta nel modo
descritto da Heckman (1979).

Si noti che nella stima di massima verosimiglianza viene impiegata una
matrice hessiana calcolata numericamente; ciò può condurre a una stima
inaccurata della matrice di covarianze se l'ordine di grandezza delle
variabili esplicative è tale per cui alcuni dei coefficienti stimati
risultano molto piccoli in valore assoluto. Il problema verrà affrontato
nelle versioni future; nel frattempo, si può aggirare il problema
riscalando opportunamente i regressori problematici.

Accesso dal menù:    /Modello/Modelli non lineari/Heckit

# help Utilities

Varianti:   help
            help functions
            help comando
            help funzione
Opzione:    --func (sceglie l'aiuto sulle funzioni)

Se non vengono indicati argomenti, mostra un elenco dei comandi disponibili.
Indicando l'argomento "functions", mostra un elenco delle funzioni
disponibili (si veda "genr").

"help" comando descrive il comando (ad es. "help smpl"). help funzione
descrive la funzione (ad es. help ldet). Alcune funzioni hanno lo stesso
nome dei comandi relativi (ad esempio diff): in questo caso verrà mostrato
l'aiuto relativo al comando, a meno che non si usi l'opzione --func.

Accesso dal menù:    /Aiuto

# hsk Estimation

Argomenti:  variabile-dipendente variabili-indipendenti 
Opzione:    --vcv (mostra la matrice di covarianza)

Questo comando è utile in presenza di eteroschedasticità sotto forma di
una funzione incognita dei regressori, che può essere approssimata da una
relazione quadratica. In questo contesto, offre la possibilità di avere
errori standard consistenti e stime dei parametri più efficienti, rispetto
alla stima OLS.

La procedura richiede: (a) la stima OLS del modello, (b) una regressione
ausiliaria per generare la stima della varianza dell'errore e (c) la stima
con minimi quadrati ponderati, usando come peso il reciproco della varianza
stimata.

Nella regressione ausiliaria (b) il logaritmo dei quadrati dei residui dalla
prima regressione OLS viene regredito sui regressori originali e sui loro
quadrati. La trasformazione logaritmica viene effettuata per assicurarsi che
le varianze stimate siano non negative. Indicando con u^* i valori stimati
da questa regressione, la serie dei pesi per la regressione con minimi
quadrati ponderati è data da 1/exp(u^*).

Accesso dal menù:    /Modello/Altri modelli lineari/HSK - WLS corretti per eteroschedasticità

# hurst Statistics

Argomento:  nome-variabile 

Calcola l'esponente di Hurst (una misura di persistenza, o di memoria lunga)
per una serie storica con almeno 128 osservazioni.

L'esponente di Hurst è discusso da Mandelbrot. In termini teorici è
l'esponente H nella relazione

  RS(x) = an^H

dove RS è l'"intervallo riscalato" della variabile x in un campione
dell'ampiezza n, mentre a è una costante. L'intervallo riscalato è
l'intervallo (valore massimo meno valore minimo) del valore cumulato, o
somma parziale, di x sul periodo del campione (dopo aver sottratto la media
campionaria), diviso per lo scarto quadratico medio campionario.

Come punto di riferimento, se x è un rumore bianco (media zero, persistenza
zero) l'intervallo dei suoi valori cumulati (che forma una passeggiata
casuale), scalato per lo scarto quadratico medio, cresce come la radice
quadrata dell'ampiezza campionaria, ossia ha un esponente di Hurst atteso
pari a 0.5. Valori dell'esponente sensibilmente maggiori di 0.5 indicano
persistenza della serie, mentre valori minori di 0.5 indicano
anti-persistenza (autocorrelazione negativa). In teoria l'esponente deve
essere compreso tra 0 e 1, ma in campioni finiti è possibile ottenere delle
stime per l'esponente maggiori di 1.

In gretl, l'esponente è stimato usando il sotto-campionamento binario: si
inizia dall'intero intervallo dei dati, quindi si usano le due metà
dell'intervallo, poi i quattro quarti, e così via. Il valore RS è la media
presa sui vari campioni. L'esponente è quindi stimato come il coefficiente
di pendenza della regressione del logaritmo di RS sul logaritmo
dell'ampiezza del campione.

Accesso dal menù:    /Variabile/Esponente di Hurst

# if Programming

Struttura di controllo per l'esecuzione dei comandi. Sono supportate le tre
forme seguenti:

	# forma semplice
	if condition
	    commands
	endif

	# a due rami
	if condition
	    commands1
	else
	    commands2
        endif

	# a tre o più rami
	if condition1
	    commands1
	elif condition2
	    commands2
	else
	    commands3
	endif

La "condizione" deve essere un'espressione Booleana, per la cui sintassi si
veda "genr". Può essere incluso più di un blocco "elif". Inoltre, i
blocchi if ... endif possono essere nidificati.

# include Programming

Argomento:  file-input 

Da usare in uno script di comandi, principalmente per includere definizioni
di funzioni. Esegue i comandi nel file-input e ripassa il controllo allo
script principale. Per includere una funzione che fa parte di un pacchetto,
occorre specificare anche l'estensione del file.

Si veda anche il comando "run".

# info Dataset

Mostra le informazioni aggiuntive contenute nel file di dati attuale.

Accesso dal menù:    /Dati/Visualizza descrizione
Accesso alternativo: Finestre di esplorazione dei dati

# intreg Estimation

Argomenti:   var-min var-max var-indip 
Opzioni:    --quiet (non mostra i risultati)
            --verbose (mostra i dettagli delle iterazioni)
            --robust (errori standard robusti)
Esempio:    intreg lo hi const x1 x2
            Vedi anche wtp.inp

Stima un modello di regressione per intervallo. Questo modello è adatto al
caso in cui la variabile dipendente è osservata in modo imperfetto per
alcune osservazioni (o anche tutte). In altre parole, si ipotizza che il
processo generatore dei dati sia

  y* = x b + u

ma che solo m <= y* <= M sia osservato (l'intervallo può essere limitato a
destra o a sinistra). Si noti che per alcune osservazioni m può essere
uguale a M. Le variabili var-min e var-max devono contenere valori NA nel
caso di osservazioni non limitate a sinistra o a destra.

Il modello è stimato per massima verosimiglianza, ipotizzando la normalità
del termine di disturbo.

Per impostazione predefinita, gli errori standard sono calcolati usando
l'inversa dell'Hessiana. Se si usa l'opzione --robust, vengono calcolati
invece gli errori standard QML o Huber-White. In questo caso la matrice di
covarianza stimata è un "sandwich" dell'inversa dell'Hessiana stimata e del
prodotto esterno del gradiente.

Accesso dal menù:    /Modello/Modelli non lineari/Regressione per intervalli

# join Dataset

Argomenti:  filename varname 
Opzioni:    --data=column-name (v. oltre)
            --filter=expression (v. oltre)
            --ikey=inner-key (v. oltre)
            --okey=outer-key (v. oltre)
            --aggr=method (v. oltre)

Questo comando importa una serie di dati dal file di origine filename (che
deve essere un file di dati testuale delimitato) assegnandoli alla variabile
varname. Per maggiori dettagli, si veda la guida all'uso di gretl; in questa
sede ci limitiamo a ricordare brevemente le opzioni disponibili.

L'opzione --data può essere usata per specificare l'intestazione della
colonna nel file di origine se quest'ultima è diversa dal nome con il quale
dovrebbero essere chiamati i dati in gretl.

L'opzione --filter può essere usata per specificare un criterio da seguire
per filtrare i dati di origine (in altre parole, per selezionare un
osttoinsieme di osservazioni).

Le opzioni --ikey e --okey possono essere utilizzate per specificare una
relazione fra le osservazioni nel dataset corrente e quelle nel file di
origine (per esempio, gli individui possono essere assegnati alla famiglia
di appartenenza).

L'opzione --aggr viene usata quando la relazione fra osservazioni nel
dataset corrente e nel file di oriogine non è biunivoca.

L'opzione --tkey è applicabile solo quando il dataset corrente ha una
struttura di serie storiche. Viene usato per specificare il nome di una
colonna contenete le date da accoppiare al dataset e/o il formato in cui le
date sono rappresentate in quella colonna.

V. anche "append" per alcune semplici operazioni di unione di dataset.

# kalman Estimation

Opzioni:    --cross (permette la correlazione fra i due vettori di disturbi)
            --diffuse (usa un'inizializzazione diffusa)

Inizia un blocco di istruzioni per impostare un filtro di Kalman. Questo
blocco deve terminare con la linea end kalman, alla quale possono essere
aggiunte le opzioni elencate sopra. Le istruzioni del blocco specificano le
matrici che compongono il filtro. Per esempio,

	kalman 
	  obsy y
	  obsymat H
	  statemat F
	  statevar Q
	end kalman

Vedi la guida all'uso di gretl per ulteriori dettagli.

Vedi anche "kfilter", "ksimul", "ksmooth".

# kpss Tests

Argomenti:  ordine lista-variabili 
Opzioni:    --trend (include un trend)
            --verbose (mostra i risultati della regressione)
            --quiet (non mostra i risultati)
            --difference (usa la differenza prima della variabile)
Esempi:     kpss 8 y
            kpss 4 x1 --trend

For use of this command with panel data please see the final section in this
entry.

Calcola il test KPSS (Kwiatkowski, Phillips, Schmidt e Shin, 1992) per la
stazionarietà di ognuna delle variabili specificate (o della loro
differenza prima, se si usa l'opzione --difference. L'ipotesi nulla è che
la variabile in questione sia stazionaria, attorno a un valore fisso o, se
è stata usata l'opzione --trend, attorno a un trend deterministico lineare.

L'argomento ordine determina la dimensione della finestra usata per il
livellamento di Bartlett. Se si usa l'opzione --verbose, vengono mostrati
anche i risultati della regressione ausiliaria, insieme alla varianza
stimata della componente random walk della variabile.

Il valori critici riportati per questa statistica test sono basati sulle
superfici di risposta stimati da Sephton (Economics Letters, 1995), che per
piccoli campioni sono più accurati di quelli forniti nell'articolo
originale di KPSS. Quando la statistica test si trova fra i valori critici
al 10 e all'1 per cento viene mostrato un p-value ottenuto per
interpolazione lineare, che non dovrebbe essere accettato in maniera
acritica.

Panel data

Quando il comando kpss viene usato con dati panel per calcolare un test
panel di radice unitaria, le opzioni applicabili e i risultati mostrati sono
leggermente diversi. Mentre nel caso di serie storiche regolari potete
fornire una lista di variabili da testare, con dati panel il comando può
testare solo una variabile alla volta. L'opzione --verbose, inoltre, ha un
isgnificato diverso: produce un breve resoconto del test per ciascuna
singola serie storica (di default viene mostrato solo il risultato
complessivo).

Se possibile viene calcolato il test complessivo (ipotesi nulla: la ariabile
in questione è stazionaria per tutte le unità panel) usando il metodo di
Choi (Journal of International Money and Finance, 2001). Questo calcolo non
è sempre immediato perchè mentre il test di Choi è basato sui p-valu dei
test sulle singole serie, attualmente non esiste un modo per calcolare i
p-value della statistica test KPSS; dobbiamo perciò basarci su qualche
valore critico.

Se per una data variabile la statistica test cade fra i valori critici al 10
e all'1 per cento siamo in grado di interpolare un p-value. Ma se il test
cade a sinistra del valore critico al 10 per cento, o supera quello all'1
per cento, non riusciamo a interpolare e tutto ciò che possiamo ottenere è
un limite superiore al test globale di Choi. Se le singole statistiche test
si trovano a sinistra del valore critico al 10 per cento per alcune unità
ma superano quello all'1 per cento per altre non è possibile neppure il
calcolo del limite superiore del test globale.

Accesso dal menù:    /Variabile/Test KPSS

# labels Dataset

Varianti:   labels [ varlist ]
            labels --to-file=filename
            labels --from-file=filename
            labels --delete

Nella sua prima forma mostra le etichette informative (se presenti) per le
variabili in varlist, oppure per tutte le variabili nel dataset se varlist
non è specificata.

Con l'opzione --to-file, scrive nel file indicato le etichette di tutte le
variabili nel dataset, una per linea. Se non sono presenti etichette viene
emesso un messaggio d'errore; se alcune variabili hanno etichette e altre
no, per le seconde viene mostrata una linea vuota.

Con l'opzione --from-file, legge il file specificato (che deve essere di
testo) e assegna le etichette alle variabili nel dataset, leggendo
un'etichetta per linea e interpretando linee vuote come etichette vuote.

L'opzione --delete da quello che vi attendete: rimuove dal dataset tutte le
etichette di variabili.

# lad Estimation

Argomenti:  variabile-dipendente variabili-indipendenti 
Opzione:    --vcv (mostra la matrice di covarianza)

Calcola una regressione che minimizza la somma delle deviazioni assolute dei
valori stimati dai valori effettivi della variabile dipendente. Le stime dei
coefficienti sono derivate usando l'algoritmo del simplesso di
Barrodale-Roberts; viene mostrato un messaggio di avvertimento se la
soluzione non è unica.

Gli errori standard sono derivati usando la procedura bootstrap con 500
estrazioni. La matrice di covarianza per le stime dei parametri, mostrata se
si usa l'opzione --vcv, si basa sulla stessa procedura.

Accesso dal menù:    /Modello/Stima robusta/LAD - Minime deviazioni assolute

# lags Transformations

Argomenti:  [ ordine ; ] lista-variabilii 
Esempi:     lags x y
            lags 12 ; x y

Crea delle nuove variabili come valori ritardati di ognuna delle variabili
nella lista-variabili. Il numero dei ritardi può essere indicato dal primo
parametro opzionale, altrimenti sarà pari alla periodicità del dataset. Ad
esempio, se la periodicità è 4 (trimestrale), il comando "lags x y" crea

       x_1 = x(t-1)
       x_2 = x(t-2)
       x_3 = x(t-3)
       x_4 = x(t-4)

Il numero dei ritardi creati può essere indicato come primo parametro
opzionale (se presente, deve essere seguito da un punto e virgola).

Accesso dal menù:    /Aggiungi/Ritardi delle variabili selezionate

# ldiff Transformations

Argomento:  lista-variabili 

Calcola la differenza prima del logaritmo naturale di ogni variabile della
lista-variabili e la salva in una nuova variabile con il prefisso ld_.
Così, "ldiff x y" crea le nuove variabili

	ld_x = log(x) - log(x(-1))
	ld_y = log(y) - log(y(-1))

Accesso dal menù:    /Aggiungi/Differenze logaritmiche

# leverage Tests

Opzione:    --save (salva le variabili)

Deve seguire immediatamente un comando "ols". Calcola il "leverage" (h,
compreso tra 0 e 1) di ogni osservazione nel campione su cui è stato
stimato il precedente modello. Mostra il residuo (u) per ogni osservazione
assieme al leverage corrispondente e a una misura della sua influenza sulla
stima: u*h/(1-h). I "punti di leverage" per cui il valore di h supera 2k/n
(dove k è il numero dei parametri stimati e n è l'ampiezza del campione)
sono indicati con un asterisco. Per i dettagli sui concetti di leverage e
influenza, si veda Davidson and MacKinnon (1993), capitolo 2.

Vengono mostrati anche i valori DFFITS: questi sono "residui studentizzati"
(ossia i residui previsti, divisi per i propri errori standard) moltiplicati
per sqrt[h/(1 - h)]. Per una discussione dei residui studentizzati e dei
valori DFFITS si veda Maddala's Introduction to Econometrics, cap. 12,
oppure Belsley, Kuh and Welsch (1980).

In breve, i "residui previsti" sono la differenza tra il valore osservato e
il valore stimato della variabile dipendente all'osservazione t, ottenuti da
una regressione in cui quell'osservazione è stata omessa (oppure in cui è
stata aggiunta una variabile dummy che vale 1 solo per l'osservazione t); il
residuo studentizzato si ottiene dividendo il residuo previsto per il
proprio errore standard.

Se si usa l'opzione --save, il leverage, il valore di influenza e il valore
DFFITS vengono aggiunti al dataset in uso.

Dopo l'esecuzione, l'accessore $test restituisce il criterio di validazione
incrociata, definito come la somma dei quadrati degli scarti fra la
variabile dipendente e il suo valore previsto, calcolato a partire da un
campione dal quale quell'osservazione è stata esclusa. (Questo stimatore è
chiamato leave-one-out). Per una discussione più approfondita del criterio
di validazione incrociata, v. Davidson e MacKinnon's Econometric Theory and
Methods, pag. 685-686, e i riferimenti bibliografici ivi citati.

Accesso dal menù:    Finestra del modello, /Test/LEVERAGE - Osservazioni influenti

# levinlin Tests

Argomenti:  order series 
Opzioni:    --nc (test senza costante)
            --ct (con costante e trend)
            --quiet (non mostra i risultati)
Esempi:     levinlin 0 y
            levinlin 2 y --ct
            levinlin {2,2,3,3,4,4} y

Calcola il test di radice unitaria per dati panel di Levin, Lin and Chu
(2002). L'ipotesi nulla che tutte le singole serie storiche contengano una
radica unitaria, mentre l'alternativa è che nessuna delle serie storiche ne
contenga una. (In altre parole, si assume un coefficiente AR(1) comune a
tutte le serie, anche se altre proprietà statistiche delle serie possono
variare da un'unità di osservazione all'altra.)

Di default le regressioni dei test ADF contengono una costante; per
eliminarla usate l'opzione --nc; per aggiungere un trend lineare usate
l'opzione --ct. (V. il comando "adf" per una spiegazione delle regressioni
ADF.)

Il valore (non negativo) order del numero di ritardi della variabile
dipendente da usare nel test può essere indicato in due modi diversi. Se si
fornisce uno scalare, questo viene applicato a tutte le serie nel panel. In
alternativa è possibile fornire una matrice che contiene un particolare
ordine di ritardo per ogni serie. La matrice deve essere un vettore con
numero di elementi pari a quello delle unità di osservazione nel
sottoinsieme corrente del campione, e può essere indicata per nome o
costruita usando parentesi graffe come illustrato nell'ultimo degli esempi
precedenti.

Accesso dal menù:    /Variable/Unit root tests/Levin-Lin-Chu test

# logistic Estimation

Argomenti:  variabile-dipendente variabili-indipendenti 
Opzioni:    --ymax=value (specifica il massimo della variabile dipendente)
            --vcv (mostra la matrice di covarianza)
Esempi:     logistic y const x
            logistic y const x --ymax=50

Regressione logistica: esegue una regressione OLS usando la trasformazione
logistica sulla variabile dipendente:

  log(y/(y* - y))

La variabile dipendente dev'essere strettamente positiva. Se è una frazione
decimale, compresa tra 0 e 1, il valore predefinito per y^* (il massimo
asintotico della variabile dipendente) è 1. Se la variabile dipendente è
una percentuale, compresa tra 0 e 100, il valore predefinito di y^* è 100.

È possibile indicare un valore diverso per il massimo, usando l'opzione
--ymax. Il valore fornito deve essere maggiore di tutti i valori osservati
della variabile dipendente.

I valori stimati e i residui della regressione sono trasformati
automaticamente usando

  y = y* / (1 + exp(-x))

dove x rappresenta un valore stimato oppure un residuo della regressione
OLS, usando la variabile dipendente trasformata. I valori riportati sono
dunque confrontabili con la variabile dipendente originale.

Si noti che se la variabile dipendente è binaria, occorre usare il comando
"logit" invece di questo comando.

Accesso dal menù:    /Modello/Modelli non lineari/Logistico

# logit Estimation

Argomenti:  variabile-dipendente variabili-indipendenti 
Opzioni:    --robust (errori standard robusti)
            --cluster=clustvar (errori standard clusterizzati)
            --multinomial (stima un logit multinomiale)
            --vcv (mostra la matrice di covarianza)
            --verbose (mostra i dettagli delle iterazioni)
            --p-values (mostra i p-value invece delle pendenze)

Se la variabile dipendente è binaria (i suoi valori sono 0 o 1), esegue una
stima di massima verosimiglianza dei coefficienti per le
variabili-indipendenti con il metodo BRMR ("binary response model
regression") descritto in Davidson e MacKinnon (2004). Visto che il modello
è nonlineare, le pendenze dipendono dai valori delle variabili
indipendenti: per impostazione predefinita, al posto dei p-value vengono
mostrate le pendenze rispetto ad ognuna delle variabili indipendenti,
calcolate in corrispondenza della media della variabile. Questo
comportamento può essere soppresso usando l'opzione --p-values. La
statistica chi-quadro testa l'ipotesi nulla che tutti i coefficienti tranne
la costante siano pari a zero.

In modalità predefinita, gli errori standard sono calcolati con l'inversa
negativa dell'Hessiana. Se si usa l'opzione --robust, verranno calcolati gli
errori standard QML o quelli di Huber-White. In questo caso, la matrice di
covarianza stimata è un "sandwich" dell'inversa dell'Hessiana stimata e del
prodotto esterno del gradiente. Per i dettagli, si veda Davidson e MacKinnon
2004, cap. 10.

Se la variabile dipendente non è binaria, ma è discreta, si ottengono
stime Logit ordinate. Tuttavia, se viene fornita l'opzione --multinomial, la
variabile dipendente è interpretata come non ordinale, e vengono prodotte
stime Logit Multinomiali. (In ambo i casi, verrà dato un errore se la
dipendente non è discreta.) Nel caso multinomiale, l'accessore $mnlprobs
sarà disponibile dopo la stima; esso conterrà una matrice con le
probabilità stimate dei possibili valori della dipendente per ogni
osservazione (osservazioni per riga, valori per colonna).

Per condurre un'analisi delle proporzioni (dove la variabile dipendente è
la proporzione dei casi che hanno una certa caratteristica in ogni
osservazione, invece che una variabile binaria che indica se la
caratteristica è presente o no), non bisogna usare il comando "logit", ma
occorre costruire la variabile logit come

	genr lgt_p = log(p/(1 - p))

e usare questa come variabile dipendente in una regressione OLS. Si veda
Ramanathan (2002), capitolo 12.

Accesso dal menù:    /Modello/Modelli non lineari/Logit

# logs Transformations

Argomento:  lista-variabili 

Calcola il logaritmo naturale di ognuna delle variabili della
lista-variabili e lo salva in una nuova variabile col prefisso l_, ossia una
"elle" seguita da un trattino basso. Ad esempio "logs x y" crea le nuove
variabili l_x = ln(x) e l_y = ln(y).

Accesso dal menù:    /Aggiungi/Logaritmi delle variabili selezionate

# loop Programming

Argomento:  controllo 
Opzioni:    --progressive (abilita modalità speciali di alcuni comandi)
            --verbose (mostra i dettagli dei comandi genr)
            --quiet (non mostra il numero di iterazioni eseguite)
Esempi:     loop 1000
            loop 1000 --progressive
            loop while essdiff > .00001
            loop i=1991..2000
            loop for (r=-.99; r<=.99; r+=.01)
            loop foreach i xlist

Questo comando apre una modalità speciale, in cui il programma accetta
comandi da eseguire più volte. Si esce dalla modalità loop con
l'istruzione "endloop": solo a questo punto i comandi indicati vengono
eseguiti.

Il parametro "controllo" deve assumere uno dei cinque valori mostrati negli
esempi: un numero di volte per cui ripetere i comandi all'interno del loop;
"while" seguito da una condizione booleana; un intervallo di valori interi
per una variabile indice; "for" seguito da tre espressioni tra parentesi,
separate da punti e virgola (in modo simile all'istruzione for nel
linguaggio di programmazione C); infine, "foreach" seguito da una variabile
indice e una lista.

Si veda la la guida all'uso di gretl per altri dettagli ed esempi, oltre che
per la spiegazione dell'opzione --progressive (che è destinata ad essere
usata nelle simulazioni Monte Carlo) e per l'elenco dei comandi di gretl che
possono essere usati all'interno di un loop.

# mahal Statistics

Argomento:  lista-variabili 
Opzioni:    --quiet (non mostra nulla)
            --save (salva le distanze nel dataset)
            --vcv (mostra la matrice di covarianza)

La distanza di Mahalanobis è la distanza tra due punti in uno spazio
k-dimensionale, scalata rispetto alla variazione statistica in ogni
dimensione dello spazio. Ad esempio, se p e q sono due osservazioni su un
insieme di k variabili con matrice di covarianza C, la distanza di
Mahalanobis tra le due osservazioni è data da

  sqrt((p - q)' * C-inversa * (p - q))

dove (p - q) è un vettore a k dimensioni. Se la matrice di covarianza è la
matrice identità, la distanza di Mahalanobis corrisponde alla distanza
Euclidea.

Lo spazio in cui vengono calcolate le distanze è definito dalle variabili
selezionate; per ogni osservazione nell'intervallo attuale viene calcolata
la distanza tra l'osservazione e il centroide delle variabili selezionate.
La distanza è la controparte multidimensionale di uno z-score standard e
può essere usata per giudicare se una certa osservazione "appartiene" a un
gruppo di altre osservazioni.

Se si usa l'opzione --vcv, vengono mostrate la matrice di covarianza e la
sua inversa. Se si usa l'opzione --save, le distanze vengono salvate nel
dataset con il nome mdist (o mdist1, mdist2 e così via, se esiste già una
variabile con quel nome).

Accesso dal menù:    /Visualizza/Distanze di Mahalanobis

# makepkg Programming

Argomento:  filename 
Opzioni:    --index (crea un file ausiliario di indicizzazione)
            --translations (crea un file ausiliario di stringhe)

Permette la creazione di un "function package" da linea di comando. Il nome
di file indica il nome del pacchetto da creare e deve avere estensione .gfn.
Si veda la guida all'uso di gretl per dettagli.

Le opzioni consentono la scrittura di file ausiliari per l'uso con gli
"addon" di gretl. Il file indice è un breve documento XML contenente alcune
informazioni base sul pacchetto; ha lo stesso nome del pacchetto stesso ed
estensione .xml. Il file di traduzioni contiene le stringhe da tradurre del
pacchetto, in formato C; per il pacchetto pippo questo file deve chiamarsi
pippo-i18n.c.

Accesso dal menù:    /Tools/Function packages/New package

# markers Dataset

Varianti:   markers --to-file=nomefile
            markers --from-file=nomefile
            markers --delete

Con l'opzione --to-file, scrive nel file indicato le stringhe marcatrici
delle osservazioni presenti nel dataset corrente, una per ogni linea. Se il
dataset non contiene stringhe viene emesso un messaggio d'errore.

Con l'opzione --from-file, legge dal file specificato (che deve essere in
formato testo) e assegna alle righe del dataset i marcatori di osservazione,
leggendone uno per riga. In generale il file dovrebbe contenere tanti
marcatori quante sono le osservazioni nel dataset, ma se quest'ultimo è un
panel il numero di marcatori nel file potrebbe anche essere pari al numero
di unità in cross-section (nel qual caso i marcatori sono ripetuti a ogni
data).

L'opzione --delete fa quello che vi aspettate: cancella le stringhe
marcatrici delle osservazioni dal dataset.

# meantest Tests

Argomenti:  var1 var2 
Opzione:    --unequal-vars (assume varianze diverse)

Calcola la statistica t per l'ipotesi nulla che le medie della popolazione
siano uguali per le variabili var1 e var2, mostrando il suo p-value.

L'impostazione predefinita prevede di assumere che le varianze delle due
variabili siano uguali, mentre usando l'opzione --unequal-vars, si assume
che esse siano diverse. Questo è rilevante per la statistica test solo se
le due variabili contengono un diverso numero di osservazioni valide (non
mancanti).

Accesso dal menù:    /Modello/Modelli bivariati/Differenza delle medie

# mle Estimation

Argomenti:  funzione di log-verosimiglianza derivate 
Opzioni:    --quiet (non stampa il modello stimato)
            --vcv (mostra la matrice di covarianza)
            --hessian (calcola la matrice di covarianza a partire dall'Hessiana)
            --robust (matrice di covarianza QML)
            --verbose (mostra i dettagli delle iterazioni)
            --no-gradient-check (si veda sotto)
            --lbfgs (usa L-BFGS-B invece di BFGS)
Esempio:    weibull.inp

Esegue la stima di massima verosimiglianza (ML, Maximum Likelihood) usando
l'algoritmo BFGS (Broyden, Fletcher, Goldfarb, Shanno). Occorre specificare
la funzione di log-verosimiglianza e indicare dei valori iniziali per i
parametri della funzione (utilizzando il comando "genr". Se possibile è
consigliabile indicare anche espressioni per le derivate di questa funzione,
rispetto ad ognuno dei parametri; se non si indicano le derivate analitiche,
verrà calcolata un'approssimazione numerica.

Esempio: si supponga di avere una serie X con valori 0 o 1 e di voler
ottenere la stima di massima verosimiglianza della probabilità p che X
valga 1 (è semplice intuire che la stima ML di p corrisponderà alla
proporzione dei valori 1 nel campione).

Occorre per prima cosa aggiungere p al dataset e assegnargli un valore
iniziale; ad esempio, scalar p = 0.5.

Quindi costruiamo il blocco di comandi per la stima di massima
verosimiglianza:

       mle loglik = X*log(p) + (1-X)*log(1-p)
       deriv p = X/p - (1-X)/(1-p)
       end mle

La prima riga specifica la funzione di log-verosimiglianza: inizia con la
parola chiave mle, quindi contiene la variabile dipendente e una
specificazione per la log-verosimiglianza usando la stessa sintassi del
comando "genr". La riga seguente (che è opzionale), inizia con la parola
chiave deriv e fornisce la derivata della funzione di log-verosimiglianza
rispetto al parametro p. Se non vengono indicate derivate, occorre includere
una dichiarazione che identifica i parametri liberi (separati da spazi)
utilizzando la parola chiave params. Ad esempio si sarebbe potuto scrivere:

       mle loglik = X*log(p) + (1-X)*log(1-p)
       params p
       end mle

e in questo caso la derivata verrebbe calcolata numericamente.

Si noti che eventuali opzioni vanno indicate nella riga finale del blocco
MLE.

Per impostazione predefinita, gli errori standard sono basati sul prodotto
esterno del gradiente. Se si usa l'opzione --hessian, vengono basati
sull'inversa negativa dell'Hessiana (che è approssimata numericamente). Se
si usa l'opzione --robust, viene usato uno stimatore QML (ossia, un sandwich
dell'inversa negativa dell'Hessiana e della matrice di covarianza del
gradiente).

Se vengono fornite derivate analitiche, per default gretl effettua un
controllo numerico per valutarne l'attendibilità. Talvolta questo controllo
può produrre dei falsi positivi; altre parole derivate corrette sembrano
essere errate e il comando si rifiuta di completare la stima. Per evitare
questa possibilità o per realizzare un piccolo guadagno in termini di tempo
è possibile ricorrere all'opzione --no-gradient-check. Naturalmente è
opportuno ricorrere a questa opzione solo se si è convinti convinti della
correttezza del gradiente specificato.

Per una descrizione molto più approfondita di "mle", per favore consultate
la guida all'uso di gretl.

Accesso dal menù:    /Modello/Massima verosimiglianza

# modeltab Utilities

Varianti:   modeltab add
            modeltab show
            modeltab free
            modeltab --output=nomefile

Manipola la "tabella modelli" di gretl. Si veda la la guida all'uso di gretl
per i dettagli. Le opzioni hanno i seguenti effetti: "add" aggiunge l'ultimo
modello stimato alla tabella modelli, se possibile; "show" mostra la tabella
modelli in una finestra; "free" pulisce la tabella.

Per stampare la tabella del modello usate l'opzione --output= seguita dal
nome di un file. Se quest'ultimo ha il suffisso ".tex", l'output sarà in
formato TeX; se il suffisso è ".rtf" l'output sarà RTF; in caso contrario
sarà in formato di testo. Nel caso di output in formato TeX per default
verrà prodotto un "frammento" pronto per essere inserito in un documento;
se invece si preferisce ottenere un documento completo, usate l'opzione
--complete; per esempio,

	modeltab --output="myfile.tex" --complete

Accesso dal menù:    Finestra delle icone, Icona Tabella Modelli

# modprint Printing

Argomenti:  matcoeff nomi [ stat ] 

Stampa la tabella dei coefficienti e le statistiche aggiuntive opzionali per
un modello stimato "a mano". Utile principalmente per le funzioni definite
dall'utente.

L'argomento matcoeff deve essere una matrice k per 2 che contiene k
coefficienti e k errori standard associati, mentre nomi deve essere una
stringa che contiene almeno k nomi, separati da virgole, per i coefficienti.

L'argomento opzionale stat è un vettore che contiene p statistiche
aggiuntive da stampare sotto la tabella dei coefficienti. Se si usa questo
argomento, nomi deve contenere k + p stringhe separate da virgola, di cui le
ultime p sono associate alle statistiche aggiuntive.

# modtest Tests

Argomento:  [ ordine ] 
Opzioni:    --normality (normalità dei residui)
            --logs (non-linearità, logaritmi)
            --autocorr (correlazione seriale)
            --arch (ARCH)
            --squares (non-linearità, quadrati)
            --white (eteroschedasticità, test di White)
            --white-nocross (eteroschedasticità, test di White (solo quadrati))
            --breusch-pagan (eteroschedasticità, test di Breusch-Pagan)
            --robust (stima robusta della varianza per Breusch-Pagan)
            --panel (eteroschedasticità, a gruppi)
            --comfac (restrizione a fattore comune, (solo modelli AR1))
            --quiet (non mostra la regressione ausiliaria)

Deve seguire immediatamente un comando di stima. A seconda dell'opzione
usata, il comando esegue uno dei test seguenti: test di Doornik-Hansen per
la normalità del termine di errore; test dei moltiplicatori di Lagrange per
la non-linearità (logaritmi o quadrati); test di White (con o senza i
prodotti incrociati) o test di Breusch-Pagan per l'eteroschedasticità
(Breusch and Pagan, 1979), test LMF per la correlazione seriale (si veda
(Kiviet, 1986)); test per il modello ARCH (Autoregressive Conditional
Heteroskedasticity, si veda anche il comando "arch"); o restrizione a
fattore comune, (solo modelli AR1). La maggior parte delle opzioni sono
disponibili solo per modelli stimati con OLS, ma si veda oltre per alcuni
dettagli riguardanti la stima con i minimi quadrati a due stadi.

L'argomento opzionale ordine è rilevante solo nel caso si scelga l'opzione
--autocorr o l'opzione --arch. Per impostazione predefinita, questi test
sono eseguiti usando un ordine di ritardo pari alla periodicità dei dati,
ma è possibile anche impostare un ordine di ritardo specifico.

L'opzione --robust ha effetto solo se viene scelto il test di Breusch-Pagan;
l'effetto è quello di usare lo stimatore robusto per la varianza proposto
da Koenker (1981), rendendo il test meno sensibile all'ipotesi di
normalità.

L'opzione --panel è disponibile solo se il modello viene stimato su dati
panel: in questo caso viene eseguito un test per eteroschedasticità a
gruppi (ossia per una varianza dell'errore diversa fra le unità cross
section).

L'opzione --comfac è disponibile solo quando il modello è stimato usando
un metodo AR(1), come quello di Hildreth-Lu. La regressione ausiliaria ha la
struttura di un modello dinamico relativamente poco vincolato ed è usata
per verificare il vincolo di fattori comuni implicito nella specificazione
AR(1).

Per impostazione predefinita, il programma mostra la regressione ausiliaria
su cui si basa la statistica test, ma è possibile evitarlo usando l'opzione
--quiet. La statistica test e il suo p-value possono essere recuperati
usando le variabili accessorie $test e $pvalue.

Nel caso di modelli stimati col metodo dei minimi quadrati a due stadi (si
veda "tsls"), non è possibile usare il test LM, quindi gretl offre alcuni
test equivalenti; in questo caso, l'opzione --autocorr calcola il test di
Godfrey per l'autocorrelazione (si veda Godfrey 1994), mentre l'opzione
--white produce il test HET1 per l'eteroschedasticità (si veda Pesaran e
Taylor 1999).

Accesso dal menù:    Finestra del modello, /Test

# mpols Estimation

Argomenti:  variabile-dipendente variabili-indipendenti 
Opzioni:    --vcv (mostra la matrice di covarianza)
            --simple-print (non mostra le statistiche ausiliarie)
            --quiet (non mostra i risultati)

Calcola le stime OLS per il modello indicato usando aritmetica in virgola
mobile a precisione multipla. Questo comando è disponibile solo se gretl è
compilato con il supporto per la libreria Gnu Multiple Precision (GMP). Per
impostazione predefinita, vengono usati 256 bit di precisione nei calcoli,
ma è possibile aumentare questo valore usando la variabile d'ambiente
GRETL_MP_BITS. Ad esempio, usando l'interprete dei comandi bash, è
possibile aumentare la precisione a 1024 bit eseguendo il comando seguente
prima di avviare gretl

	export GRETL_MP_BITS=1024

Per questo comando è disponibile un'opzione abbastanza speciale (utile
soprattutto a scopo di test): se la lista variabili-indipendenti è seguita
da un punto e virgola, e da un'ulteriore lista di numeri, questi numeri
vengono interpretati come potenze di x da aggiungere alla regressione, dove
x è l'ultima variabile della lista variabili-indipendeti. Questi termini
addizionali vengono calcolati e memorizzati in precisione multipla.
Nell'esempio seguente, y è regredita su x e sulla seconda, terza e quarta
potenza di x:

	mpols y 0 x ; 2 3 4

Accesso dal menù:    /Modello/Altri modelli lineari/MPOLS - Minimi quadrati in alta precisione

# negbin Estimation

Argomenti:  depvar indepvars [ ; offset ] 
Opzioni:    --model1 (usa il modello NegBin 1)
            --robust (matrice di covarianza QML)
            --cluster=clustvar (vedi "logit" per una spegazione)
            --opg (vedi sotto)
            --vcv (stampa la matrice di covarianze)
            --verbose (mostra i dettagli delle iterazioni)

Stima un modello Binomiale Negativo. Il comando assume che la variabile
dipendente rappresenti un conteggio del numero di volte in cui si è
verificato un certo evento e deve assumere solo valori interi non negativi.
Di default, viene usata la distribuzione NegBin 2, in cui la varianza
condizionale è data da mu(1 + αmu), dove mu denota la media condizionale.
Tuttavia, se vien data l'opzione --model1 allora la varianza condizionale
sarà data da mu(1 + α).

L'argomento opzionale offset funziona come per il comando "poisson". In
effetti, il modello di Poisson è un caso particolare del binomiale negativo
con α = 0.

Di default, gli errori standard vengono calcolati unsando un'approssimazione
numerica dell'Hessiana sul punto di massimo. Con l'opzione --opg la matrice
di covarianze verrà invece calcolata tramite il prodotto esterno dei
gradienti (OPG), o via QML con l'opzione --robust usando un "sandwich"
dell'hessiana inversa e dell'OPG.

Accesso dal menù:    /Model/Nonlinear models/Count data...

# nls Estimation

Argomenti:  funzione [ derivate ] 
Opzioni:    --quiet (non stampa il modello stimato)
            --robust (errori standard robusti)
            --vcv (mostra la matrice di covarianza)
            --verbose (mostra i dettagli delle iterazioni)
Esempio:    wg_nls.inp

Esegue una stima con minimi quadrati non-lineari (NLS: Nonlinear Least
Squares) usando una versione modificata dell'algoritmo di
Levenberg-Marquardt. Occorre fornire una specificazione di funzione e
dichiarare i parametri della funzione (usando il comando "genr") prima della
stima. Opzionalmente, è anche possibile specificare le espressioni per le
derivate della funzione rispetto a ognuno dei parametri. Se non si indicano
le derivate, occorre fornire una lista dei parametri da stimare (separati da
spazi o virgole), preceduta dalla parola chiave params. In quest'ultimo
caso, viene calcolata un'approssimazione numerica del Jacobiano.

È più semplice mostrare il funzionamento con un esempio. Quello che segue
è uno script completo per stimare la funzione di consumo non-lineare
presentata in Econometric Analysis di William Greene (capitolo 11 della
quarta edizione, o capitolo 9 della quinta). I numeri alla sinistra delle
righe sono dei punti di riferimento e non fanno parte dei comandi. Si noti
che le opzioni, come ad esempio --vcv per mostrare la matrice di covarianza
delle stime dei parametri, vanno aggiunte al comando finale end nls.

	1   open greene11_3.gdt
	2   ols C 0 Y
	3   genr a = $coeff(0)
	4   genr b = $coeff(Y)
	5   genr g = 1.0
	6   nls C = a + b * Y^g
	7   deriv a = 1
	8   deriv b = Y^g
	9   deriv g = b * Y^g * log(Y)
	10  end nls --vcv

Spesso è comodo inizializzare i parametri con riferimento a un modello
lineare collegato, come è mostrato nelle righe da 2 a 5. I parametri alfa,
beta e gamma possono essere impostati a qualunque valore iniziale (non
necessariamente sulla base di un modello stimato con OLS), ma la convergenza
della procedura NLS non è garantita per qualunque punto di partenza.

I veri comandi NLS occupano le righe da 6 a 10. Sulla riga 6 viene dato il
comando "nls": viene specificata una variabile dipendente, seguita dal segno
uguale, seguito da una specificazione di funzione. La sintassi per
l'espressione a destra è la stessa usata per il comando "genr". Le tre
righe successive specificano le derivate della funzione di regressione
rispetto a ognuno dei parametri. Ogni riga inizia con il comando "deriv",
indica il nome di un parametro, il segno di uguale e un'espressione che
indica come calcolare la derivata (anche qui la sintassi è la stessa di
"genr"). In alternativa, invece di fornire le derivate, è possibile
sostituire le righe dalla 7 alla 9 con la seguente:

	params a b g

La riga 10, "end nls", completa il comando ed esegue la stima.

Per ulteriori dettagli sulla stima NLS si veda la la guida all'uso di gretl.

Accesso dal menù:    /Modello/Modelli non lineari/NLS - Minimi quadrati non lineari

# normtest Tests

Argomento:  series 
Opzioni:    --dhansen (test Doornik-Hansen)
            --swilk (test di Shapiro-Wilk)
            --lillie (test di Lilliefors)
            --jbera (test di Jarque-Bera)
            --all (esegue tutti i test)
            --quiet (non mostra i dettagli dei risultati)

Conduce un test di normalità per la serie specificata. Il tipo di test
eseguito è determinato dalle opzioni del comando (se non ne viene usata
alcuna, viene eseguito il test di Doornik-Hansen). Si noti che il test di
Jarque-Bera test, sebbene semplice da calcolare, ha un'accuratezza
relativamente bassa in campioni limitati, quindi se ne raccomanda l'uso
principalmente a scopo di confronto.

La statistica test e il suo p-value possono essere recuperati usando gli
accessori $test e $pvalue. Se si usa l'opzione --all, i risultati salvati
saranno queslli del test di Doornik-Hansen.

# nulldata Dataset

Argomento:  lunghezza_serie 
Opzione:    --preserve (preserva le matrici)
Esempio:    nulldata 500

Crea un dataset "vuoto", che contiene solo una costante e una variabile
indice, con periodicità 1 e il numero indicato di osservazioni. Ad esempio,
è possibile creare un dataset a scopo di simulazione usando alcuni comandi
"genr" (come "genr uniform()" e "genr normal()") per generare dati di prova.
Questo comando può essere usato insieme a "loop". Si veda anche l'opzione
"seed" del comando "set".

Per impostazione predefinita, questo comando cancella tutti i dati presenti
nell'ambiente di lavoro di gretl. Usando l'opzione --preserve, verranno
mantenute tutte le matrici attualmente definite.

Accesso dal menù:    /File/Nuovo dataset

# ols Estimation

Argomenti:  variabile-dipendente variabili-indipendenti 
Opzioni:    --vcv (mostra la matrice di covarianza)
            --robust (errori standard robusti)
            --jackknife (vedi sotto)
            --simple-print (non mostra le statistiche ausiliarie)
            --quiet (non mostra i risultati)
            --anova (stampa una tabella ANOVA)
            --no-df-corr (sopprime la correzione per i gradi di libertà)
            --print-final (si veda sotto)
Esempi:     ols 1 0 2 4 6 7
            ols y 0 x1 x2 x3 --vcv
            ols y 0 x1 x2 x3 --quiet

Calcola le stime minimi quadrati ordinari (OLS: Ordinary Least Squares)
usando la variabile-dipendente e la lista di variabili-indipendenti, che
possono essere specificate per nome o numero. Il termine costante può
essere indicato usando il numero 0.

Oltre alle stime dei coefficienti e agli errori standard, il programma
mostra i p-value per le statistiche t (a due code) e F. Un p-value inferiore
a 0.01 indica significatività al livello dell'1 per cento ed è denotato
con ***. ** indica invece la significatività tra l'1 e il 5 per cento,
mentre * indica un livello di significatività tra il 5 e il 10 per cento.
Vengono mostrate anche le statistiche di selezione del modello (il criterio
di informazione di Akaike, AIC, e il criterio di informazione bayesiana di
Schwarz, BIC). La formula usata per AIC è descritta in Akaike (1974), ossia
meno due volte la log-verosimiglianza massimizzata più il doppio del numero
di parametri stimati.

Usando l'opzione --no-df-corr la correzione per i gradi di libertà non
viene applicata nel calcolo della varianza stimata dell'errore (e quindi
anche dell'errore standard delle stime dei parametri).

L'opzione --print-final è utilizzabile solo nel contesto di un "loop".
L'effetto è quello di eseguire la regressione in modo silenzioso per tutte
le iterazioni del loop tranne l'ultima. Si veda la la guida all'uso di gretl
per i dettagli.

È possibile salvare alcune variabili interne generate durante la stima,
usando il comando "genr" subito dopo questo comando.

La formula usata per generare gli errori standard robusti (quando viene
usata l'opzione --robust) può essere modificata con il comando "set".
L'opzione --jackknife equivale a impostare hc_version a 3a, in modo da
emulare il vecchio comando hccm.

Accesso dal menù:    /Modello/OLS - Minimi quadrati ordinari
Accesso alternativo: Pulsante Beta-hat sulla barra degli strumenti

# omit Tests

Argomento:  lista-variabili 
Opzioni:    --wald (esegue un test di Wald invece che un test F)
            --vcv (mostra la matrice di covarianza)
            --quiet (non mostra le stime per il modello ridotto)
            --silent (non mostra nulla)
            --auto=alpha (eliminazione sequenziale, si veda oltre)
            --inst (omette come strumento, solo per TSLS)
            --both (omette come regressore e come strumento, solo per TSLS)
Esempi:     omit 5 7 9
            omit seasonals --quiet
            omit --auto
            omit --auto=0.05

Questo comando deve seguire un comando di stima e calcola un test per la
significatività congiunta delle variabili nella lista-variabili, che deve
essere un sottoinsieme delle variabili indipendenti del modello stimato in
precedenza. In alternativa, se si usa l'opzione --auto viene attivata la
procedura di eliminazione sequenziale: ad ogni passo viene omessa la
variabile con il p-value più alto, fino a che tutte le variabili restanti
hanno un p-value inferiore a una certa soglia. La soglia predefinita è del
10 per cento (con due code), che può essere modificata aggiungendo "=" e un
valore tra 0 e 1 (senza spazi), come nel quarto esempio mostrato sopra.

Se il modello originale è stato stimato con OLS, la statistica test è un
valore F, basato sulle somme dei quadrati dei residui del modello vincolato
e di quello originale, a meno che quest'ultimo sia stato stimato usando
errori standard robusti. In questo caso, il valore F viene calcolato delle
stime robuste della matrice di covarianza del modello originale (è la
versione F di un test di Wald).

Per gli stimatori diversi da OLS, o se si usa l'opzione --wald, la
statistica usata è un valore chi-quadro asintotico di Wald, basato sulla
matrice di covarianza del modello originale.

Per impostazione predefinita, viene stimato il modello vincolato, vengono
mostrate le stime e il modello vincolato rimpiazza quello originale come
"modello attuale" nel caso si voglia, ad esempio, recuperare i residui con
$uhat (o eseguire test ulteriori, come "add" o "omit").

Usando l'opzione Wald, il modello vincolato non viene stimato (quindi il
modello attuale non viene rimpiazzato). L'opzione --quiet sopprime la stampa
dei risultati del modello vincolato (se esso viene stimato): viene mostrato
solo il risultato del test. Se il modello vincolato viene stimato e ne viene
chiesta la stampa, l'opzione --vcv ha l'effetto di mostrare la matrice di
covarianza dei coefficienti del modello vincolato, altrimenti quest'opzione
è ignorata.

Se si usa l'opzione --silent, non viene mostrato alcun risultato; tuttavia,
i risultati del test possono essere recuperati usando le variabili speciali
$test e $pvalue.

Se il modello originale è stato stimato con i minimi quadrati a due stadi,
può sorgere un'ambiguità: le nuove variabili vanno omesse come regressori,
come strumenti o con entrambe le funzioni? Per risolvere l'ambiguità, nella
modalità predefinita le variabili sono omesse dall'elenco dei regressori,
se si usa l'opzione --inst sono omesse dall'elenco degli strumenti, mentre
se si usa l'opzione --both sono rimosse totalmente dal modello. Queste due
opzioni sono incompatibili con l'opzione --wald; se uno o più strumenti
vengono omessi, il modello va ri-stimato.

Accesso dal menù:    Finestra del modello, /Test/OMIT - Ometti variabili

# open Dataset

Argomento:  file-dati 
Opzioni:    --www (usa un database sul server di gretl)
            Si veda oltre per le opzioni specifiche per i fogli elettronici
Esempi:     open data4-1
            open voter.dta
            open fedbog --www

Apre un file di dati. Se è già stato aperto un file di dati, esso viene
sostituito da quello selezionato. Se non si specifica un percorso completo,
il programma cercherà automaticamente il file in alcuni percorsi
predefiniti. Se non si specifica un'estensione per il file, come nel primo
degli esempi, gretl assume che si tratti di un file di dati standard, con
estensione .gdt. A seconda del nome del file e di alcune sue
caratteristiche, gretl cerca di indovinare il formato dei dati (standard,
testo semplice, CSV, MS Excel, Stata, ecc).

Quando si apre un file di un foglio elettronico (Gnumeric, Open Document o
XLS), è possibile fornire fino a tre parametri aggiuntivi, oltre al nome
del file. Per prima cosa, è possibile selezionare un particolare foglio di
lavoro all'interno del file, indicando il suo numero con la sintassi
--sheet=2, oppure indicando il suo nome tra virgolette doppie, usando la
sintassi --sheet="MacroData". L'impostazione predefinita consiste nel
leggere il primo foglio di lavoro del file. È anche possibile specificare
la riga/colonna da cui iniziare a leggere, usando la sintassi

	--coloffset=3 --rowoffset=2

che indica a gretl di ignorare le prime 3 colonne e le prime 2 righe.
L'impostazione predefinita consiste nel leggere tutte le celle del foglio, a
partire dalla prima in alto a sinistra.

Questo comando può essere usato anche per aprire un database (gretl, RATS
4.0 o PcGive) per la lettura. In questo caso, dev'essere seguito dal comando
"data" per estrarre una particolare serie dal database. Se si usa l'opzione
www, il programma cercherà di accedere al database specificato sul server
di gretl -- ad esempio il database "Federal Reserve interest rates" nel
terzo degli esempi visti sopra.

Accesso dal menù:    /File/Apri dati
Accesso alternativo: Trascinare un file di dati in gretl (MS Windows o Gnome)

# orthdev Transformations

Argomento:  lista-variabili 

Utilizzabile solo con dati panel. Per ognuna delle variabili nella
lista-variabili viene generata una serie di deviazioni ortogonali in avanti,
salvata col nome della variabile prefissata da o_. Quindi, "orthdev x y"
crea le nuove variabili o_x e o_y.

I valori sono salvati con un periodo di ritardo rispetto alla loro
collocazione temporale (ossia, o_x all'osservazione t contiene la deviazione
che, in senso stretto, corrisponde al periodo t - 1). Questo comportamento
è coerente con quello delle differenze prime: viene persa la prima
osservazione di ogni serie, non l'ultima.

# outfile Printing

Argomenti:  file-output opzione 
Opzioni:    --append (aggiunge al file)
            --close (chiude il file)
            --write (sovrascrive il file)
Esempi:     outfile --write regress.txt
            outfile --close

Scrive i risultati sul file-output, fino a nuovo ordine. Usando l'opzione
--append, i risultati vengono aggiunti a un file esistente, mentre --write
apre un nuovo file (o ne sovrascrive uno esistente). Può essere aperto solo
un file alla volta.

L'opzione --close può essere usata per chiudere un file di output aperto in
precedenza, tornando a scrivere i risultati sul canale predefinito.

Nel primo degli esempi precedenti viene aperto il file regress.txt, mentre
nel secondo viene chiuso. Se prima del comando --close fosse eseguito un
comando "ols", i risultati della regressione verrebbero scritti su
regress.txt invece che sullo schermo.

Esiste una variante: se si usa la parola chiave null al posto di un nome di
file insieme all'opzione --write, l'effetto è quello di sopprimere la
stampa dei risultati fino alla successiva istruzione outfile --close.

# panel Estimation

Opzioni:    --vcv (mostra la matrice di covarianza)
            --fixed-effects (stima con effetti di gruppo fissi)
            --random-effects (effetti casuali o modello GLS)
            --between (stima il modello tra i gruppi)
            --time-dummies (include variabili dummy temporali)
            --unit-weights (minimi quadrati ponderati)
            --iterate (stima iterativa)
            --quiet (mostra meno risultati)
            --verbose (mostra più risultati)

Stima un modello panel, per impostazione predefinita usando lo stimatore a
effetti fissi; la stima è implementata sottraendo le medie di gruppo o
delle unità dai dati originali.

Se si usa l'opzione --random-effects, viene usato il modello GLS a effetti
casuali, usando il metodo di Swamy e Arora.

In alternativa, con l'opzione --unit-weights, il modello viene stimato con i
minimi quadrati ponderati, con i pesi costruiti a partire dalla varianza
residua per le rispettive unità cross section nel campione. Solo in questo
caso, è possibile usare l'opzione --iterate per produrre stime iterative:
nel caso di convergenza, le stime sono di massima verosimiglianza.

Come ulteriore alternativa, se si usa l'opzione --between, viene stimato il
modello tra i gruppi, ossia una regressione OLS usando le medie dei gruppi.

Per maggiori dettagli sulla stima panel, si veda la la guida all'uso di
gretl.

Accesso dal menù:    /Modello/Panel

# pca Statistics

Argomento:  lista-variabili 
Opzioni:    --covariance (usa la matrice di covarianza)
            --save (salva le componenti principali)
            --save-all (salva tutte le componenti)

Analisi delle componenti principali. Mostra gli autovalori della matrice di
correlazione (o della matrice di covarianza, se si usa l'opzione
--covariance) per le variabili nella lista-variabili, insieme alla
proporzione della varianza comune spiegata da ogni componente. Mostra anche
i corrispondenti autovettori (o "pesi della componente").

Usando l'opzione --save, le componenti con autovalori maggiori di 1.0
vengono salvati nel dataset come variabili, con i nomi PC1, PC2 e così via.
Queste variabili artificiali sono definite come la somma del peso della
componente moltiplicato per Xi standardizzato, dove Xi denota la i-esima
variabile nella lista-variabili.

Usando l'opzione --save-all, vengono salvate tutte le componenti, come
descritto sopra.

Accesso dal menù:    /Visualizza/Componenti principali
Accesso alternativo: Pop-up nella finestra principale (selezione multipla)

# pergm Statistics

Argomenti:  nome-variabile [ banda ] 
Opzioni:    --bartlett (usa la finestra di Bartlett)
            --log (usa una scala logaritmica)

Calcola e mostra (graficamente se non si è in modalità batch) lo spettro
della variabile specificata. Per impostazione predefinita viene mostrato il
periodogramma nel campione, mentre usando l'opzione --bartlett, lo spettro
viene stimato usando una finestra di Bartlett per i ritardi (si veda ad
esempio Econometric Analysis di Greene per una discussione su questo
argomento). L'ampiezza predefinita della fiestra di Bartlett è pari a due
volte la radice quadrata dell'ampiezza campionaria, ma questo valore può
essere impostato manualmente usando il parametro banda, fino a un massimo
pari a metà dell'ampiezza campionaria. Usando l'opzione --log, lo spettro
viene rappresentato su una scala logaritmica.

Quando viene mostrato il periodogramma del campione, vengono mostrati anche
due test per l'integrazione frazionale ("memoria lunga") della serie, ossia
il test di Geweke e Porter-Hudak (GPH), e lo stimatore locale di Whittle.
L'ipotesi nulla in entrambi i casi è che l'ordine di integrazione sia zero.
Per impostazione predefinita, l'ordine per questi test è il valore minore
tra T/2 e T^0.6; anche questo valore può essere modificato con il parametro
di banda.

Accesso dal menù:    /Variabile/Spettro
Accesso alternativo: Menù pop-up nella finestra principale (selezione singola)

# poisson Estimation

Argomenti:  variabile-dipendente variabili-indipendenti [ ; offset ] 
Opzioni:    --vcv (mostra la matrice di covarianza)
            --verbose (mostra i dettagli delle iterazioni)
Esempi:     poisson y 0 x1 x2
            poisson y 0 x1 x2 ; S

Stima una regressione di Poisson, in cui la variabile dipendente rappresenta
le occorrenze di un qualche tipo di evento e può assumere solo valori
interi non negativi.

Se una variabile casuale discreta Y segue la distribuzione di Poisson,

  Pr(Y = y) = exp(-v) * v^y / y!

per y = 0, 1, 2,.... La media e la varianza della distribuzione sono
entrambe uguali a v. Nel modello di regressione di Poisson, il parametro v
è rappresentato da una funzione di una o più varabili indipendenti. La
versione più comune del modello (e l'unica supportata da gretl) ha

  v = exp(b0 + b1*x1 + b2*x2 + ...)

ossia il logaritmo di v è una funzione lineare delle variabili
indipendenti.

Opzionalmente è possibile aggiungere una variabile "offset" alla
specificazione, ossia una variabile di scala, il cui logaritmo viene
aggiunto alla funzione di regressione lineare (con un coefficiente implicito
di 1.0). Ciò ha senso se si ipotizza che il numero di occorrenze
dell'evento in questione sia proporzionale a qualche fattore noto, a parità
di altre condizioni. Ad esempio, il numero di incidenti stradali può essere
ipotizzato proporzionale al volume del traffico, che potrebbe essere
specificato come una variabile di "offset" in un modello di Poisson per il
tasso di incidenti. La variabile di offset dev'essere strettamente positiva.

Accesso dal menù:    /Modello/Modelli non lineari/Poisson

# print Printing

Argomenti:  lista-variabili  o stringa-letterale 
Opzioni:    --byobs (per osservazione)
            --no-dates (usa i numeri delle osservazioni)
Esempi:     print x1 x2 --byobs
            print "Questa è una stringa"

Se viene indicata una lista-variabili, stampa i valori delle variabili
specificate, altrimenti stampa i valori di tutte le variabili nel dataset in
uso. Usando l'opzione --byobs i dati vengono stampati per osservazione,
altrimenti sono stampati per variabile.

Se si usa l'opzione --byobs e i dati sono mostrati per osservazione, il
comportamento predefinito è quello di mostrare la data (per serie storiche)
o il marcatore (se esiste) all'inizio di ogni riga. L'opzione --no-dates
sopprime la visualizzazione delle date o dei marcatori: viene mostrato solo
un semplice numero di osservazione.

Se l'argomento di "print" è una stringa letterale (che deve iniziare con le
virgolette doppie "), la stringa viene stampata così come è stata
indicata. Si veda anche "printf".

Nota: c'è un "trucco" con questo comando, usando l'opzione --byobs, che
può essere utile quando si lavora su un dataset con valori mancanti. Se si
fornisce una lista di variabili seguite da un punto e virgola e da una
variabile finale, la variabile finale non viene mostrata, ma viene usata per
selezionare le osservazioni da mostrare. Le osservazioni per cui la
variabile finale assume valore 0 non verranno mostrate. Ad esempio, si
supponga di avere la serie giornaliera x e di volere la lista delle date per
cui x ha valori mancanti. Si può procedere nel modo seguente:

	genr filt = missing(x)
	print x ; filt --byobs

Accesso dal menù:    /Dati/Mostra valori

# printf Printing

Argomenti:  formato , argomenti 

Stampa valori scalari, serie, matrici o stringhe formattandoli secondo le
indicazioni di una stringa di formato (che supporta un piccolo sottoinsieme
del comando printf() del linguaggio di programmazione C). I formati numerici
riconosciuti sono %e, %E, %f, %g, %G e %d, con i vari modificatori
disponibili in C. Esempi: la stringa di formato %.10g stampa un valore con
10 cifre significative; %12.6f stampa un valore con 6 cifre decimali e una
larghezza di 12 caratteri. Per formattare le stringhe occorre usare la
stringa di formato %s.

La stringa di formato deve essere racchiusa tra virgolette doppie, i valori
da stampare devono seguire la stringa di formato, separati da virgole. I
valori possono avere tre forme: a) nomi di variabili; b) espressioni valide
per il comando "genr"; c) le funzioni speciali varname() o date(). L'esempio
seguente stampa i valori di due variabili e quello di un'espressione
calcolata:

	ols 1 0 2 3
	genr b = $coeff(2)
	genr se_b = $stderr(2)
	printf "b = %.8g, standard error %.8g, t = %.4f\n", b, se_b, b/se_b

Le prossime righe mostrano l'uso delle funzioni varname e date, che
rispettivamente mostrano il nome di una variabile dato il suo numero
identificativo, e una stringa data, dato un numero di osservazione.

 	printf "Il nome della variabile %d è %s\n", i, varname(i)
 	printf "La data dell'osservazione %d è %s\n", j, date(j)

Se si usa un argomento matrice insieme a un formato numerico, l'intera
matrice verrà stampata usando per ogni elemento il formato numerico
indicato. La stessa cosa vale per le serie, tranne per il fatto che
l'intervallo di valori stampato è controllato dall'impostazione del
campione corrente.

La lunghezza massima di una stringa di formato è di 127 caratteri. Vengono
riconosciute le sequenze di escape \n (newline), \t (tab), \v (tab
verticale) e \\ (barra inversa). Per stampare un segno di percentuale, si
usi %%.

Come in C, i valori numerici che fanno parte del formato (larghezza e
precisione) possono essere dati direttamente come numeri, come in %10.4f, o
come variabili. Nell'ultimo caso, si inseriscono asterischi nella stringa di
formato e si forniscono nell'ordine gli argomenti corrispondenti. Ad
esempio:

	scalar larghezza = 12
	scalar precisione = 6
	printf "x = %*.*f\n", larghezza, precisione, x

# probit Estimation

Argomenti:  variabile-dipendente variabili-indipendenti 
Opzioni:    --robust (errori standard robusti)
            --vcv (mostra la matrice di covarianza)
            --verbose (mostra i dettagli delle iterazioni)
            --p-values (mostra i p-value invece degli effetti
	  marginali)
            --random-effects (stima un modello panel a effetti casuali (RE))
            --quadpoints=k (numero di punti di quadratura per la stima RE)

Se la variabile dipendente è binaria (tutti i suoi valori sono 0 o 1),
esegue una stima di massima verosimiglianza dei coefficienti delle
variabili-indipendenti con il metodo Newton-Raphson. Visto che il modello è
nonlineare, gli effetti marginali (pendenze) dipendono dai valori delle
variabili indipendenti: per impostazione predefinita, al posto dei p-value
vengono mostrate le pendenze rispetto ad ognuna delle variabili
indipendenti, calcolate in corrispondenza della media della variabile.
Questo comportamento può essere soppresso usando l'opzione --p-values. La
statistica chi-quadro testa l'ipotesi nulla che tutti i coefficienti tranne
la costante siano pari a zero.

In modalità predefinita, gli errori standard sono calcolati tramite
l'Hessiana. Se si usa l'opzione --robust, verranno calcolati gli errori
standard QML (Huber-White). In questo caso, la matrice di covarianza stimata
è un "sandwich" dell'inversa dell'Hessiana stimata e del prodotto esterno
del gradiente. Per i dettagli, si veda Davidson e MacKinnon 2004, cap. 10.

Con l'opzione --random-effects, il termine di errore è composto per ipotesi
da due componenti gaussiane: una, specifica per l'unità cross-sezionale e
invariante nel tempo (nota come "effetto individuale") e l'altra specifica
per quella particolare osservazione.

Il calcolo della log-verosimiglianza per questo modello viene effettuato
tramite la quadratura di Gauss-Hermite per approssimare il valore di valori
attesi di funzioni di variabili casuali normali. Il numero di punti di
quadratura usati si può scegliere tramite l'opzione --quadpoints (il
default è 32). Un numero elevato di questi aumenta l'accuratezza dei
risultati, ma al costo di tempi di calcolo più lunghi; in questo caso la
stima può richiedere molto tempo con dataset grandi.

Oltre ai parametri standard (e statistiche associate) relativi alle
variabili esplicative, dopo la stima di questo tipo di modello vengono
presentati alcuni risultati aggiuntivi:

  lnsigma2: la stima ML del logaritmo della varianza dell'effetto
  individuale;

  sigma_u: la stima dell'errore quadratico medio dell'effetto individuale;

  rho: la quota stima dell'effetto individuale sulla varianza totale del
  termine di errore composito (anche nota come correlazione intra-classe).

Il test LR per l'ipotesi rho=0 consente di stabilire se la specificazione a
effetti random è in effetti necessaria. Sotto la nulla, una semplice
specificazione probit è del tutto adeguata.

Se la variabile dipendente non è binaria, ma è discreta, si ottengono
stime Probit ordinali. Se la variabile scelta come dipendente non è
discreta, viene emesso un messaggio di errore.

Il probit per l'analisi delle proporzioni non è ancora stato implementato
in gretl.

Accesso dal menù:    /Modello/Modelli non lineari/Probit

# pvalue Utilities

Argomenti:  distribuzione [ parametri ] valore-x 
Esempi:     pvalue z zscore
            pvalue t 25 3.0
            pvalue X 3 5.6
            pvalue F 4 58 fval
            pvalue G forma scala x
            pvalue B bprob 10 6
            pvalue P lambda x
            pvalue W shape scale x

Calcola l'area alla destra del valore-x nella distribuzione indicata (z per
la Gaussiana, t per la t di Student, X per la chi-quadro, F per la F, G per
la gamma, B per la binomiale, P per la Poisson e W for Weibull).

A seconda della distribuzione, occorre fornire le seguenti informazioni,
prima del valore-x: per le distribuzioni t e chi-quadro occorre indicare i
gradi di libertà; per la F sono richiesti i gradi di libertà al numeratore
e al denominatore; per la gamma sono richiesti il parametro di forma e
quello di scala; per la binomiale sono richieste la probabilità di
"successo" e il numero di prove; per la distribuzione di Poisson va indicato
il parametro lambda (che rappresenta sia la media che la varianza); per la
distribuzione Weibull, i parametri di forma e scala. Come si vede dagli
esempi precedenti, gli argomenti numerici possono essere indicati sotto
forma di numero o come nomi di variabili.

Si noti che talvolta la distribuzione gamma viene caratterizzata dai
parametri di media e varianza, invece che da quelli di forma e scala. La
media è il prodotto di forma e scala, mentre la varianza è il prodotto tra
la forma e il quadrato della scala. Quindi la scala si può ottenere come la
varianza divisa per la media, mentre la forma come la media divisa per la
scala.

Accesso dal menù:    /Strumenti/Calcola p-value

# qlrtest Tests

Per un modello stimato con OLS su serie storiche, esegue il test del
rapporto di verosimiglianza di Quandt (QLR) per un break strutturale in un
punto incognito del campione, escludendo il 15% delle osservazioni
all'inizio e ella fine del campione.

Per ogni possibile punto di rottura compreso nel 70% centrale delle
osservazioni, viene eseguito un test di Chow (si veda "chow"). La statistica
del test QLR è il massimo dei valori F di questi test; segue una
distribuzione non standard, i cui valori critici sono presi da Introduction
to Econometrics di Stock e Watson (2003). Se la statistica QLR eccede il
valore critico per un dato livello di significatività, è possibile
inferire che i parametri del modello non sono costanti. Questa statistica
può essere usata per riconoscere forme di instabilità diverse da un
singolo punto di rottura, ad esempio più punti di rottura o un lento
cambiamento dei parametri.

Accesso dal menù:    Finestra del modello, /Test/QLR

# qqplot Graphs

Varianti:   qqplot y
            qqplot y x
Opzioni:    --z-scores (v. oltre)
            --raw (v. oltre)

Con una sola serie come argomento, mostra un grafico della distribuzione
empirica della serie stessa (indicata col nome o con il suo numero ID)
contro i quantili della normale. La serie deve includere almeno 20 valori
validi nel campione selezionato al momento. Per impostazione predefinita, i
quantili empirici vengono disegnati contro quelli della normale avente media
e varianza uguali a quelli campionari della serie, ma sono disponibili due
alternative: con l'opzione --z-scores, i dati vengono standardizzati prima,
oppure, con l'opzione --raw, i quantili empirici possono essere disegnati
contro quelli della normale standardizzata.

Tramite l'opzione --output si invia il grafico al file desiderato; usare
"display" per forzare l'output allo schermo, ad esempio nel contesto di un
loop.

Con due argomenti, y and x, mostra un grafico dei quantili empirici di y
contro quelli di x. I dati non vengono standardizzati.

Accesso dal menù:    /Variabile/Q-Q normale
Accesso dal menù:    /Visualizza/Grafico/Q-Q

# quantreg Estimation

Argomenti:  tau variabile-dipendente variabili-indipendenti 
Opzioni:    --robust (errori standard robusti)
            --intervals=level (calcola gli intervalli di confidenza)
            --vcv (mostra la matrice di covarianza)
Esempi:     quantreg 0.25 y 0 xlist
            quantreg 0.5 y 0 xlist --intervals
            quantreg 0.5 y 0 xlist --intervals=.95
            quantreg tauvec y 0 xlist --robust
            Vedi anche mrw_qr.inp

Regressione quantile. Il primo argomento, tau, è il quantile condizionale
per cui si desiderano le stime. Può essere un valore numerico o il nome di
una variabile scalare predefinita; il valore deve essere compreso
nell'intervallo da 0.01 a 0.99 (in alternativa, può essere indicato un
vettore di valori, si veda sotto per i dettagli). Gli argomenti dal secondo
in poi compongono un elenco di regressori sul modello di quello usato in
"ols".

Senza l'opzione --intervals, vengono mostrati gli errori standard per le
stime quantili; questi sono calcolati con la formula asintotica di Koenker e
Bassett (1978), ma se si usa l'opzione --robust, verrà usata la variante
robusta per l'eteroschedasticità di Koenker e Zhao (1994).

Se si usa l'opzione --intervals, gretl calcolerà gli intervalli di
confidenza invece degli errori standard. Questi intervalli sono calcolati
col metodo dell'inversione del rango e in generale sono asimmetrici rispetto
alle stime puntuali dei parametri. Se non si usa l'opzione "--robust", gli
intervalli sono calcolati nell'ipotesi di errori IID (Koenker, 1994), mentre
se viene indicata, sono calcolati con lo stimatore robusto sviluppato da
Koenker e Machado (1999).

Per impostazione predefinita vengono prodotti intervalli di confidenza al
90%. È possibile specificare un altro livello di confidenza (sotto forma di
frazione decimale), aggiungendolo all'opzione, come in --intervals=0.95.

Invece di indicare tau come uno scalare, è possibile usare un vettore,
indicando il nome di una matrice predefinita. In questo caso le stime
vengono eseguite per tutti i valori di tau, e i risultati mostrano la
sequenza delle stime quantili per ognuno dei regressori.

Accesso dal menù:    /Modello/Stima robusta/Regressione quantile

# quit Utilities

Esce dal programma, dando la possibilità di salvare i risultati della
sessione.

Accesso dal menù:    /File/Esci

# rename Dataset

Varianti:   rename numero-var
	nuovo-nome
            rename nome-var
	nuovo-nome

Modifica il nome di una variabile con numero identificativo numero-var o
nome nome-var in nuovo-nome. Il numero-var deve essere compreso tra 1 e il
numero di variabili nel dataset. Il nuovo nome deve essere lungo al massimo
15 caratteri, deve iniziare con una lettera e deve essere composto di sole
lettere, numeri e il carattere trattino basso.

Accesso dal menù:    /Variabile/Modifica attributi
Accesso alternativo: Menù pop-up nella finestra principale (selezione
      singola)

# reset Tests

Opzioni:    --quiet (non mostra la regressione ausiliaria)
            --squares-only (calcola il test coi soli quadrati)
            --cubes-only (calcola il test coi soli cubi)

Va eseguito dopo la stima di un modello via OLS. Esegue il test RESET di
Ramsey per la specificazione del modello (non-linearità), aggiungendo alla
regressione il quadrato e/o il cubo dei valori stimati (a meno che non siano
specificate le opzioni --squares-only o --cubes-only) e calcolando la
statistica F per l'ipotesi nulla che i coefficienti dei due termini aggiunti
siano pari a zero.

Vengono aggiunti sia i quadrati che i cubi, a meno che siano usate le
opzioni --squares-only o --cubes-only.

Accesso dal menù:    Finestra del modello, /Test/RESET - Ramsey

# restrict Tests

Impone un insieme di vincoli lineari sull'ultimo modello stimato o su un
sistema di equazioni definito in precedenza. La sintassi del comando è
leggermente diversa in ognuno dei due casi.

In entrambi i casi, l'insieme di vincoli deve essere racchiuso tra i comandi
"restrict" e "end restrict". Nel caso della singola equazione, i vincoli
sono applicati implicitamente all'ultimo modello e vengono valutati appena
viene terminato il comando "restrict". Nel caso del sistema, il comando
iniziale "restrict" deve essere seguito immediatamente dal nome di un
sistema di equazioni definito in precedenza (si veda "system"). I vincoli
vengono valutati nella successiva stima del sistema effettuata con il
comando "estimate".

Ogni vincolo nell'insieme va indicato sotto forma di equazione con una
combinazione lineare dei parametri al primo membro e un valore numerico al
secondo. Nel caso della singola equazione, i parametri sono indicati con la
sintassi b[i], dove i rappresenta la posizione nella lista dei regressori, a
partire da uno, oppure con b[variabile], dove variabile è il nome del
regressore in questione. estion. Nel caso del sistema, i parametri vengono
indicati con la sintassi b seguita da due numeri tra parentesi quadre. Il
primo numero rappresenta la posizione dell'equazione all'interno del
sistema, mentre il secondo indica la posizione nella lista dei regressori.
Ad esempio b[2,1] indica il primo parametro della seconda equazione, mentre
b[3,2] il secondo parametro della terza equazione.

I termini b nell'equazione che rappresenta un vincolo possono essere
prefissati da un moltiplicatore numerico, usando il segno * per indicare la
moltiplicazione, ad esempio 3.5*b[4].

Ecco un esempio di un insieme di vincoli per un modello stimato in
precedenza:

	restrict
	 b[1] = 0
	 b[2] - b[3] = 0
	 b[4] + 2*b[5] = 1
	end restrict

Ed ecco un esempio di un insieme di vincoli da applicare a un sistema (se il
nome del sistema non contiene spazi, è possibile tralasciare le
virgolette).

	restrict "Sistema 1"
	 b[1,1] = 0
	 b[1,2] - b[2,2] = 0
	 b[3,4] + 2*b[3,5] = 1
	end restrict

Nel caso dell'equazione singola, i vincoli sono valutati attraverso un test
F di Wald, usando la matrice di covarianza dei coefficienti del modello in
questione. In modalità predefinita vengono mostrate le stime dei
coefficienti vincolati; se si desidera solo la statistica test, basta
aggiungere l'opzione --quiet al comando restrict iniziale.

Nel caso del sistema, la statistica test dipende dallo stimatore scelto: un
test del rapporto di verosimiglianza nel caso di un sistema stimato con un
metodo di massima verosimiglianza, o un test F asintotico negli altri casi.

Accesso dal menù:    Modello, /Test/Vincoli lineari

# rmplot Graphs

Argomento:  nome-variabile 

Grafici Range-mean: questo comando crea un semplice grafico che aiuta a
capire se una serie storica y(t) ha varianza costante o no. L'intero
campione t=1,...,T viene diviso in piccoli sotto-campioni di dimensione
arbitraria k. Il primo sotto-campione è formato da y(1), ... ,y(k), il
secondo da y(k+1), ... , y(2k), e così via. Per ogni sotto-campione,
vengono calcolati la media e il campo di variazione (range: il valore
massimo meno quello minimo) e viene costruito un grafico con le medie
sull'asse orizzontale e i campi di variazione su quello verticale, in modo
che ogni sotto-campione sia rappresentato da un punto sul piano. Se la
varianza della serie è costante, ci si aspetta che il campo di variazione
del sotto-campione sia indipendente dalla media del sotto-campione; se i
punti si dispongono su una linea crescente, la varianza della serie cresce
al crescere della media, viceversa se i punti si dispongono su una linea
decrescente.

Oltre al grafico, gretl mostra anche le medie e i campi di variazione per
ogni sotto-campione, insieme al coefficiente di pendenza della regressione
OLS del campo di variazione sulla media e il p-value per l'ipotesi nulla che
la pendenza sia zero. Se il coefficiente di pendenza è significativo al
livello del 10 per cento, viene mostrata sul grafico la linea stimata della
regressione del campo di variazione sulla media.

Accesso dal menù:    /Variabile/Grafico range-mean

# run Programming

Argomento:  file-input 

Esegue i comandi nel file-input e restituisce il controllo al prompt
interattivo. Questo comando si intende usato con il programma a riga di
comando gretlcli, o con il "terminale di gretl" nel programma con
interfaccia grafica.

Si veda anche "include".

Accesso dal menù:    Icona Esegui nella finestra comandi

# runs Tests

Argomento:  nome-variabile 
Opzioni:    --difference (usa la differenza prima della variabile)
            --equal (i valori positivi e negativi sono equiprobabili)

Esegue il test non parametrico "delle successioni" per la casualità della
variabile specificata, dove le successioni sono definite come sequenze di
valori consecutivi positivi o negativi. Ad esempio, per testare la
casualità delle deviazioni dalla mediana per una variabile chiamata x1, con
una mediana diversa da zero, eseguire i comandi seguenti:

	genr signx1 = x1 - median(x1)
	runs signx1

Se si usa l'opzione --difference, la variabile viene differenziata prima
dell'analisi, quindi le successioni sono interpretabili come sequenze di
incrementi o decrementi consecutivi nel valore della variabile.

Se si usa l'opzione --equal, l'ipotesi nulla incorpora l'assunzione che i
valori positivi e negativi siano equiprobabili, altrimenti la statistica
test è invariante rispetto all'"equilibrio" del processo che genera la
sequenza, focalizzandosi solo sull'indipendenza.

Accesso dal menù:    /Strumenti/Test non parametrici

# scatters Graphs

Argomenti:  variabile-y ; lista-variabili-x  o lista-variabili-y ; variabile-x 
Opzione:    --with-lines (crea grafici lineari)
Esempi:     scatters 1 ; 2 3 4 5
            scatters 1 2 3 4 5 6 ; 7

Produce grafici della variabile-y rispetto ad ognuna delle variabili nella
lista-variabili-x, oppure di tutte le variabili nella lista-variabili-y
rispetto alla variabile-x. Il primo esempio visto sopra assegna la variabile
1 all'asse y e produce quattro grafici, il primo con la variabile 2
sull'asse x, il secondo con la variabile 3 sull'asse x, e così via. Il
secondo esempio rappresenta ognuna delle variabili da 1 a 6 rispetto alla
variabile 7 sull'asse x. Questi gruppi di grafici sono utili nell'analisi
esplorativa dei dati. È possibile creare fino a sei grafici alla volta,
eventuali variabili in sovrappiù saranno ignorate.

Per impostazione predefinita vengono prodotti dei classici grafici a
dispersione, ma se si usa l'opzione --with-lines vengono mostrate anche le
linee di collegamento tra i punti del grafico.

Accesso dal menù:    /Visualizza/Grafici multipli

# sdiff Transformations

Argomento:  lista-variabili 

Calcola la differenza stagionale di ogni variabile della lista-variabili e
salva il risultato in una nuova variabile con il prefisso sd_. Il comando è
disponibile solo per serie storiche stagionali.

Accesso dal menù:    /Aggiungi/Differenze stagionali

# set Programming

Argomenti:  variabile valore 
Esempi:     set svd on
            set csv_delim tab
            set horizon 10

Imposta i valori di vari parametri del programma. Il valore impostato rimane
in vigore per la durata della sessione di gretl, a meno di non essere
modificato da un ulteriore esecuzione del comando "set". I parametri che
possono essere impostati in questo modo sono elencati di seguito. Si noti
che le impostazioni di hac_lag, hc_version e hac_kernel sono usate quando
viene data l'opzione --robust a un comando di stima.

Un uso speciale di questo comando è "set stopwatch". In questo modo viene
avviata la misurazione del tempo della CPU, che viene fermata la prima volta
che viene usata la variabile accessoria $stopwatch, ad esempio assegnandola
a un'altra variabile, oppure stampandola. $stopwatch conterrà il numero di
secondi usati dalla CPU, dal momento in cui è stato dato il comando set
stopwatch.

Se il comando "set" è usato senza parametri, vengono mostrate le
impostazioni attuali per tutti i parametri rilevanti.

Le impostazioni disponibili sono raggruppate in sei categorie: interazione
col programma, metodi numerici, generazione di numeri casuali, stima
robusta, filtri e stima di modelli per serie storiche.

Interazione con il programma

Queste impostazioni servono per controllare vari aspetti del modo in cui
gretl interagisce con l'utente.

  csv_delim: comma (virgola, valore predefinito), space (spazio), o tab.
  Imposta il delimitatore di colonna usato nel salvataggio di dati su file
  in formato CSV.

  echo: off o on (valore predefinito). Sopprime o ripristina l'indicazione
  dei comandi eseguiti nell'output dei risultati.

  force_decpoint: on o off (valore predefinito). Forza gretl a usare il
  carattere punto come separatore decimale, in un ambiente in cui il
  separatore standard è un'altro carattere (tipicamente la virgola).

  halt_on_error: off o on (valore predefinito). Quando è attivo, se si
  verifica un errore all'interno di un loop, questo si interromperà. Se si
  usa il client a riga di comando, il programma terminerà.

  loop_maxiter: un valore intero non negativo. Imposta il numero massimo di
  iterazioni consentite prima che un loop di tipo while si fermi (si veda
  "loop"). Si noti che questa impostazione riguarda solo la variante while,
  visto che lo scopo è quello di interrompere possibili cicli infiniti. Il
  valore speciale 0 viene usato per rendere tali cicli potenzialmente
  infiniti, visto che non viene fatto alcun controllo sul numero di
  iterazioni. Usare con cautela.

  max_verbose: on o off (valore predefinito). Attiva l'output aggiuntivo per
  la funzione BFGSmax (si veda la Guida all'uso per i dettagli).

  messages: off o on (valore predefinito). Sopprime o ripristina
  l'indicazione dei messaggi informativi associati a vari comandi, ad
  esempio quando viene generata una nuova variabile o viene modificato
  l'intervallo del campione.

  debug: 1, 2 o 0 (valore predefinito). Da usare per le funzioni definite
  dall'utente. Impostare debug a 1 equivale a impostare messages in tutte
  queste funzioni; impostando la variabile a 2 ha l'effetto aggiuntivo di
  impostare max_verbose in tutte le funzioni.

  shell_ok: on o off (valore predefinito). Abilita l'esecuzione di programmi
  esterni da gretl attraverso la shell di sistema. Per motivi di sicurezza,
  la funzione è disabilitata per impostazione predefinita; inoltre è
  possibile abilitarla solo tramite l'interfaccia grafica
  (Strumenti/Preferenze/Generali). Una volta abilitata, l'impostazione
  rimarrà attiva per le successive sessioni, fino a che non sarà
  disabilitata esplicitamente.

  shelldir: percorso. Imposta la directory di lavoro attuale per i comandi
  shell.

  use_cwd: on o off (valore predefinito). Questa impostazione modifica il
  comportamento dei comandi "outfile" e "store", che scrivono su file
  esterni. Normalmente, il file verrà scritto nella directory dati
  predefinita dell'utente: se si imposta use_cwd a on, al contrario, il file
  verrà creato nella directory di lavoro da cui gretl è stato eseguito.

Metodi numerici

Queste impostazioni vengono usate per controllare gli algoritmi numerici
usati da gretl per la stima.

  bhhh_maxiter: un intero. Imposta il massimo numero di iterazioni per la
  routine BHHH, che è usata dal comando "arma". Se non viene raggiunta la
  convergenza dopo bhhh_maxiter, il programma segnala un errore. Il valore
  predefinito è 500.

  bhhh_toler: un valore a virgola mobile, oppure la stringa default. Viene
  usato dalla routine BHHH di gretl per controllare se viene raggiunta la
  convergenza. L'algoritmo di calcolo ferma le iterazioni non appena
  l'incremento nella log-verosimiglianza tra le iterazioni è minore di
  bhhh_toler. Il valore predefinito è 1.0E-06; questo valore può essere
  reimpostato usando la stringa default invece di un valore numerico.

  bfgs_maxiter: un valore intero. Rappresenta il massimo numero di
  iterazioni per la routine BFGS di gretl, usata da "mle", "gmm" e altri
  stimatori. Se non si raggiunge la convergenza nel numero specificato di
  iterazioni, il programma produce un messaggio di errore. Il valore
  predefinito dipende dal contesto, ma tipicamente è nell'ordine delle 500
  iterazioni.

  bfgs_toler: un valore in virgola mobile, o la stringa default. Viene usato
  nella routine BFGS di gretl per controllare se si è raggiunta la
  convergenza. L'algoritmo si ferma appena l'incremento relativo nella
  funzione obiettivo tra un'iterazione e l'altra è minore di bfgs_toler. Il
  valore predefinito è pari alla precisione della macchina elevata alla
  potenza 3/4; questo valore può essere re-impostato usando la stringa
  default invece di un valore numerico.

  initvals: una matrice pre-specificata. Permette di impostare manualmente
  le stime dei parametri ARMA. Per i dettagli, si veda la la guida all'uso
  di gretl.

  lbfgs: on o off (valore predefinito). Usa la versione a memoria limitata
  di BFGS, al posto dell'algoritmo standard. Può essere vantaggioso quando
  la funzione da massimizzare non è globalmente concava.

  nls_toler: un valore in virgola mobile (il valore predefinito è pari alla
  precisione della macchina elevata alla potenza 3/4). Imposta la tolleranza
  usata per stabilire se è stata raggiunta la convergenza nelle procedure
  iterative di stima con i minimi quadrati non lineari usate dal comando
  "nls".

  svd: on o off (valore predefinito). Usa la decomposizione SVD invece di
  quella di Cholesky o della QR nel calcolo delle stime OLS. Questa opzione
  si applica alla funzione mols e a vari altri calcoli eseguiti
  internamente, ma non al comando "ols".

  fcp: on o off (valore predefinito). Usa l'algoritmo di Fiorentini,
  Calzolari e Panattoni al posto del codice interno di gretl per calcolare
  le stime GARCH.

  gmm_maxiter: un intero, il numero massimo di iterazioni per il comando
  "gmm" con l'opzione --iterate. Il default è 250.

  nadarwat_trim: un intero, il parametro di taglio usato dalla funzione
  "nadarwat".

  fdjac_quality: un intero fra 0 e 2, corrsipondente all'algoritmo usato
  nella funzione "fdjac".

Generazione di numeri casuali

  seed: un intero senza segno. Imposta il seme per il generatore di numeri
  pseudo-casuali. Di solito il seme viene impostato a partire dall'ora di
  sistema, ma se si intende generare sequenze ripetibili di numeri casuali
  occorre impostare il seme manualmente.

Stima robusta

  bootrep: un intero. Imposta il numero di replicazioni per il comando
  "restrict" con l'opzione --bootstrap.

  garch_vcv: unset, hessian, im (matrice di informazione) , op (matrice dei
  prodotti esterni), qml (stimatore QML), bw (Bollerslev-Wooldridge).
  Specifica la variante da usare per stimare la matrice di covarianza dei
  coefficienti nei modelli GARCH. Se si usa unset (valore predefinito),
  viene usata l'Hessiana, a meno di usare l'opzione "robust" col comando
  garch, nel qual caso viene usato QML.

  arma_vcv: hessian (predefinito) o op (prodotto esterno). Specifica la
  variante da usare per calcolare la matrice di covarianza per i modelli
  ARIMA.

  force_hc: off (predefinito) o on. Lo stimatore HAC viene usato in modo
  predefinito con dati serie storiche e quando si usa l'opzione --robust di
  ols. Impostando invece force_hc a "on", si forza l'uso della matrice di
  covarianza coerente con l'eteroschedasticità (che non tiene conto
  dell'autocorrelazione).

  hac_lag: nw1 (valore predefinito), nw2, nw3, o un intero. Imposta il
  massimo valore di ritardo, o la larghezza di banda, p, usato nel calcolo
  degli errori standard HAC (Heteroskedasticity and Autocorrelation
  Consistent) con l'approccio Newey-West, per le serie storiche. nw1 e nw2
  rappresentano due varianti di calcolo automatico basate sulla dimensione
  del campione, T: per nw1, p = 0.75 * T^(1/3), e per nw2, p = 4 *
  (T/100)^(2/9). nw3 permette di selezionare la larghezza di banda basandosi
  sui dati. Si veda anche qs_bandwidth e hac_prewhiten.

  hac_kernel: bartlett (valore predefinito), parzen, o qs (Quadratic
  Spectral). Imposta il kernel, o struttura di pesi, usato nel calcolo degli
  errori standard HAC.

  hac_prewhiten: on o off (valore predefinito). Usa le procedure di
  "prewhitening" e "re-coloring" di Andrews-Monahan nel calcolo degli errori
  standard HAC. Questo comporta anche la selezione della larghezza di banda
  basata sui dati.

  hc_version: 0 (valore predefinito), 1, 2, 3 o 3a. Imposta la variante da
  usare nel calcolo degli errori standard HAC (Heteroskedasticity and
  Autocorrelation Consistent) con dati di tipo cross section. Le prime 4
  opzioni corrispondono alle HC0, HC1, HC2 e HC3 discusse da Davidson e
  MacKinnon nel capitolo 5 di Econometric Theory and Methods. HC0 produce
  quelli che di solito vengono chiamati "errori standard di White". La
  variante 3a è la procedura "jackknife" di MacKinnon-White.

  pcse: off (impostazione predefinita) o on. Di solito, quando si stima un
  modello con pooled OLS su dati panel usando l'opzione --robust, viene
  usato lo stimatore di Arellano per la matrice di covarianza. Se si imposta
  pcse a "on", verranno usati i Panel Corrected Standard Errors (PCSE) di
  Beck e Katz, che non tengono conto dell'autocorrelazione.

  qs_bandwidth: larghezza di banda per la stima HAC nel caso in cui si
  scelga il kernel "Quadratic Spectral" (a differenza dei kernel Bartlett e
  Parzen, la larghezza di banda QS non deve essere necessariamente un
  intero).

Filtri

  hp_lambda: auto (valore predefinito), o un valore numerico. Imposta il
  parametro di livellamento per il filtro di Hodrick-Prescott (si veda la
  funzione hpfilt sotto il comando genr). Il valore predefinito è 100 volte
  il quadrato della periodicità, ossia 100 per i dati annuali, 1600 per i
  dati trimestrali e così via.

  bkbp_limits: due interi, il secondo maggiore del primo (i valori
  predefiniti sono 8 e 32). Imposta i limiti di frequenza per il filtro
  passa-banda di Baxter-King (si veda la funzione bkfilt nel comando genr).

  bkbp_k: un intero (il valore predefinito è 8). Imposta l'ordine di
  approssimazione per il filtro passa-banda di Baxter-King.

Serie storiche

  horizon: un intero (il valore predefinito dipende dalla frequenza dei
  dati). Imposta l'orizzonte per le funzioni impulso-risposta e per la
  decomposizione della varianza nel contesto delle autoregressioni
  vettoriali.

  vecm_norm: phillips (valore predefinito), diag, first o none. Usato nel
  contesto della stima VECM, attraverso il comando "vecm" per identificare i
  vettori di cointegrazione. Si veda la Guida all'uso per i dettagli.

# setinfo Dataset

Argomenti:  nome-variabile -d descrizione -n nome-grafici 
Opzioni:    --discrete (marca la variabile come discreta)
            --continuous (marca la variabile come continua)
Esempi:     setinfo x1 -d "Descrizione di x1" -n "Nome nei grafici"
            setinfo z --discrete

Imposta fino a tre attributi di una variabile, nel modo seguente.

Usando l'opzione -d seguita da una stringa tra virgolette doppie, la stringa
verrà usata come etichetta descrittiva per la variabile indicata, che viene
mostrata dal comando "labels" e anche nella finestra principale del
programma.

Usando l'opzione -n seguita da una stringa tra virgolette doppie, la stringa
verrà usata nei grafici al posto del nome della variabile.

Usando una delle opzioni --discrete o --continuous, viene impostato il
carattere numerico della variabile. In modalità predefinita, tutte le
variabili sono considerate come continue; marcando una variabile come
discreta, essa viene trattata in modo speciale nei diagrammi di frequenza.

Accesso dal menù:    /Variabile/Modifica attributi
Accesso alternativo: Menù pop-up nella finestra principale

# setmiss Dataset

Argomenti:  valore [ lista-variabili ] 
Esempi:     setmiss -1
            setmiss 100 x2

Imposta il programma in modo da interpretare un dato valore numerico (il
primo parametro indicato al comando) come codice per i "valori mancanti" nei
dati importati. Se questo valore è l'unico parametro fornito, come nel
primo degli esempi precedenti, l'interpretazione verrà applicata a tutte le
serie del dataset. Se "valore" è seguito da una lista di variabili,
indicate per nome o numero, l'interpretazione è limitata solo alle
variabili specificate. Così, nel secondo esempio, il valore 100 è
interpretato come codice per "mancante", ma solo per la variabile x2.

Accesso dal menù:    /Campione/Imposta codice valori mancanti

# setobs Dataset

Varianti:   setobs periodicità oss-iniziale
            setobs variabile-unità variabile-periodi
Opzioni:    --cross-section (interpreta come cross section)
            --time-series (interpreta come serie storiche)
            --stacked-cross-section (interpreta come panel)
            --stacked-time-series (interpreta come panel)
            --panel-vars (usa variabili indice (si veda oltre))
Esempi:     setobs 4 1990:1 --time-series
            setobs 12 1978:03
            setobs 1 1 --cross-section
            setobs 20 1:1 --stacked-time-series
            setobs unita anno --panel-vars

Forza il programma a interpretare il dataset in uso secondo la struttura
specificata.

Nella prima forma del comando, la periodicità, che deve essere un valore
intero, nel caso delle serie storiche rappresenta la frequenza delle
osservazioni (1 = annuale; 4 = trimestrale; 12 = mensile; 52 = settimanale;
5, 6, o 7 = giornaliera; 24 = oraria). Nel caso di dati panel, la
periodicità è il numero di righe per ogni blocco di dati, ossia il numero
di unità cross section se i dati sono organizzati come pila di dati cross
section, o il numero di periodi se i dati sono organizzati come pila di
serie storiche. Nel caso di semplici dati cross section, la periodicità
dev'essere impostata a 1.

L'osservazione iniziale rappresenta la data iniziale nel caso delle serie
storiche. Gli anni possono essere indicati con due o quattro cifre, mentre i
sotto-periodi (ad esempio i trimestri o i mesi) devono essere separati dagli
anni con un carattere "due punti". Nel caso di dati panel, l'osservazione
iniziale va indicata come 1:1, mentre nel caso di dati cross section come 1.
L'osservazione iniziale per i dati giornalieri o settimanali va indicata
nella forma AA/MM/GG o AAAA/MM/GG (oppure semplicemente 1 per i dati non
datati).

La seconda forma del comando (che richiede l'uso dell'opzione --panel-vars)
può essere usata per imporre un'interpretazione panel dei dati, quando il
dataset contiene variabili che identificano in modo univoco le unità cross
section e i periodi. Il dataset verrà ordinato come pila di serie storiche,
per valori crescenti della variabile che rappresenta le unità,
variabile-unità.

Se non viene usata nessuna opzione per indicare esplicitamente la struttura
dei dati, il programma cercherà di riconoscerla automaticamente a partire
dalle informazioni indicate.

Accesso dal menù:    Dati/Struttura dataset

# shell Utilities

Argomento:  comando-shell 
Esempi:     ! ls -al
            ! notepad
            launch notepad

Un "!", o la parola chiave "launch", all'inizio di una riga di comando è
interpretato come passaggio all'interprete di comandi (shell) usato
dall'utente nel sistema operativo. In questo modo è possibile eseguire
comandi shell arbitrari dall'interno di gretl. Quando si usa "!", il comando
esterno viene eseguito in modalità sincrona, ossia gretl aspetta il termine
della sua esecuzione prima di procedere. Se invece si vuole avviare un altro
programma da dentro gretl senza aspettare che abbia completato la sua
esecuzione (modalità asincrona), occorre usare "launch".

Per motivi di sicurezza, questa funzionalità è disabilitata in modalità
predefinita. Per attivarla, occorre selezionare la casella "Abilita comandi
shell" nel menù File, Preferenze. In questo modo si renderanno disponibili
i comandi shell anche nella modalità a riga di comando di gretl (questo è
l'unico modo per farlo).

# smpl Dataset

Varianti:   smpl oss-iniziale oss-finale
            smpl +i -j
            smpl variabile-dummy --dummy
            smpl condizione --restrict
            smpl --no-missing [ lista-variabili ]
            smpl n --random
            smpl full
Esempi:     smpl 3 10
            smpl 1960:2 1982:4
            smpl +1 -1
            smpl x > 3000 --restrict
            smpl y > 3000 --restrict --replace
            smpl 100 --random

Reimposta l'intervallo del campione. Il nuovo intervallo può essere
definito in vari modi. Nel primo modo (corrispondente ai primi due esempi
precedenti) oss-iniziale e oss-finale devono essere coerenti con la
periodicità dei dati. Una delle due può essere sostituita da un punto e
virgola per lasciare intatto il valore attuale. Nel secondo modo, gli interi
i e j (che possono essere positivi o negativi e vanno indicati con il segno)
sono presi come spostamenti relativi ai punti iniziale e finale del campione
in uso. Nel terzo modo, variabile-dummy deve essere una variabile
indicatrice che assume solo valori 0 o 1 e il campione verrà ristretto alle
osservazioni per cui la variabile dummy vale 1. Il quarto modo, che usa
--restrict, limita il campione alle osservazioni che soddisfano la
condizione Booleana specificata secondo la sintassi del comando "genr".

Con la forma --no-missing, se viene specificata una lista-variabili, vengono
selezionate le osservazioni per cui tutte le variabili nella lista-variabili
hanno valori validi in corrispondenza dell'osservazione; altrimenti, se non
viene indicata alcuna lista-variabili, vengono selezionate le osservazioni
per cui tutte le variabili hanno valori validi (non mancanti).

Con la forma --random, viene estratto casualmente dal dataset il numero
indicato di osservazioni. Per essere in grado di replicare questa selezione,
occorre per prima cosa impostare il seme del generatore di numeri casuali
(si veda il comando "set").

La forma finale, smpl full, ripristina l'intervallo completo del campione.

Si noti che i vincoli sul campione di solito sono cumulativi: il valore di
riferimento di ogni comando smpl è il campione attuale, così che ogni
vincolo si aggiunge a quelli già impostati. Se si vuole che il comando
funzioni sostituendo i vincoli esistenti, occorre usare l'opzione --replace
alla fine del comando.

La variabile interna obs può essere usata con la forma --restrict di smpl
per escludere particolari osservazioni dal campione. Ad esempio,

	smpl obs!=4 --restrict

scarterà la quarta osservazione. Se le osservazioni sono identificate da
etichette,

        smpl obs!="USA" --restrict

scarterà l'osservazione a cui è associata l'etichetta "USA".

Per le forme --dummy, --restrict e --no-missing di smpl, occore tenere
presente che tutte le informazioni "strutturali" contenute nel file dei dati
(a proposito della struttura di serie storiche o di panel dei dati) vengono
perse. È possibile reimpostare la struttura originale con il comando
"setobs".

Si veda la la guida all'uso di gretl per ulteriori dettagli.

Accesso dal menù:    /Campione

# spearman Statistics

Argomenti:  x y 
Opzione:    --verbose (mostra i dati ordinati)

Mostra il coefficiente di correlazione di rango di Spearman per le variabili
x e y. Le variabili non devono essere state ordinate manualmente in
precedenza, se ne occupa la funzione.

L'ordinamento automatico è dal massimo al minimo (ossia il valore massimo
nei dati assume il rango 1). Se occorre invertire l'ordinamento, creare una
variabile che è il negativo della variabile originale, ad esempio:

	genr altx = -x
	spearman altx y

Accesso dal menù:    /Modello/Stima robusta/SPEARMAN - Correlazione di rango

# sprintf Printing

Argomenti:  var-stringa formato , argomenti 

Questo comando funziona esattamente come il comando "printf", stampando gli
argomenti nel modo controllato dalla stringa di formato, tranne per il fatto
che il risultato è scritto nella stringa specificata, var-stringa.

Per stampare la variabile stringa, basta usare il suo nome preceduto da @,
come in questo esempio:

	sprintf variabile "%g", x
	print "variabile ha il valore @variabile"

# square Transformations

Argomento:  lista-variabili 
Opzione:    --cross (genera anche i prodotti incrociati, oltre ai quadrati)

Genera nuove variabili che sono i quadrati delle variabili nella
lista-variabili (con anche i prodotti incrociati, se si usa l'opzione
--cross). Ad esempio, "square x y" genera sq_x = x al quadrato, sq_y = y al
quadrato e (opzionalmente) x_y = x per y. Se una particolare variabile è
una dummy, non ne viene fatto il quadrato, visto che si otterrebbe la stessa
variabile.

Accesso dal menù:    /Aggiungi/Quadrati delle variabili selezionate

# store Dataset

Argomenti:  file-dati [ lista-variabili ] 
Opzioni:    --csv (usa il formato CSV)
            --omit-obs (si veda oltre, a proposito del formato CSV)
            --gnu-octave (usa il formato GNU Octave)
            --gnu-R (usa il formato GNU R)
            --gzipped (comprime con gzip)
            --jmulti (usa il formato ASCII di JMulti)
            --dat (usa il formato ASCII di PcGive)
            --database (usa il formato database di gretl)
            --overwrite (cfr oltre, a proposito del formato dei database)

Salva l'intero dataset, o un sottoinsieme delle variabili se è stata
indicata una lista-variabili, nel file indicato con file-dati.

L'impostazione predefinita è di salvare i dati nel formato "interno" di
gretl, ma le opzioni del comando permettono di usare formati alternativi. I
dati CSV (Comma-Separated Values, dati separati da virgole) possono essere
letti dai programmi di foglio elettronico e possono essere modificati con un
editor di testi. I formati Octave, R e PcGive sono destinati ad essere usati
con i rispettivi programmi. La compressione con gzip può essere utile per
grandi dataset. Si veda la la guida all'uso di gretl per i dettagli sui vari
formati.

L'opzione --omit-obs è applicabile solo quando si salvano dati in formato
CSV. In modalità predefinita, se i dati sono serie storiche o panel, o se
il dataset include marcatori per osservazioni specifiche, il file CSV
comprende una prima colonna che identifica le osservazioni (ad esempio per
data). Se si usa --omit-obs, questa colonna verrà omessa e verranno salvati
solo i dati effettivi.

Si noti che le variabili scalari non saranno salvate automaticamente: per
salvarle occorre includerle esplicitamente nella lista-variabili.

L'opzione di salvataggio in formato database di gretl è indicata se occorre
costruire dei grandi dataset di serie, magari con frequenze diverse e
diversi intervalli di osservazioni. Al momento questa opzione è disponibile
solo per dati annuali, trimestrali o mensili. Salvando su un file che esiste
già, il comportamento predefinito è quello di accodare le nuove serie al
contenuto del database preesistente. In questo contesto, se una o più delle
variabili da salvare hanno lo stesso nome di una delle variabili già
presenti nel database si otterrà un messaggio di errore. L'opzione
--overwrite permette invece di sovrascrivere eventuali variabili del dataset
che hanno lo stesso nome delle nuove variabili, in modo che queste ultime
rimpiazzino le variabili preesistenti.

Accesso dal menù:    /File/Salva dati; /File/Esporta dati

# summary Statistics

Argomento:  summary [ lista ]
            summary --matrix=nomematrice
Opzioni:    --simple (solo statistiche di base)
            --weight=wvar (variabile peso)
            --by=byvar (vedi sotto)

Nella prima forma, mostra le statistiche descrittive per le variabili nella
lista-variabili, o per tutte le variabili nel dataset, se non si indica una
lista-variabili. L'output comprende media, scarto quadratico medio,
coefficiente di variazione (= scarto quadratico medio / media), mediana,
minimo, massimo, coefficiente di asimmetria, curtosi in eccesso. Dando
l'opzione --simple, si avranno soltanto media, minimo, massimo e scarto
quadratico medio.

L'opzione --by (dove il parametro byvar dev'essere il nome di una variabile
discreta), provoca la stampa delle statistiche per sottocampioni definiti
dai diversi valori di byvar. Ad esempio, se byvar è una variabile binaria
(dummy), verranno riportate separatamente le statistiche relative ai
sottocampioni definitia dai due casi byvar = 0 e byvar = 1. Nota: al
momento, questa opzione è incompatibile con l'altra opzione --weight.

Accesso dal menù:    /Visualizza/Statistiche descrittive
Accesso alternativo: Menù pop-up nella finestra principale

# system Estimation

Varianti:   system method=stimatore
            nome-sistema <- system
Esempi:     "Klein Model 1" <- system
            system method=sur
            system method=3sls
            Vedi anche klein.inp, kmenta.inp, greene14_2.inp

Inizia un sistema di equazioni. Esistono due versioni del comando, a seconda
che si voglia salvare il sistema per poterlo stimare in più modi diversi,
oppure stimare il sistema una volta sola.

Per salvare il sistema occorre dargli un nome, come nel primo esempio
proposto (se il nome contiene spazi, occorre racchiuderlo tra virgolette).
In questo caso, è possibile stimare il sistema con il comando "estimate".
Una volta che il sistema è stato salvato, è possibile imporre dei vincoli
su di esso (compresi vincoli incrociati tra equazioni) usando il comando
"restrict".

In alternativa, è possibile indicare uno stimatore per il sistema usando
method= seguito da una stringa che identifica uno degli stimatori
supportati: "ols" (ordinary least squares - minimi quadrati ordinari),
"tsls" (two-stage least squares - minimi quadrati a due stadi), "sur"
(seemingly unrelated regressions - regressioni apparentemente non
collegate), "3sls" (three-stage least squares - minimi quadrati a tre
stadi), "fiml" (full information maximum likelihood - massima
verosimiglianza con informazione completa) o "liml" (limited information
maximum likelihood - massima verosimiglianza con informazione limitata). In
questo caso, il sistema viene stimato appena completata la sua definizione.

Un sistema di equazioni termina con la riga "end system". All'interno del
sistema possono essere definiti i quattro tipi di istruzioni seguenti.

  "equation": specifica un'equazione del sistema. Occorre indicarne almeno
  due.

  "instr": per i sistemi da stimare con i minimi quadrati a tre stadi,
  indica la lista degli strumenti (indicati dal nome o dal numero della
  variabile). In alternativa, è possibile fornire questa informazione nella
  riga "equation" usando la stessa sintassi accettata dal comando "tsls".

  "endog": per i sistemi di equazioni simultanee, indica la lista delle
  variabili endogene. È indicato principalmente per la stima FIML, ma può
  essere usato anche nella stima minimi quadrati a tre stadi al posto
  dell'istruzione "instr": in questo modo tutte le variabili non
  identificate come endogene verranno usate come strumenti.

  "identity": per la stima FIML, un'identità che collega due o più
  variabili del sistema. Questo tipo di istruzione è ignorata se viene
  usato uno stimatore diverso da FIML.

Dopo la stima eseguita con i comandi "system" o "estimate" è possibile
recuperare informazioni aggiuntive dalle seguenti variabili accessorie:

  $uhat: la matrice dei residui, una colonna per equazione.

  $yhat: la matrice dei valori stimati, una colonna per equazione.

  $coeff: il vettore colonna dei coefficienti (tutti i coefficienti della
  prima equazione, seguiti da quelli della seconda equazione, e così via).

  $vcv: la matrice di covarianza dei coefficienti. Se il vettore $coeff ha k
  elementi, questa matrice ha dimensione k per k.

  $sigma: la matrice di covarianza dei residui incrociata tra equazioni.

  $sysGamma, $sysA e $sysB: matrici dei coefficienti in forma strutturale
  (si veda oltre).

Se si vuole salvare i residui o i valori stimati per una specifica equazione
come serie di dati, basta selezionare la colonna dalla matrice $uhat o $yhat
e assegnarla a una serie, come in

	series uh1 = $uhat[,1]

Le matrici in forma strutturale corrispondono alla seguente rappresentazione
di un modello ad equazioni simultanee:

  Gamma y(t) = A y(t-1) + B x(t) + e(t)

Se ci sono n variabili endogene e k variabili esogene, Gamma è una matrice
n x n e B è n x k. Se il sistema non contiene ritardi delle variabili
endogene, la matrice A non è presente. Se il massimo ritardo di un
regressore endogeno è p, la matrice A è n x np.

Accesso dal menù:    /Modello/Equazioni simultanee

# tabprint Printing

Argomento:  [ -f nomefile ] 
Opzioni:    --rtf (Produce RTF invece di LaTeX)
            --complete (Crea un documento completo)
            --format="f1|f2|f3|f4" (Specifica un formato personalizzato)

Va eseguito dopo la stima di un modello. Stampa il modello stimato sotto
forma di tabella, in formato LaTeX, o, se viene usata l'opzione --rtf, in
formato RTF. Se viene specificato un nome di file dopo l'opzione -f,
l'output viene scritto nel file, altrimenti viene scritto in un file col
nome model_N.tex (o model_N.rtf), dove N è il numero dei modelli stimati
finora nella sessione in corso.

Le opzioni illustrate di seguito sono disponibili solo per il formato LaTeX.

Usando l'opzione --complete, il file LaTeX è un documento completo, pronto
per essere processato; altrimenti il file va incluso in un documento.

Se si intende modificare lo stile del formato tabulare, è possibile
specificare un formato personalizzato usando l'opzione --format, seguita da
una stringa di formato. La stringa di formato va inclusa tra virgolette
doppie e deve essere unita all'opzione con un segno di uguale. La
composizione della stringa di formato è la seguente: ci sono quattro campi,
che rappresentano il coefficiente, l'errore standard, il rapporto t e il
p-value. Questi campi vanno separati usando barre verticali e possono
contenere una specificazione di formato per valori numerici nello stile
della funzione printf, oppure possono essere lasciati in bianco, in modo da
sopprimere la visualizzazione del campo nella rispettiva colonna dela
tabella (con l'unico vincolo che non è possibile lasciare in bianco tutti i
campi). Ecco alcuni esempi:

	--format="%.4f|%.4f|%.4f|%.4f"
	--format="%.4f|%.4f|%.3f|"
	--format="%.5f|%.4f||%.4f"
	--format="%.8g|%.8g||%.4f"

La prima specificazione stampa i valori di tutte le colonne usando 4 cifre
decimali. La seconda sopprime il p-value e mostra il rapporto t con 3 cifre
decimali. La terza omette il rapporto t, mentre l'ultima omette il rapporto
t e mostra sia il coefficiente che l'errore standard con 8 cifre
significative.

Una volta che si imposta un formato in questo modo, esso viene ricordato e
usato per tutta la sessione di lavoro. Per tornare ad usare il formato
predefinito, basta usare la parola chiave --format=default.

Accesso dal menù:    Finestra del modello, /LaTeX

# textplot Graphs

Argomento:  lista-variabili 
Opzioni:    --time-series (disegna per osservazione)
            --one-scale (forza l'uso di un'unica scala)
            --tall (usa 40 linee)

Gafica ASCII nuda e cruda. Senza l'opzione --time-series, varlist deve
contenere almeno due serie, l'ultima delle quali va sull'asse delle ascisse,
e verrà prodotto un diagramma a dispersione. In questo caso, si può usare
l'opzione --tall per produrre un grafico in cui l'asse y è rappresentato da
40 righe di caratteri (il default è 20 righe).

Con l'opzione --time-series, viene prodotto un grafico per osservazione. In
questo caso, l'opzione --one-scale forza l'uso di una scala singola;
altrimenti, se varlist contiene più di una serie i dati potrebbero essere
riscalati. Ogni riga rappresenta un'osservazione, con i dati disegnati
orizzontalmente.

Vedi anche "gnuplot".

# tobit Estimation

Argomenti:  variabile-dipendente variabili-indipendenti 
Opzioni:    --vcv (mostra la matrice di covarianza)
            --verbose (mostra i dettagli delle iterazioni)

Stima un modello Tobit. Il modello può essere appropriato quando la
variabile dipendente è "censurata". Ad esempio, vengono osservati valori
positivi o nulli della spesa dei consumatori per beni durevoli, ma non
valori negativi; tuttavia le decisioni di spesa possono essere pensate come
derivanti da una propensione al consumo, sottostante e non osservata, che
può anche essere negativa in alcuni casi. Per i dettagli si veda il
capitolo 20 di Econometric Analysis di Greene.

Accesso dal menù:    /Modello/Modelli non lineari/Tobit

# tsls Estimation

Argomenti:  variabile-dipendente variabili-indipendenti ; strumenti 
Opzioni:    --vcv (mostra la matrice di covarianza)
            --robust (errori standard robusti)
            --liml (usa massima verosimiglianza a informazione limitata)
            --gmm (usa il metodo generalizzato dei momenti)
Esempio:    tsls y1 0 y2 y3 x1 x2 ; 0 x1 x2 x3 x4 x5 x6

Calcola le stime con variabili strumentali, per impostazione predefinita
usando i minimi quadrati a due stadi (TSLS), ma è possibile scegliere altre
opzioni. Occorre specificare la variabile-dipendente, la lista di
variabili-indipendenti (che si intende includere alcuni regressori
endogeni), e infine gli strumenti, la lista completa delle variabili esogene
e predeterminate. Se la lista degli strumenti non è lunga almeno quanto
quella delle variabili-indipendenti, il modello non è identificato.

Nell'esempio precedente, le y sono le variabili endogene e le x sono le
variabili esogene e predeterminate. Si noti che eventuali regressori esogeni
devono essere inclusi in entrambe le liste.

L'output delle stime TSLS comprende il test di Hausman e, se il modello è
sovra-identificato, il test di Sargan per la sovra-identificazione. Nel test
di Hausman, l'ipotesi nulla è che le stime OLS siano consistenti, o in
altre parole che non sia richiesta la stima per mezzo di variabili
strumentali. Un modello di questo tipo è sovra-identificato se ci sono più
strumenti di quelli strettamente necessari. Il test di Sargan è basato su
una regressione ausiliaria dei residui del modello minimi quadrati a due
stadi sull'intera lista degli strumenti. L'ipotesi nulla è che tutti gli
strumenti siano validi, cosa di cui si dovrebbe dubitare se la regressione
ausiliaria ha un significativo potere esplicativo. Davidson e MacKinnon
(2004, capitolo 8) forniscono una buona spiegazione di entrambi i test.

Il valore R-quadro mostrato i modelli stimati con i minimi quadrati a due
stadi è il quadrato della correlazione tra la variabile dipendente e i
valori stimati.

In alternativa al metodo TSLS, il modello può essere stimato usando la
massima verosimiglianza a informazione limitata (opzione --liml) o il metodo
generalizzato dei momenti (opzione --gmm). Si noti che se il modello è
esattamente identificato, questi metodi dovrebbero produrre gli stessi
risultati del metodo TSLS, ma se il modello è sovraidentificato, i
risultati saranno in genere diversi.

Se si usa la stima GMM, è possibile usare le seguenti opzioni aggiuntive:

  --two-step: esegue la stima GMM in due passi, invece che in un passo solo.

  --iterate: itera il GMM fino alla convergenza.

  --weights=Pesi: specifica una matrice quadrata di pesi da usare nel
  calcolo della funzione criterio del GMM. La dimensione di questa matrice
  deve essere pari al numero di strumenti. L'impostazione predefinita
  consiste nell'usare una matrice identità di dimensione opportuna.

Accesso dal menù:    /Modello/TSLS - Minimi quadrati a due stadi

# var Estimation

Argomenti:  ordine lista-variabili [ ; lista-esogene ] 
Opzioni:    --nc (non include una costante)
            --trend (include un trend)
            --seasonals (include variabili dummy stagionali)
            --robust (errori standard robusti)
            --impulse-responses (mostra impulso-risposta)
            --variance-decomp (mostra decomposizioni della varianza della previsione)
            --lagselect (mostra i criteri di informazione per la selezione dei ritardi)
Esempi:     var 4 x1 x2 x3 ; time mydum
            var 4 x1 x2 x3 --seasonals
            var 12 x1 x2 x3 --lagselect

Imposta e stima (usando OLS) un'autoregressione vettoriale (VAR). Il primo
argomento specifica l'ordine di ritardo (o il massimo ordine di ritardi se
è stata usata l'opzione --lagselect). L'ordine può essere indicato
numericamente o con il nome di una variabile scalare preesistente. Quindi
segue l'impostazione della prima equazione. Non occorre includere i ritardi
tra gli elementi della lista-variabili: verranno aggiunti automaticamente.
Il punto e virgola separa le variabili stocastiche, per cui verrà incluso
un numero di ritardi pari a ordine, dai termini deterministici o esogeni
presenti nella lista-esogene. Si noti che viene inclusa automaticamente una
costante, a meno che non si usi l'opzione --nc; inoltre è possibile
aggiungere un trend con l'opzione --trend e variabili dummy stagionali con
l'opzione --seasonals.

Viene calcolata una regressione separata per ognuna delle variabili nella
lista-variabili. Il risultato di ogni equazione include i test F per i
vincoli di uguaglianza a zero su tutti i ritardi delle variabili, un test F
per la significatività del ritardo massimo e, se è stata usata l'opzione
--impulse-responses, la scomposizione della varianza della previsione e le
funzioni di impulso-risposta.

Le decomposizioni della varianza della previsione e le funzioni di
impulso-risposta sono basate sulla decomposizione di Cholesky della matrice
di covarianza contemporanea, e in questo contesto l'ordine in cui vengono
date le variabili stocastiche conta. La prima variabile nella lista viene
considerata come la "più esogena" all'interno del periodo. L'orizzonte per
le decomposizioni della varianza e le funzioni di impulso-risposta può
essere impostato usando il comando "set".

Se si usa l'opzione --lagselect, il primo parametro del comando var viene
interpretato come il massimo ordine di ritardo. In questo caso, il comando
non produce il solito risultato della stima del VAR, ma una tabella che
mostra i valori dei criteri di informazione di Akaike (AIC), Schwartz (BIC)
e Hannan-Quinn (HQC) calcolati per VAR dall'ordine 1 fino all'ordine massimo
indicato, in modo da aiutare nella scelta dell'ordine di ritardo ottimale.

Accesso dal menù:    /Modello/Serie storiche/VAR - Autoregressione vettoriale

# varlist Dataset

Mostra un elenco delle variabili disponibili. "list" e "ls" sono sinonimi.

# vartest Tests

Argomenti:  var1 var2 

Calcola la statistica F per l'ipotesi nulla che le varianze della
popolazione per le variabili var1 e var2 siano uguali e mostra il p-value.

Accesso dal menù:    /Modello/Modelli bivariati/Differenza delle varianze

# vecm Estimation

Argomenti:  ordine rango lista-y [ ; lista-x ] [ ; lista-rx ] 
Opzioni:    --nc (senza costante)
            --rc (costante vincolata)
            --crt (costante e trend vincolato)
            --ct (costante e trend non vincolato)
            --seasonals (include dummy stagionali centrate)
            --impulse-responses (mostra impulso-risposta)
            --variance-decomp (mostra decomposizioni della varianza delle previsioni)
Esempi:     vecm 4 1 Y1 Y2 Y3
            vecm 3 2 Y1 Y2 Y3 --rc
            vecm 3 2 Y1 Y2 Y3 ; X1 --rc
            Vedi anche denmark.inp, hamilton.inp

Un VECM è un tipo di autoregressione vettoriale, o VAR (si veda "var"),
applicabile quando le variabili del modello sono individualmente integrate
di ordine 1 (ossia, sono "random walk" con o senza deriva), ma esibiscono
cointegrazione. Questo comando è strettamente connesso al test di Johansen
per la cointegrazione (si veda "coint2").

Il parametro ordine rappresenta l'ordine di ritardo del sistema VAR. Il
numero di ritardi nel VECM (dove la variabile dipendente è data da una
differenza prima) è pari a ordine meno uno.

Il parametro rango rappresenta il rango di cointegrazione, o in altre parole
il numero di vettori di cointegrazione. Questo deve essere maggiore di zero
e minore o uguale (in genere minore) al numero di variabili endogene
contenute nella lista-y.

La lista-y rappresenta l'elenco delle variabili endogene, nei livelli.
L'inclusione di trend deterministici nel modello è controllata dalle
opzioni del comando. Se non si indica alcuna opzione, viene inclusa una
"costante non vincolata", che permette la presenza di un'intercetta diversa
da zero nelle relazioni di cointegrazione e di un trend nei livelli delle
variabili endogene. Nella letteratura originata dal lavoro di Johansen (si
veda ad esempio il suo libro del 1995), si fa riferimento a questo come al
"caso 3". Le prime quattro opzioni mostrate sopra, che sono mutualmente
esclusive, producono rispettivamente i casi 1, 2, 4 e 5. Il significato di
questi casi e i criteri per scegliere tra di essi sono spiegati nella la
guida all'uso di gretl.

Le liste opzionali lista-x e lista-rx permettono di specificare insiemi di
variabili esogene che entrano nel modello in modo non vincolato (lista-x) o
in modo vincolato allo spazio di cointegrazione (lista-rx). Queste liste
vanno separate dalla lista-y (e tra di loro) da caratteri punto e virgola.

L'opzione --seasonals, che può accompagnare una qualsiasi delle altre
opzioni, specifica l'inclusione di un gruppo di variabili dummy stagionali
centrate. Questa opzione è disponibile solo per dati trimestrali o mensili.

Il primo degli esempi mostrati sopra specifica un VECM con ordine di ritardo
pari a 4 e un unico vettore di cointegrazione. Le variabili endogene sono
Y1, Y2 e Y3. Il secondo esempio usa le stesse variabili ma specifica un
ritardo di ordine 3 e due vettori di cointegrazione, oltre a specificare una
"costante vincolata", che è appropriata se i vettori di cointegrazione
possono avere un'intercetta diversa da zero, ma le variabili Y non hanno
trend.

Accesso dal menù:    /Modello/Serie storiche/VECM

# vif Tests

Deve seguire la stima di un modello che includa almeno due variabili
indipendenti. Calcola e mostra i fattori di inflazione della varianza
(Variance Inflation Factors - VIF) per i regressori. Il VIF per il
regressore j è definito come

  1/(1 - Rj^2)

dove R_j è il coefficiente di correlazione multipla tra il regressore j e
gli altri regressori. Il fattore ha un valore minimo di 1.0 quando la
variabile in questione è ortogonale alle altre variabili indipendenti.
Neter, Wasserman e Kutner (1990) suggeriscono di usare il VIF maggiore come
test diagnostico per la collinearità; un valore superiore a 10 è in genere
considerato indice di un grado di collinearità problematico.

Accesso dal menù:    Finestra del modello, /Test/collinearità

# wls Estimation

Argomenti:  variabile-pesi variabile-dipendente variabili-indipendenti 
Opzioni:    --vcv (mostra la matrice di covarianza)
            --robust (errori standard robusti)
            --quiet (non mostra i risultati)

Calcola stime con minimi quadrati ponderati (WLS - Weighted Least Squares),
prendendo i pesi da variabile-pesi. In pratica, detta w la radice quadrata
positiva della variabile-pesi, viene calcolata una regressione OLS di w *
variabile-dipendente rispetto a w * variabili-indipendenti. L'R-quadro,
comunque, è calcolato in un modo speciale, ossia come

  R^2 = 1 - ESS / WTSS

dove ESS è la somma dei quadrati degli errori (somma dei quadrati dei
residui) dalla regressione ponderata, mentre WTSS denota la "somma totale
ponderata dei quadrati", che è pari alla somma dei quadrati dei residui
della regressione della variabile dipendente ponderata sulla sola costante
ponderata.

Se variabile-pesi è una variabile dummy, la stima WLS equivale a eliminare
tutte le osservazioni per cui essa vale zero.

Accesso dal menù:    /Modello/Altri modelli lineari/WLS - Minimi quadrati ponderati

# xcorrgm Statistics

Argomenti:  var1 var2 [ maxlag ] 
Esempio:    xcorrgm x y 12

Mostra il correlogramma incrociato per le variabili var1 e var2, che possono
essere specificate per nome o per numero. I valori sono i coefficienti di
correlazione campionari tra il valore presente di var1 e i valori ritardati
e anticipati di var2.

Se si indica un valore maxlag, la lunghezza del correlogramma è limitata al
numero di ritardi e anticipi indicati, altrimenti è determinata
automaticamente in funzione della frequenza dei dati e del numero di
osservazioni.

Accesso dal menù:    /Visualizza/Correlogramma
Accesso alternativo: Menù pop-up nella finestra principale (selezione multipla)

# xtab Statistics

Argomenti:  lista-y [ ; lista-x ] 
Opzioni:    --row (mostra le percentuali per riga)
            --column (mostra le percentuali per colonna)
            --zeros (mostra i valori pari a zero)

Mostra la tabella di contingenza, o la tabulazione incrociata, tra ogni
combinazione delle variabili della lista-y; se si indica anche una seconda
lista, lista-x, ogni variabile della lista-y viene tabulata (per riga)
rispetto ad ogni variabile della lista-x (per colonna). Le variabili in
queste liste possono essere referenziate per nome o per numero, e devono
essere state marcate come discrete.

Per impostazione predefinita le celle indicano la frequenza assoluta. Le
opzioni --row e --column (che sono mutualmente esclusive) sostituiscono la
frequenza assoluta con le frequenze in percentuale relativamente a ciascuna
riga o colonna. Le celle con valore di frequenza nullo sono lasciate vuote,
a meno che non venga usata l'opzione --zeros, che mostra esplicitamente i
valori pari a zero; questa opzione può essere comoda se occorre importare
la tabella in un altro programma, come un foglio di calcolo.

Il test chi quadro di Pearson per l'indipendenza viene mostrato se la
frequenza attesa nell'ipotesi di indipendenza è pari almeno a 1.0e-7 per
tutte le celle. Una regola approssimativa usata spesso nel giudicare la
validità di questa statistica richiede che la frequenza attesa sia
superiore a 5 per almeno l'80 per cento delle celle; se questa condizione
non viene soddisfatta viene mostrato un messaggio di avvertimento.

Se la tabella di contingenza è 2 x 2, viene calcolato il test esatto di
Fisher per l'indipendenza. Si noti che questo test si basa sull'ipotesi che
i totali per riga e colonna siano fissi; questo può essere appropriato o
meno a seconda di come sono stati generati i dati. Il p-value sinistro va
usato nel caso in cui l'ipotesi alternativa a quella di indipendenza sia
quella dell'associazione negativa (ossia i valori tendono ad accumularsi
nelle celle che non appartengono alla diagonale della tabella), mentre il
p-value destro va usato nell'ipotesi alternativa di associazione positiva.
Il p-value a due code di questo test è calcolato seguendo il metodo (b)
descritto in Agresti (1992, capitolo 2.1): esso è la somma delle
probabilità di tutte le possibili tabelle che hanno i totali per riga e per
colonna pari a quelli della tabella data e che hanno una probabilità minore
o uguale a quella della tabella data.

