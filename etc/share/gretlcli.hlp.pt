headings 10
Tests 22
add
adf
chow
coeffsum
coint
coint2
cusum
difftest
hausman
kpss
leverage
levinlin
meantest
modtest
normtest
omit
qlrtest
reset
restrict
runs
vartest
vif
Graphs 7
boxplot
gnuplot
graphpg
qqplot
rmplot
scatters
textplot
Statistics 13
anova
corr
corrgm
fractint
freq
hurst
mahal
pca
pergm
spearman
summary
xcorrgm
xtab
Dataset 18
append
data
dataset
delete
genr
info
join
labels
markers
nulldata
open
rename
setinfo
setmiss
setobs
smpl
store
varlist
Estimation 34
ar
ar1
arbond
arch
arima
biprobit
dpanel
duration
equation
estimate
garch
gmm
heckit
hsk
intreg
kalman
lad
logistic
logit
mle
mpols
negbin
nls
ols
panel
poisson
probit
quantreg
system
tobit
tsls
var
vecm
wls
Programming 17
break
catch
clear
debug
elif
else
end
endif
endloop
foreign
function
if
include
loop
makepkg
run
set
Transformations 9
diff
discrete
dummify
lags
ldiff
logs
orthdev
sdiff
square
Printing 7
eqnprint
modprint
outfile
print
printf
sprintf
tabprint
Prediction 1
fcast
Utilities 5
help
modeltab
pvalue
quit
shell

# add Tests

Argument:   lista-de-variáveis 
Options:    --lm (fazer um teste LM, apenas para OLS (Ordinary Least Squares))
            --quiet (mostrar apenas o resultado básico do teste)
            --silent (não mostrar nada)
            --vcv (mostrar matriz de covariância para o modelo aumentado)
            --both (apenas para estimação IV, ver abaixo)
Examples:   add 5 7 9
            add xx yy zz --quiet

Tem que ser invocado após um comando de estimação. As variáveis na
lista-de-variáveis são acrescentadas ao modelo anterior e o novo modelo é
estimado. Os resultados do teste de significância conjunta podem ser
obtidos usando os acessores $test e $pvalue.

Por omissão é efetuada uma estimação da versão aumentada do modelo
original, com a inclusão das variáveis da lista-de-variáveis. O teste é
um teste de Wald sobre o modelo aumentado, que substitui o original como o
"modelo corrente" para o propósito de, por exemplo, obter os resíduos como
$uhat ou realizar mais testes.

Em alternativa, usando a opção --lm (apenas no caso de modelos estimados
por OLS), será efetuado um teste LM. Uma regressão auxiliar é executada,
na qual a variável dependente é o resíduo do modelo anterior e as
variáveis independentes são as mesmas do modelo anterior mais as da
lista-de-variáveis. De acordo com a hipótese nula de que as variáveis
acrescentadas não acrescentam poder explicativo, a dimensão da amostra
vezes o R quadrado não-ajustado desta regressão tem uma distribuição
Qui-quadrado com um grau de liberdade igual ao número de regressores
adicionado. Neste caso o modelo original não é alterado.

A opção --both é específico para o método dos mínimos quadrados de
duas fases: indica que as novas variáveis devem ser acrescentadas tanto à
lista de regressores como à lista de instrumentos, por omissão apenas
serão acrescentadas à lista de regressores.

Menu path:    Janela do modelo, /Testes/Acrescentar variáveis

# adf Tests

Arguments:  ordem lista-de-variáveis 
Options:    --nc (teste sem constante)
            --c (apenas com constante)
            --ct (com constante e tendência)
            --ctt (com constante, tendência e quadrado da tendência)
            --seasonals (incluir variáveis sazonais auxiliares)
            --gls (atenuar média ou tendência usando GLS)
            --verbose (mostrar resultados da regressão)
            --quiet (não mostrar resultados)
            --difference (usar a primeira diferença da variável)
            --test-down[=critério] (ordem de desfasamento automática)
Examples:   adf 0 y
            adf 2 y --nc --c --ct
            adf 12 y --c --test-down
            See also jgm-1996.inp

Determina estatísticas para um conjunto de testes de Dickey-Fuller sobre a
variável especificada, com a hipótese nula de que a variável tem uma raiz
unitária. (Mas se a opção de diferenciação tiver sido dada, a primeira
diferença da variável é obtida, e a discussão abaixo deve ser
interpretada como sendo referente à variável transformada.)

Por omissão, são apresentadas três variantes do teste: uma baseada na
regressão contendo uma constante, uma usando uma constante e uma tendência
linear, e uma usando uma constante e uma tendência quadrática. Você pode
controlar as variantes que são apresentadas ao especificar uma ou mais
opções.

Em todos os casos a variável dependente é a primeira diferença da
variável especificada, y, e a variável independente chave é o primeiro
desfasamento de y. O modelo é construido de modo a que o coeficiente do
desfasamento de y iguale 1 menos a raiz em questão. Por exemplo, o modelo
com uma constante pode ser escrito como

  (1 - L)y(t) = b0 + (1-a)y(t-1) + e(t)

Se a ordem de desfasamento, k, é maior que 0, então k desfasamentos da
variável dependente são incluidos no lado direito das regressões de
teste, sujeitos à seguinte qualificação. Se a opção --test-down foi
dada, k é considerada como sendo o desfasamento máximo e a ordem de
desfasamento efectivamente usada é obtida testando para baixo, de acordo
com o seguinte algoritmo:

1. Estimar a regressão de Dickey-Fuller com k desfasamentos da variável
   dependente.

2. O último desfasamento é significante? Se sim, executar o teste com com
   a ordem de desfasamento, k. Senão, fazer k = k - 1; se k for igual a 0,
   executar o teste com a ordem de desfasamento 0, senão saltar para o
   passo 1.

No contexto do passo 2 acima, "significante" quer dizer que para o último
desfasamento, a estatística-t, que segue uma distribuição normal, tem um
p-value bilateral assimptótico menor ou igual a 0,10.

Os p-values para os testes de Dickey-Fuller baseiam-se em MacKinnon (1996).
O código relevante é incluído com a generosa permissão do autor.

Menu path:    /Variável/Teste de Dickey-Fuller aumentado

# anova Statistics

Arguments:  response treatment [ block ] 
Option:     --quiet (não mostrar resultados)

Análise de Variância: response é uma série que mede um efeito com
interesse e treatment tem que ser uma variável discreta que codifica dois
ou mais tipos de tratamento (ou não-tratamento). Para ANOVA de duas-vias, a
variável block (que também deve ser discreta) codifica os valores de uma
variável de controlo.

Quando não se usa a opção --quiet, este comando mostra a tabela das somas
de quadrados e médias quadradas juntamente com um teste F. O teste F e o
seu valor P podem ser obtidos usando os acessores $test e $pvalue
respetivamente.

A hipótese nula do teste F é de que a resposta média é invariante com o
tipo de tratamento, ou por outras palavras, que o tratamento não produz
efeito. Em termos formais, o teste é apenas válido se a variância da
resposta for igual para todos os tipos de tratamentos.

Note que os resultados apresentados por este comando pertencem a um
subconjunto da informação resultante do procedimento seguinte, que é
facilmente implementável em gretl. Crie um conjunto de variáveis
auxiliares que codifiquem todos os tipos de tratamentos, exceto um. No caso
da ANOVA de duas-vias, adicionalmente, crie um conjunto de variáveis
auxiliares que codifiquem todos os "blocks" (controlos), exceto um. De
seguida efectue uma regressão sobre response com uma constante e com as
variáveis auxiliares usando "ols". No caso da ANOVA singular (ou uma-via) a
tabela é produzida passando a opção --anova para ols. No caso da ANOVA de
duas-vias o teste F relevante, é obtido usando o comando "omit". Por
exemplo (assumindo que y é a resposta, xt codifica os tratamentos, e xb
codifica os controlos):

	# uma-via
	list dxt = dummify(xt)
	ols y 0 dxt --anova
	# duas-vias
	list dxb = dummify(xb)
	ols y 0 dxt dxb
	# teste da significância conjunta de dxt
	omit dxt --quiet

Menu path:    /Modelo/Outros modelos lineares/ANOVA

# append Dataset

Argument:   ficheiro-de-dados 
Option:     --time-series (ver abaixo)

Abre um ficheiro de dados e acrescenta esse conteúdo ao conjunto de dados
actual, se os novos dados forem compatíveis. O programa tentará determinar
o formato do ficheiro de dados (nativo, texto simples, CSV, Gnumeric, Excel,
etc.).

Os dados acrescentados podem tomar a forma de observações adicionais em
variáveis já existentes, ou em novas variáveis. Caso sejam novas
variáveis, estas terão que ser compatíveis de acordo com: (a) o número
de observações dos novos dados seja o mesmo que nos dados existentes, ou
(b) que os novos dados estejam acompanhados de informação clara sobre as
observações de modo que gretl possa decidir onde colocar os valores.

Existe uma funcionalidade especial para acrescentar a um conjunto de dados
de painel. Seja n o número de unidades de secção cruzada no painel, T o
número de períodos temporais, e m o número de observações dos novos
dados. Se m = n os novos dados serão tomados como invariantes-temporais, e
serão copiados para a posição em cada período temporal. Por outro lado,
se m = T os dados serão tratados como sendo não-variantes a longo das
unidades de painel, e serão copiados para a posição em cada unidade. Se o
painel é "quadrado", e m é igual a n e a T, acontece uma ambiguidade.
Neste caso, por omissão, trata-se cada novos dados como sendo
invariantes-temporais, mas você pode forçar gretl para tratar os novos
dados como sendo série temporal ao fornecer a opção --time-series. (Esta
opção é ignorada nos outros casos.)

Ver também o comando "join" para um manuseamento mais sofisticado com
várias fontes de dados.

Menu path:    /Ficheiro/Acrescentar dados

# ar Estimation

Arguments:  desfasamentos ; variável-dependente variáveis-independentes 
Option:     --vcv (mostrar matriz de covariância)
Example:    ar 1 3 4 ; y 0 x1 x2 x3

Determina estimativas para os parâmetros usando o procedimento iteractivo e
generalizado de Cochrane-Orcutt (ver a Secção 9.5 de Ramanathan, 2002). A
iteração termina quando os erros das somas de quadrados sucessivos não
difiram em mais que 0,005 porcento ou após 20 iterações.

"desfasamentos" é uma lista de desfasamentos nos resíduos, terminada por
um ponto-e-vírgula. No exemplo acima o termo do erro é especificado como

  u(t) = rho(1)*u(t-1) + rho(3)*u(t-3) + rho(4)*u(t-4)

Menu path:    /Modelo/Série temporal/Estimação autoregressiva

# ar1 Estimation

Arguments:  variável-dependente variáveis-independentes 
Options:    --hilu (usar o procedimento Hildreth-Lu)
            --pwe (usar o estimador Prais-Winsten)
            --vcv (mostrar a matriz de covariância)
            --no-corc (não aperfeiçoar os resultados com Cochrane-Orcutt)
Examples:   ar1 1 0 2 4 6 7
            ar1 y 0 xlist --hilu --no-corc
            ar1 y 0 xlist --pwe

Determina estimativas admissíveis GLS para um modelo em que se assume que o
termo de erro segue um processo autoregressivo de primeira-ordem.

O métudo por omissão é o procedimento iterativo de Cochrane-Orcutt (ver,
por exemplo, a Secção 9.4 de Ramanathan, 2002). A iteração termina
quando as estimativas sucessivas do coeficiente de autocorrelação não
diferirem por mais de 0.001 ou após 20 iterações.

Se tiver sido dada a opção --hilu, é utilizado o procedimento de pesquisa
de Hildreth-Lu. Os resultados são depois aperfeiçoados usando o método
Cochrane-Orcutt, exceto se tiver sido indicada a opção --no-corc. (Esta
última opção é ignorada se não tiver sido usado --hilu).

Se tiver sido dada a opção --pwe, é usado o estimador de Prais-Winsten.
Isto involve uma iteração semelhante à de Cochrane-Orcutt; a diferença
é que equanto Cochrane-Orcutt descarta a primeira observação, a de
Prais-Winsten faz uso dela. Para mais detalhes ver, por exemplo, o Capítulo
13 do livro de Greene, Econometric Analysis (2000).

Menu path:    /Modelo/Série temporal/Cochrane-Orcutt
Menu path:    /Modelo/Série temporal/Hildreth-Lu
Menu path:    /Modelo/Série temporal/Prais-Winsten

# arbond Estimation

Argument:   p [ q ] ; variável-dependente variáveis-independentes [ ; instrumentos ] 
Options:    --quiet (não mostrar o modelo estimado)
            --vcv (mostrar matriz de covariância)
            --two-step (executa estimação pelo Método Generalizado dos Momentos (GMM) de 2-fases)
            --time-dummies (acrescenta variáveis auxiliares tempo)
            --asymptotic (erros padrão assimptóticos não corrigidos)
Examples:   arbond 2 ; y Dx1 Dx2
            arbond 2 5 ; y Dx1 Dx2 ; Dx1
            arbond 1 ; y Dx1 Dx2 ; Dx1 GMM(x2,2,3)
            See also arbond91.inp

Executa a estimação de modelos de painel dinâmico (ou seja, modelos de
painel que contenham um ou mais desfasamentos da variável dependente)
recorrendo ao método Método Generalizado dos Momentos (GMM-DIF)
desenvolvido por Arellano and Bond (1991). Por favor ver "dpanel" para uma
versão mais flexível e actualizada deste comando que também usa GMM-SYS
para além do GMM-DIF.

O parâmetro p representa a ordem da autoregressão para a variável
dependente. O parâmetro opcional q indica o máximo desfasamento do nível
da variável dependente a ser usada como um instrumento. Se este argumento
for omitido, ou de valor 0, todos os desfasamentos disponíveis são usados.

A variável dependente deve ser dada na forma de níveis; ela será
automaticamente diferenciada (pois este estimador usa diferenciação para
anular os efeitos individuais). As variáveis independentes não são
automaticamente diferenciadas; se você pretende usar diferenças (o que
acontece em geral para variáveis quantitativas, mas não será, por
exemplo, para variáveis auxiliares temporais), deve primeiro criar essas
diferenças e depois especificar estas como sendo regressoras.

O último campo (opcional) do comando serve para especificar instrumentos.
Se não for dado nenhum, então é assumido que todas as variáveis
independentes são estritamente exógenas. Se você especificar alguns
instrumentos, então deve incluir na lista quaisquer variáveis
independentes estritamente exógenas. Para regressores predeterminados,
você pode usar a função GMM para incluir uma gama de desfasamentos
especificada no modo bloco-diagonal. Isto é ilustrado no terceiro exemplo
acima. O primeiro argumento de GMM é o nome da variável em questão, o
segundo é o desfasamento mínimo a ser usado como instrumento, e o terceiro
é o desfasamento máximo. Se o terceiro argumento for dado como 0, todos os
desfasamentos disponíveis são usados.

Por omissão são apresentados os resultados da estimação 1-fase (com
erros padrão robustos). Opcionalmente, você pode escolher estimação de
2-fases. Em ambos os casos são efectuados testes de autocorrelação de
ordem 1 e 2, assim como o teste de sobre-identificação de Sargan e o teste
de Wald para a significância conjunta dos regressores. Note-se que este
modelo de diferenciação com autocorrelação de primeira-ordem não
invalida o modelo, mas que a autocorrelação de segunda-ordem não respeita
as assunções estatísticas presentes.

No caso da estimação de 2-fases, por omissão, os erros padrão são
determinados usando a correcção de amostra-finita sugerida por Windmeijer
(2005). Os erros padrão assimptóticos associados ao estimador de 2-fases
são em geral considerados como guias para inferência pouco fiáveis, mas
se por alguma razão os pretender ver, você pode usar a opção
--asymptotic para desligar a correcção de Windmeijer.

Se for dada a opção --time-dummies, são acrescentadas variáveis
auxiliares temporais aos regressores especificados. Para evitar
colinearidade perfeita com a constante, o número de auxiliares é uma
unidade a menos que o número máximo de períodos usados na estimação. As
auxiliares são introduzidas por níveis; se você deseja usar auxiliares de
tempo na forma de primeiras-diferenças, você terá que definir e
acrescentar essas variáveis manualmente.

Menu path:    /Modelo/Painel/Arellano-Bond

# arch Estimation

Arguments:  ordem variável-dependente variáveis-independentes 
Example:    arch 4 y 0 x1 x2 x3

This command is retained at present for backward compatibility, but you are
better off using the maximum likelihood estimator offered by the "garch"
command; for a plain ARCH model, set the first GARCH parameter to 0.

Estima a especificação do modelo fornecido aceitando em ARCH
(Heterosquedicidade Condicional Autoregressiva). O modelo é primeiramente
estimado em OLS, e depois é efectuada uma regressão auxiliar, na qual, o
quadrado dos resíduos da primeira fase é regredido com os seus próprios
valores desfasados. A fase final é uma estimação por mínimos quadrados
com pesos, usando como pesos os recíprocos das variâncias de erro
ajustadas da regressão auxiliar. (Se a variância predita de de alguma
observação na regressão auxiliar for não positiva, então será usada o
correspondente resíduo quadrado).

Os valores alpha mostrados abaixo dos coeficientes são os parâmetros
estimados do processo ARCH da regressão auxiliar.

Ver também "garch" e "modtest" (a opção --arch).

Menu path:    /Modelo/Série temporal/ARCH

# arima Estimation

Arguments:  p d q [ ; P D Q ] variável-dependente ; [ variáveis-independentes ] 
Options:    --verbose (mostrar detalhes das iterações)
            --vcv (mostrar matriz de covariância)
            --hessian (ver abaixo)
            --opg (ver abaixo)
            --nc (não incluir uma constante)
            --conditional (usar verosimilhança máxima condicional)
            --x-12-arima (usar X-12-ARIMA para estimação)
            --lbfgs (usar maximizador L-BFGS-B)
            --y-diff-only (ARIMAX especial, ver abaixo)
            --save-ehat (ver abaixo)
Examples:   arima 1 0 2 ; y
            arima 2 0 2 ; y 0 x1 x2 --verbose
            arima 0 1 1 ; 0 1 1 ; y --nc

Se não for dada a lista de variáveis-independentes, é estimado um modelo
ARIMA (Média Móvel, Autoregressiva, Integrada) univariado. O valores
inteiros p, d e q representam respectivamente, a ordem autoregressiva (AR),
a ordem de diferenciação, e ordem da média móvel (MA). Estes valores
podem ser fornecidos na forma numérica, ou como nome de variáveis
escalares pré-existentes. Por exemplo, um valor de 1 em d, significa que a
primeira diferença da variável dependente deve ser obtida antes de estimar
os parâmetros ARMA.

Se você pretender apenas incluir no modelo desfasamentos específicos AR ou
MA (e não todos os desfasamentos até uma certa ordem) você pode
substituir p e/ou q de acordo com: (a) o nome de uma matriz pré-definida
contendo um conjunto de valores inteiros, ou (b) uma expressão tal como {1
4}; ou seja, um conjunto de desfasamentos separados por espaços dentro de
chavetas.

Os valores inteiros opcionais,P, D e Q representam respectivamente, a
sazonalidade AR, a ordem para diferenciação de sazonalidade e a ordem de
sazonalidade MA. Estes são apenas aplicáveis se os dados tiverem uma
frequência superior a 1 (por exemplo, trimestral ou mensal). Mais uma vez,
estas ordens podem ser dadas na forma numérica ou como variáveis.

No caso univariado é incluído no modelo por omissão, um interceptor, mas
isto pode ser suprimido com a opção --nc. Se forem fornecidas
variáveis-independentes, o modelo passa a ser ARMAX; neste caso a constante
deve ser explicitamente incluída se você pretender um interceptor (tal
como no segundo exemplo acima).

Existe outra forma alternativa para este comando: se você não pretende
aplicar diferenciação (seja sazonal ou não-sazonal), você pode omitir
ambos os parâmetros d e D, em vez de entrar explicitamente zeros. Além
disso, arma é um sinónimo ou aliás para arima. Assim, por exemplo, o
comando seguinte é válido para especificar o modelo ARMA(2, 1):

	arma 2 1 ; y

O normal é usar a funcionalidade "nativa" gretl ARMA, com estimação de
Máxima Verosimilhança (ML) exata (usando o filtro de Kalman). Outras
opções são: código nativo, ML condicional; X-12-ARIMA, ML exata; e
X-12-ARIMA, ML condicional. (As últimas duas opções estão disponíveis
apenas se o programa X-12-ARIMA estiver instalado.) Para detalhes sobre
estas opções, veja por favor the Gretl User's Guide.

Quando o código nativo ML é usado, os erros padrão são por omissão
baseados numa aproximação numérica da (inversa negativa da) Hessiana, ou
em recurso, no produto externo do gradiente (OPG) caso falhe o cálculo da
Hessiana numérica. Podem ser usadas duas opções (mutualmente exclusivas)
para forçar a situação: a opção --opg força o uso do método OPG, sem
tentar obter a Hessiana, enquanto a opção --hessian desativa o OPG em
último recurso. Note que a falha na determinação da Hessiana numérica
indica, em geral um modelo incorretamente especificado.

A opção --lbfgs é específica para estimação usando código nativo ARMA
e ML exata: significa o uso do algoritmo de "memória limitada" L-BFGS-B em
vez do usual maximizador BFGS. Isto pode ajudar em alguns casos onde a
convergência é difícil de atingir.

A opção --y-diff-only é específica na estimação de modelos ARIMAX
(modelos com uma ordem de integração não-nula e que incluam regressores
exógenos), e aplica-se apenas quando se usa a ML exata e nativa de gretl.
Para esses modelos o comportamento normal é de diferenciar tanto as
variáveis dependentes como as regressoras, mas quando esta opção é
fornecida, apenas é diferenciada a variável dependente, mantendo-se as
variáveis regressoras na forma de nível.

A opção --save-ehat é aplicável apenas quando se usa estimação ML
nativa e exata. O efeito é o de disponibilizar um vector contendo a
estimativa óptima de período t da perturbação data-t ou inovação: isto
pode ser recuperado com o uso do acessor $ehat. Estes valores diferem da
série dos resíduos ($uhat), que contém os erros de predição
um-passo-à-frente.

O valor AIC retornado em ligação com os modelos ARIMA é calculado
conforme a definição usada no programa X-12-ARIMA, nomeadamente

  AIC = -2L + 2k

onde L é o logaritmo da verosimilhança e k é o número total de
parâmetros estimados. Note-se que o programa X-12-ARIMA não produz
critérios de informação tal como o AIC quando a estimação é por ML
condicional.

As raízes AR e MA apresentadas em ligação com a estimação ARMA são
baseadas na seguinte representação de um processo ARMA(p,q):

	(1 - a_1*L - a_2*L^2 - ... - a_p*L^p)Y =
          c + (1 + b_1*L + b_2*L^2 + ... + b_q*L^q) e_t

As raízes AR são portanto as soluções de

         1 - a_1*z - a_2*z^2 - ... - a_p*L^p = 0

e a estabilidade requer que estas raízes estejam fora do círculo
unitário.

A imagem da "frequência" apresentada em ligação com as raízes AR e MA é
o valor lambda que resolve z = r * exp(i*2*pi*lambda) onde z é a raiz em
questão e r o seu módulo.

Menu path:    /Modelo/Série temporal/ARIMA
Other access: Menu de contexto da janela principal (selecção singular)

# biprobit Estimation

Arguments:  variável-dependente1 variável-dependente2 variáveis-independentes1 [ ; variáveis-independentes2 ] 
Options:    --vcv (mostrar a matriz de covariância)
            --robust (erros padrão robustos)
            --cluster=variável-agrupada (ver a explicação em "logit")
            --opg (ver abaixo)
            --save-xbeta (ver abaixo)
            --verbose (mostrar informação adicional)
Examples:   biprobit y1 y2 0 x1 x2
            biprobit y1 y2 0 x11 x12 ; 0 x21 x22
            See also biprobit.inp

Estima um modelo probit bivariado, usando o método de Newton-Raphson para
maximizar a verosimilhança.

A lista de argumentos começa com as duas variáveis dependentes
(binárias), seguidas pela lista de regressores. Se a segunda lista tiver
sido dada, separada por um ponto-e-vírgula, ela será interpretada como
sendo o conjunto de regressores para a segunda equação, e as
variáveis-independentes1 são específicas para a primeira equação; caso
contrário as variáveis-independentes1 são consideradas representando o
conjunto de regressores comum.

Por omissão, os erros padrão são calculados usando uma aproximação
númerica por convergência da Hessiana. Mas se tiver sido dada a opção
--opg a matriz de covariância será baseada no produto externo do gradiente
(OPG), ou se a opção --robust tiver sido dada, o erros padrão QML serão
calulados usando a "sandwich" entre a inversa da Hessiana e a OPG.

Depois duma estimação com sucesso, o acessor $uhat obtém uma matriz de
duas colunas que são os resíduos generalizados das duas equações; ou
seja, os valores esperados das perturbações condicionadas pelos resultados
observados e covariados. Por omissão o $yhat obtém a matriz com quatro
colunas, que são as probabilidades estimadas para os quatro possíveis
resultados conjuntos para (y_1, y_2), e pela ordem (1,1), (1,0), (0,1),
(0,0). Alternativamente, se tiver sido usada a opção --save-xbeta, o $yhat
tem duas colunas e contém os valores das funções de índice para as
respectivas equações.

A saída inclui o teste de razões de verosimilhança para a hipótese nula
de que as perturbações nas duas equações são não-correlacionadas.

# boxplot Graphs

Argument:   lista-de-variáveis 
Options:    --notches (mostrar intervalo de 90 porcento para a mediana delimitado por entalhes)
            --factorized (ver abaixo)
            --panel (ver abaixo)
            --matrix=nome (mostra o gráfico das colunas da matriz indicada)
            --output=nome-de-ficheiro (envia a saída para o ficheiro especificado)

Estes gráficos apresentam a distribuição de uma variável. A caixa
central contém os 50 porcento dos dados centrais, i.e. está limitada pelos
primeiro e terceiro quartis. Os "bigodes" estendem-se até aos valores
mínimo e máximo. É desenhada uma linha que corta a caixa na mediana. Um
símbolo "+" indica a média. Se tiver sido selecionada a opção de mostrar
o intervalo de confiança para a média, ele é obtido pelo método
'bootstrap' e apresentado na forma de linhas a tracejado acima e abaixo da
mediana.

A opção --factorized permite examinar a distribuição de uma variável
condicionada pelo valor de um fator discreto. Por exemplo, se um conjunto de
dados contém salários e uma variável auxiliar para o sexo, você pode
selecionar a variável salário como alvo e o sexo como fator para
visualizar lado a lado gráficos caixas-com-bigodes dos salários de homens
e mulheres, como em

	boxplot salario sexo --factorized

Note que neste caso você tem que especificar exatamente duas variáveis,
com a variável fator em segundo lugar.

Se o conjunto de dados atual é de painel, e apenas tiver sido especificada
uma variável, a opção --panel produz uma série de gráficos
caixas-com-bigodes lado a lado, para cada uma das "unidades" do painel ou
grupo.

Em modo interativo o resultado é mostrado imediatamente. Em modo lote
('batch') o comportamento normal é o de criar um ficheiro de comandos
gnuplot na diretoria de trabalho do utilizador, cujo nome segue a forma
gpttmpN.plt, iniciando com N = 01. Esses gráficos poderão ser
posteriormente gerados com o programa gnuplot (em MS Windows, wgnuplot).
Este comportamento pode ser modificado usando a opção --output=
nome-de-ficheiro. Para mais detalhes, ver o comando "gnuplot".

Menu path:    /Ver/Gráfico das variáveis/Caixa com bigodes

# break Programming

Sai de um ciclo. Este comando pode apenas ser usado dentro de um ciclo; ele
termina a execução de comandos e sai de dentro do ciclo (o mais interior).
Ver também "loop".

# catch Programming

Syntax:     catch command

Isto não é um comando em sentido estrito mas pode ser usado como um
prefixo na maior parte dos comandos: o efeito é o de prevenir a eventual
interrupção da execução de comandos (ou de um ficheiro de comandos)
quando ocorra um erro num comando. Se acontecer um erro, este fica registado
como sendo um erro interno que pode ser acedido com $error (um valor de zero
indica sucesso). O valor de $error deve ser sempre verificado imediatamente
a seguir ao uso de catch, e deve ser tomada a ação adequada se o comando
falhou.

A palavra reservada catch não pode ser usada antes de if, elif ou endif.

# chow Tests

Variants:   chow observação
            chow variável-auxiliar --dummy
Options:    --dummy (usar uma variável auxiliar pré-existente)
            --quiet (não mostrar estimativas para o modelo aumentado)
Examples:   chow 25
            chow 1988:1
            chow female --dummy

Tem que se seguir a uma regressão de Mínimos Quadrados (OLS). Se um
número de observação ou uma data tiver sido dado, produz um teste sobre a
hipótese nula de não haver quebra estrutural no ponto de separação
indicado. O procedimento cria uma variável auxiliar que é igual a 1 a
partir do ponto especificado por observação até ao final da amostra, caso
contrário é 0, e cria também termos de interação entre esta variável
auxiliar e as variáveis regressoras originais. Se tiver sido dada uma
variável auxiliar, será testada a hipótese nula de homogeneidade
estrutural no que diz respeito a essa variável auxiliar. Mais uma vez, os
termos de interação são acrescentados. Em quaisquer dos casos, é
executada uma regressão aumentada que inclui estes termos e é calculada a
estatística F, considerando a regressão aumentada como não restringida e
a original como restringida. Mas se o modelo original usou um estimador
robusto para a matriz de covariância, a estatística de teste é um valor
de qui-quadrado de Wald baseada num estimador robusto da matriz de
covariância da regressão aumentada.

Menu path:    Janela do modelo, /Testes/Teste de Chow

# clear Programming

Option:     --dataset (apagar apenas o conjunto de dados)

Sem opções, apaga da memória todos os objetos gravados, incluindo o
conjunto de dados corrente. Note que ao abrir um novo conjunto de dados, ou
ao usar o comando "nulldata" para criar um conjunto de dados vazio, obterá
o mesmo efeito, por isso o uso de "clear" normalmente não é necessário.

Se tiver sido dada a opção --dataset, então apenas o conjunto de dados é
apagado; os outros objetos gravados como matrizes e escalares serão
preservados.

# coeffsum Tests

Argument:   lista-de-variáveis 
Example:    coeffsum xt xt_1 xr_2
            See also restrict.inp

Tem que se seguir a uma regressão. Calcula a soma dos coeficientes nas
variáveis indicadas na lista-de-variáveis. Apresenta esta soma juntamente
com o seu erro padrão e o p-value para a hipótese nula de que a soma é
zero.

Note-se a diferença entre este teste e "omit", que testa a hipótese nula
de que os coeficientes num conjunto especificado de variáveis independentes
são todos iguais a zero.

Menu path:    Janela do modelo, /Testes/Soma de coeficientes

# coint Tests

Arguments:  ordem variável-dependente variáveis-independentes 
Options:    --nc (não incluir uma constante)
            --ct (incluir constante e tendência)
            --ctt (incluir constante e tendência quadrática)
            --skip-df (não efectuar testes DF nas variáveis individuais)
            --test-down (ordem de desfasamento automática)
            --verbose (mostrar detalhes adicionais das regressões)
Examples:   coint 4 y x1 x2
            coint 0 y x1 x2 --ct --skip-df

O teste de cointegração Engle-Granger. O procedimento por omissão é: (1)
efetuar testes de Dickey-Fuller (DF) segundo a hipótese nula de que cada
variável listada tem uma raiz unitária; (2) estima a regressão de
cointegração; e (3) executar um teste DF sobre os resíduos da regressão
de cointegração. Se for dada a opção --skip-df, o passo (1) é omitido.

Se a ordem de desfasamento especificada é positiva, todos os testes
Dickey-Fuller usam essa ordem, com esta qualificação: se a opção
--test-down for dada, o valor indicado é tomado como sendo o máximo e a
ordem de desfasamento efetivamente usada em cada caso é obtida testando
para baixo. Ver o comando "adf" para detalhes sobre este procedimento.

Por omissão, a regressão de cointegração contém uma constante. Se você
deseja suprimir a constante, acrescente a opção --nc. Se você deseja
aumentar a lista de termos determinísticos na regressão de cointegração
com uma tendência linear ou quadrática, use a opção --ct ou --ctt. Estas
opções são mutualmente exclusivas.

Os P-values para este teste são baseados em MacKinnon (1996). O código
relevante é incluído com a generosa permissão do autor.

Menu path:    /Modelo/Série temporal/Testes de Cointegração/Engle-Granger

# coint2 Tests

Arguments:  ordem listaY [ ; listaX ] [ ; listaRx ] 
Options:    --nc (sem constante)
            --rc (constante restringida)
            --uc (constante não restringida)
            --crt (constante e tendência restringida)
            --ct (constante e tendência não restringida)
            --seasonals (incluir auxiliares sazonais centradas)
            --asy (registar valores p assimtóticos)
            --quiet (apenas mostrar os testes)
            --silent (não mostrar nada)
            --verbose (mostrar detalhes das regressões auxiliares)
Examples:   coint2 2 y x
            coint2 4 y x1 x2 --verbose
            coint2 3 y x1 x2 --rc

Executa o teste de Johansen para a cointegração entre as variáveis em
listaY para a dada ordem de desfasamento. Para detalhes sobre este teste ver
the Gretl User's Guide ou Hamilton (1994), Capítulo 20. Os valores p são
calculados usando a aproximação gama de Doornik (Doornik, 1998). São
mostrados dois conjuntos de valores p para o teste traço, valores
assintóticos imediatos e valores ajustados para o tamanho da amostra. Por
omissão, o acessor $pvalue obtém a variante ajustada, mas se opção --asy
for dada, pode ser usado para registar os valores assintóticos.

A inclusão de termos determinísticos no modelo é controlada por
intermédio das opções. Por omissão, se não tiver sido indicada nenhuma
opção, será incluída uma "constante não restringida", o que permite a
presença de um interceptor não-nulo nas relações cointegrantes assim
como uma tendência nos níveis das variáveis endógenas. Na literatura
derivada do trabalho de Johansen (ver por exemplo o livro dele de 1995) isto
é frequentemente referido como sendo o "caso 3". As primeiras quatro
opções apresentadas acima, que são mutualmente exclusivas, produzem
respectivamente os casos 1, 2, 4, e 5. O significado destes casos e os
critérios para seleccionar um caso estão explicados no the Gretl User's
Guide.

As listas opcionais listaX e listaRx permite-lhe controlar as variáveis
exógenas: estas entram no sistema como não restringidas (listaX) ou
restringidas ao espaço de cointegração (listaRx). Estas listas são
separadas da listaY e entre elas usando ponto-e-vírgulas.

A opção --seasonals, que pode ser combinada com qualquer outra opção,
especifica a inclusão de um conjunto de variáveis auxiliares sazonais.
Esta opção apenas está disponível para dados trimestrais ou mensais.

A seguinte tabela serve como um guia à interpretação dos resultados
apresentados pelo teste, num caso de 3-variáveis. H0 significa a hipótese
nula, H1 a hipótese alternativa, e c o número de relações cointegrantes.

         Ordem    Teste Traço        Teste Lmax
                  H0     H1          H0     H1 
         ---------------------------------------
          0      c = 0  c = 3       c = 0  c = 1
          1      c = 1  c = 3       c = 1  c = 2
          2      c = 2  c = 3       c = 2  c = 3
         ---------------------------------------

Ver também o comando "vecm".

Menu path:    /Modelo/Série temporal/Testes de Cointegração/Johansen

# corr Statistics

Argument:   [ lista-de-variáveis ] 
Options:    --uniform (garante amostra uniforme)
            --spearman (Ró de Spearman)
            --kendall (Tau de Kendall)
            --verbose (mostra classificações ('rankings'))
Examples:   corr y x1 x2 x3
            corr ylist --uniform
            corr x y --spearman

Apresenta os coeficientes de correlação emparelhados (correlação
momento-produto de Pearson) para as variáveis indicadas. O comportamento
normal é usar todas as observações para calcular cada coeficiente
emparelhado, mas se a caixa de seleção estiver selecionada a amostra será
limitada (caso seja necessário) de modo que o mesmo conjunto de
observações seja usado em todos os coeficientes. Esta opção apenas tem
efeito se existirem valores omissos em quantidades diferentes para as
variáveis usadas.

Por omissão, apresenta os coeficientes de correlação emparelhados
(correlação momento-produto de Pearson) para as variáveis
lista-de-variáveis, ou para todas as variáveis no conjunto de dados se
não tiver sido indicada lista-de-variáveis. O comportamento normal é o de
usar todas as observações disponíveis para calcular cada coeficiente
emparelhado, mas se tiver sido dada a opção --uniform a amostra será
limitada (caso seja necessário) de modo que o mesmo conjunto de
observações seja usado em todos os coeficientes. Esta opção apenas tem
efeito se existirem valores omissos em quantidades diferentes para as
variáveis usadas.

As opções (mutualmente exclusivas) --spearman e --kendall produzem,
respetivamente, o Ró de correlação de Spearman e o Tau de correlação de
ordem de Kendall em vez do usual coeficiente de Pearson. Quando uma destas
opções é dada, a lista-de-variáveis deve apenas conter duas variáveis.

Ao calcular uma correlação de ordem, pode ser dada a opção --verbose
para mostrar os dados originais e ordenados (caso contrário esta opção
será ignorada).

Menu path:    /Ver/Matriz de correlação
Other access: Menu de contexto da janela principal (selecção múltipla)

# corrgm Statistics

Arguments:  série [ ordem ] 
Option:     --plot=modo ou nome-de-ficheiro (ver abaixo)
Example:    corrgm x 12

Apresenta os valores da função de autocorrelação para a série, que pode
ser especificada por nome ou por número. Os valores são definidos como
rho(u_t, u_t-s) onde u_t é a t-ésima observação da variável u e s é o
número de desfasamentos.

Também são apresentadas as autocorrelações parciais (obtidas segundo o
algoritmo de Durbin-Levinson): estas constituem a rede dos efeitos dos
desfasamentos intervenientes. Adicionalmente, é apresentada a estatística
de teste Q de Ljung-Box. Esta pode ser usada para testar a hipótese nula de
que a série é "ruído branco": terá uma distribuição qui-quadrado
assimptótico com os graus de liberdade iguais ao número de desfasamentos
usados.

Se o valor ordem for especificado o comprimento do correlograma fica
limitado a esse máximo número de desfasamentos, senão o comprimento é
determinado automaticamente, como uma função da frequência dos dados e do
número de observações.

Por omissão é apresentado um gráfico do correlograma: um gráfico gnuplot
em modo interativo ou um gráfico ASCII em modo de lote de comandos. Isto
pode ser ajustado por via da opção --plot. Os parâmetros válidos para
esta opção são none (para suprimir o gráfico); ascii (para produzir um
gráfico de texto mesmo em modo interativo); display (para produzir um
gráfico gnuplot mesmo em modo de lote de comandos); ou o nome de um
ficheiro. O efeito de se fornecer um nome de ficheiro é como descrito para
a opção --output do comando "gnuplot".

Depois de completar com sucesso, os acessores $test e $pvalue contêm os
respectivos valores do teste de Ljung-Box para a maior ordem apresentada.
Note que se você apenas quiser determinar a estatística Q, provavelmente
você quererá usar a função "ljungbox".

Menu path:    /Variável/Correlograma
Other access: Menu de contexto da janela principal (selecção singular)

# cusum Tests

Options:    --squares (executa o teste CUSUMSQ)
            --quiet (apenas mostra o teste Harvey-Collier)

Tem que se seguir à estimação de um modelo por via de OLS. Executa o
teste CUSUM -- ou se for dada a opção --squares, o teste CUSUMSQ -- para a
estabilidade dos parâmetros. É obtida uma série temporal de erros de
predição um passo-à-frente, pela execução de séries de regressões: a
primeira regressão usa as primeiras k observações e é usada para gerar a
predição da variável dependente na observação k + 1; a segunda usa a
primeira predição para a observação k + 2, e por aí a diante (onde k é
o número de parâmetros no modelo original).

A soma acumulada dos erros de predição escalados, ou os quadrados desses
erros, é mostrada e apresentada em gráfico. A hipótese nula para a
estabilidade dos parâmetros é rejeitada ao nível de cinco porcento, se a
soma acumulada se desviar do intervalo de confiança de 95 porcento.

No caso do teste CUSUM, é também apresentada a estatística de teste t de
Harvey-Collier, para a hipótese nula da estabilidade dos parâmetros. Ver o
livro Econometric Analysis de Greene para mais detalhes. Para o teste
CUSUMSQ, o intervalo de confiança a 95 porcento é calculado de acordo com
o algoritmo apresentado por Edgerton e Wells (1994).

Menu path:    Janela do modelo, /Testes/Teste CUSUM(SQ)

# data Dataset

Argument:   lista-de-variáveis 
Option:     --quiet (não reportar resultados exceto quando hajam erros)

Lê as variáveis indicadas na lista-de-variáveis a partir de uma base de
dados (gretl, RATS 4.0 ou PcGive), que deve ter sido préviamente aberta
usando o comando "open". A frequência dos dados e o intervalo da amostra
podem ser definidos pelos comandos "setobs" e "smpl" antes de usar este
comando. Apresenta-se um exemplo completo:

	open macrodat.rat
	setobs 4 1959:1
	smpl ; 1999:4
	data GDP_JP GDP_UK

Os comandos acima abrem a base de dados com o nome macrodat.rat, definem um
conjunto de dados trimestral iniciando no primeiro trimestre de 1959 e
terminando no quarto trimestre de 1999, e depois importam as séries
temporais com os nomes GDP_JP e GDP_UK.

Se os comandos setobs e smpl não tiverem sido especificados deste modo, a
frequência dos dados e o intervalo da amostra serão definidos usando a
primeira variável lida da base de dados.

Se as séries temporais a serem lidas forem de frequência superior à do
conjunto de dados em uso, você pode especificar um método de compactação
tal como abaixo:

	data (compact=average) LHUR PUNEW

Os quatro métodos de compactação disponíveis são: Média; "average"
(usa a média das observações de maior frequência), Último; "last" (usa
a última observação), Primeiro; "first" e Soma; "sum". Se não tiver sido
indicado nenhum métod, será usado a Média.

Menu path:    /Ficheiro/Bases de Dados

# dataset Dataset

Arguments:  palavra-chave parâmetros 
Examples:   dataset addobs 24
            dataset insobs 10
            dataset compact 1
            dataset compact 4 last
            dataset expand interp
            dataset transpose
            dataset sortby x1
            dataset resample 500
            dataset renumber x 4
            dataset clear

Efectua diversas operações sobre o conjunto de dados como um todo,
dependendo da palavra-chave, que tem que ser addobs, insobs, clear, compact,
expand, transpose, sortby, dsortby, resample ou renumber. Nota: exceptuando
clear, estas ações não estão disponíveis enquanto o conjunto de dados
estiver subamostrado por seleção de casos com algum critério Booleano.

addobs: Tem que ser seguida por um inteiro positivo. Acrescenta o número
indicado de observações adicionais no final do conjunto de dados em uso.
Essencialmente, isto é pretendido para efeitos de predição. Os valores na
maior parte das variáveis no intervalo acrescentado, serão marcados como
omissos, mas certas variáveis determinísticas são reconhecidas e
extendidas, nomeadamente, uma tendência linear simples e variáveis
periódicas auxiliares.

insobs: Tem que ser seguida por um inteiro positivo que não seja maior que
o número de observações atual. Inserte uma única observação na
posição indicada. Todos os dados subsequentes são deslocados uma
posição e o conjunto de dados fica extendido com mais uma observação.
Todas as variáveis exceto a constante recebem um valor omisso na nova
observação. Esta ação não está disponível para conjuntos de dados de
painel.

clear: Não necessita parâmetros. Limpa o conjunto de dados corrente,
ficando gretl no seu estado "vazio" inicial.

compact: Tem que ser seguida por um inteiro positivo representando uma nova
frequência, que deve ser inferior à frequência atual (por exemplo, um
valor 4 quando a frequência corrente é 12, indica a compactação de
mensal para trimestral). Este comando apenas está disponível para séries
temporais; ele compacta todas as séries temporais do conjunto de dados para
a nova frequência. Pode ser dado um segundo parâmetro, nomeadamente um de
sum, first ou last, para especificar, respectivamente, compactação usando
a soma dos valores de maior frequência, valores de ínicio e de fim de
período. Por omissão é feita compactação por média.

expand: Este comando está apenas disponível para séries temporais anuais
ou trimestrais: dados anuais podem ser expandidos para trimestrais, e dados
trimestrais para frequência mensal. Por omissão todas as séries temporais
no conjunto de dados são preenchidas com repetição de valores existentes
até atingirem a nova frequência, mas se tiver sido acrescentado o
modificador interp então as séries temporais serão expandidas usando a
interpolação de Chow-Lin: os regressores são a constante e a tendência
quadrada e é assumido um processo de perturbação AR(1).

transpose: Não necessita parâmetros. Transpõe o conjunto de dados actual.
Isto é, cada observação (linha) será tratada como uma variável
(coluna), e cada variável como uma observação. Este comando pode ser
útil se quando os dados tenham sido lidos a partir de uma origem externa em
que as linhas da tabela de dados representam variáveis.

sortby: É necessário o nome de uma lista ou de uma única série de dados.
Se tiver sido dada uma série de dados, as observações em todas as
variáveis do conjunto de dados são re-ordenadas por ordem crescente da
série especificada. Se tiver sido dada uma lista, a ordenação é
hierárquica: se as observações estiverem empatadas no que diz respeito à
primeira variável chave então é usada a segunda chave para desempatar, e
assim sucessivamente até que não haja empates ou se tenham esgotado as
chaves. Note que este comando apenas está disponível para dados sem data.

dsortby: Funciona como sortby exceto que a re-ordenação é por ordem
decrescente das séries chave.

resample: Constrói um novo conjunto de dados por amostragem aleatória, com
substituição das linhas do conjunto de dados corrente. Requer um
argumento, designadamente o número de linhas a incluir. Este pode ser
menor, igual ou maior que o número de observações nos dados originais. O
conjunto de dados original pode ser obtido usando o comando smpl full.

renumber: Requer o nome de uma de uma série seguido por um inteiro entre 1
e o número de séries no conjunto de dados menos 1. Move a série
especificada para a posição indicada dentro do conjunto de dados,
renumerando adequadamente as restantes séries. (A posição 0 está ocupada
pela constante, que não pode ser movida.)

Menu path:    /Dados

# debug Programming

Argument:   função 

Comando experimental para despiste de erros de programa ('debugger') em
funções definidas pelo utilizador, disponível em programas de
linha-de-comandos, gretlcli, e na consola do ambiente gráfico (GUI). O
comando debug deve ser utilizado antes da chamada da função, mas depois da
definição desta. O efeito é de que a execução é suspensa quando a
função é chamada e é activada uma linha de interação especial.

Na linha de interação, você introduz next para executar o comando
seguinte dentro da função, ou continue para permitir continuar a
execução da função sem impedimentos. Estes comandos podem ser abreviados
com n e c respetivamente. Você também pode interpôr uma instrução nesta
linha de interação, por exemplo um comando print para mostrar o valor
atual de alguma variável de interesse.

# delete Dataset

Argument:   nome-de-variável 
Options:    --db (apaga séries em base de dados)
            --type=nome-de-tipo (todas as variáveis do tipo dado)

Este comando é um destrutor geral para variáveis com nome (quer sejam
séries, escalares, matrizes, texto, ou 'bundles'). Tem que ser usada com
cuidado; não será peguntada nenhuma confirmação.

No caso de uma série nome-de-variável pode tomar a forma de uma lista com
nome, o que faz com que todas as séries nessa lista sejam apagadas, ou pode
tomar a forma de uma lista explícita de séries por nome ou número ID.
Note que quando você apaga séries, quaisquer séries com números ID
superiores àquelas que estão na lista a apagar serão renumeradas.

Se for dada a opção --db, o comando apaga as séries listadas não do
conjunto de dados atual mas de uma base de dados gretl, assumindo que a base
de dados está aberta e que o utilizador tem permissão de escrita no
ficheiro em questão. Ver também o comando "open".

Se tiver sido dada a opção --type ela terá de ser acompanhada por um dos
seguintes nomes-de-tipo: matrix (matriz), bundle ('bundle'), string (texto),
list (lista), ou scalar (escalar). O efeito é o de apagar todas as
variáveis do tipo dado. Neste caso (somente neste), não deve ser indicado
o argumento nome-de-variável.

Menu path:    Menu de contexto da janela principal (selecção singular)

# diff Transformations

Argument:   lista-de-variáveis 

É obtida a primeira diferença de cada variável na lista-de-variáveis e o
resultado é guardado numa nova variável com o prefixo d_. Portanto "diff x
y" cria as duas novas variáveis

	d_x = x(t) - x(t-1)
	d_y = y(t) - y(t-1)

Menu path:    /Acrescentar/Primeiras diferenças das variáveis selecionadas

# difftest Tests

Arguments:  variável1 variável2 
Options:    --sign (Teste dos Sinais, por omissão)
            --rank-sum (Teste ordinal da soma de Wilcoxon)
            --signed-rank (Teste ordinal dos sinais de Wilcoxon)
            --verbose (mostrar detalhes)

Realiza um teste não-paramétrico para a diferença entre duas populações
ou grupos, o teste específico depende da opção selecionada.

Com a opção --sign, é executado o teste dos Sinais. Este teste baseia-se
no facto de duas amostras x e y, terem sido extraídas aleatóriamente de
uma mesma distribuição, a probabilidade de x_i > y_i, para cada
observação i, deve ser igual a 0,5. A estatística de teste é w, o
número de observações para as quais x_i > y_i. Sob a hipótese nula de
que segue uma distribuição Binomial com os parâmetros (n, 0,5), onde n é
o número de observações.

Com a opção --rank-sum, é executado o teste ordinal da soma de Wilcoxon.
Este teste consiste em ordenar as observações de ambas as amostras
conjuntamente, da menor para a maior, e depois determinar a soma das ordens
de uma das amostras. As duas amostras não necessitam ser do mesmo tamanho,
e se isso acontece então usa-se a de menor dimensão no cálculo da soma
das ordens. Sob a hipótese nula de que as amostras terem sido extraídas de
populações com a mesma mediana, a distribuição de probabilidade da soma
das ordens pode ser determinada para quaisquer tamanhos das amostras; e para
amostras consideravelmente grandes existe uma forte aproximação a uma
distribuição Normal.

Com a opção --signed-rank, é executado o teste ordinal dos sinais de
Wilcoxon. Este destina-se para pares de dados associados assim como, por
exemplo, os valores das variáveis de uma amostra de indivíduos antes e
depois de algum tratamento. O teste começa por encontrar as diferenças
entre as observações emparelhadas, x_i - y_i, ordenando estas diferenças
por valor absoluto, e então atribuindo a cada par um posto com sinal,
coincidindo o sinal com o sinal da diferença. De seguida é calculado o
W_+, que é a soma dos postos com sinal positivo. Tal como o teste ordinal
da soma, esta estatística tem uma distribuição bem definida, sob a
hipótese nula de que a diferença mediana é zero, que converge para a
distribuição Normal em amostras de tamanho razoável.

Para os testes de Wilcoxon, se a opção --verbose tiver sido dada então
será mostrado as ordens. (Esta opção não tem efeito se tiver sido
selecionado o teste dos Sinais.)

# discrete Transformations

Argument:   lista-de-variáveis 
Option:     --reverse (marca variáveis como sendo contínuas)

Marca cada variável em lista-de-variáveis como sendo discreta. Por
omissão todas as variáveis são tratadas como sendo contínuas; ao marcar
uma variável como sendo discreta afeta o modo como a variável é usada em
diagramas de frequência, e também permite-lhe selecionar a variável para
o comando "dummify".

Se a opção --reverse tiver sido dada, é feito o contrário; ou seja, as
variáveis em lista-de-variáveis são marcadas como sendo contínuas.

Menu path:    /Variável/Editar caraterísticas

# dpanel Estimation

Argument:   p ; variável-dependente variáveis-independentes [ ; instrumentos ] 
Options:    --quiet (não mostrar o modelo estimado)
            --vcv (mostrar a matriz de covariância)
            --two-step (efetuar estimação GMM de dois passos)
            --system (acrescentar equações por níveis)
            --time-dummies (acrescentar variáveis auxiliares tempo)
            --dpdstyle (comportamento semelhante ao do pacote DPD do Ox)
            --asymptotic (erros padrão assimptóticos não corrigidos)
Examples:   dpanel 2 ; y x1 x2
            dpanel 2 ; y x1 x2 --system
            dpanel {2 3} ; y x1 x2 ; x1
            dpanel 1 ; y x1 x2 ; x1 GMM(x2,2,3)
            See also bbond98.inp

Efectua a estimação de modelos de dados de painel dinâmico (ou seja,
modelos de painel que incluem um ou mais desfasamentos da variável
dependente) usando os métodos GMM-DIF ou GMM-SYS.

O parâmetro p representa a ordem de autoregressão para a variável
dependente. Na forma mais simples esta é um valor escalar, mas este
argumento pode ser uma matriz pré-definida, para especificar um conjunto
(eventualmente descontínuo) de desfasamentos a serem usados.

A variável dependente e os regressores devem ser dados na forma de níveis;
eles serão automaticamente diferenciados (pois este estimador usa
diferenciação para anular os efeitos individuais).

O último campo (opcional) do comando é para especificar instrumentos. Se
não tiver sido dado instrumentos, é assumido que todas as variáveis
independentes são estritamente exógenas. Caso você especifique alguns
intrumentos, deverá incluir na lista variáveis independentes estritamente
exógenas. Para regressores pré-determinados, você pode usar a função
GMM para incluir a especificação de uma gama de desfasamentos numa forma
bloco-diagonal. Isto está exemplificado no terceiro exemplo acima. O
primeiro argumento de GMM é o nome da variável em questão, o segundo é o
desfasamento mínimo a ser usado como instrumento, e o terceiro é o
desfasamento máximo. A mesma sintaxe pode ser utilizada na função
GMMlevel para especificar instrumentos do tipo GMM para as equações nos
níveis.

Por omissão são apresentados os resultados da estimação a um passo
(juntamente com erros padrão robustos). Opcionalmente você pode selecionar
a estimação a dois passos. Em ambos os casos são determinados os testes
de autocorrelação de ordem 1 e 2, assim como o teste de Sargan para a
sobre-identificação e o teste de Wald para a significância conjunta dos
regressores. Note que neste modelo diferenciado a autocorrelação de
primeira ordem não é um risco para a validade do modelo, mas a
autocorrelação de segunda ordem viola as assunções estatísticas
presentes.

No caso da estimação em dois passos, os erros padrão são obtidos por
omissão usando a correção de amostra-finita sugerida por Windmeijer
(2005). Os erros padrão assimptóticos associados ao estimador de dois
passos, são em geral, considerados como um guia pouco fiável para
inferência, mas se por alguma razão você desejar observá-los você pode
usar a opção --asymptotic para desligar a correção de Windmeijer.

Se tiver sido dada a opção --time-dummies, uma conjunto de variáveis
auxiliares tempo é acrescentado aos regressores especificados. O número de
auxiliares é menos um que o número máximo de períodos usados na
estimação, para assim se evitar a colinearidade exata com a constante. As
variáveis auxiliares entram na forma diferenciada, exceto se tiver sido
dada a opção --dpdstyle, entrando nesse caso por níveis.

Para mais detalhes e exemplos, ver o the Gretl User's Guide.

Menu path:    /Modelo/Painel/Modelo de painel dinâmico

# dummify Transformations

Argument:   lista-de-variáveis 
Options:    --drop-first (omitir da codificação o menor valor)
            --drop-last (omitir da codificação o maior valor)

Para cada uma das variáveis adequadas em lista-de-variáveis, cria um
conjunto de variáveis auxiliares codificando para os diferentes valores
dessa variável. É adequado para as variáveis que tenham sido
explícitamente marcadas como sendo discretas, ou aquelas que tomem uma
quantidade razoavelmente pequena de valores todos eles "quase redondos"
(múltiplos de 0,25).

Por omissão é criada uma variável auxiliar para cada valor distinto na
variável em questão. Por exemplo se uma variável discreta x tiver 5
valores distintos, serão criadas 5 variáveis auxiliares e acrescentadas ao
conjunto de dados, com os nomes, Dx_1, Dx_2 e por aí adiante. A primeira
variável auxiliar terá o valor 1 para observações onde x toma o seu
valor mais pequeno, 0 caso contrário; a variável auxiliar seguinte terá o
valor 1 quando x toma o seu segundo valor mais pequeno, e por aí adiante.
Se uma das opções --drop-first ou --drop-last tiver sido acrescentada,
então o menor ou o maior valor de cada variável será omitido da
codificação (o que pode ser útil para evitar a "armadilha das variáveis
auxiliares").

Este comando também pode ser introduzido no contexto da especificação de
uma regressão. Por exemplo, a linha seguinte especifica um modelo onde y é
regredido sobre o conjunto de variáveis auxiliares codificadas em x. (Neste
contexto, as opções não podem ser passadas a "dummify".)

	ols y dummify(x)

# duration Estimation

Arguments:  variável-dependente variáveis-independentes [ ; variável-censora ] 
Options:    --exponential (usar a distribuição exponencial)
            --loglogistic (usar a distribuição log-logística)
            --lognormal (usar a distribuição log-normal)
            --medians (os valores ajustados são medianas)
            --robust (erros padrão robustos (QML))
            --cluster=variável-agrupada (ver a explicação em "logit")
            --vcv (mostrar a matriz de covariância)
            --verbose (mostrar detalhes das iterações)
Examples:   duration y 0 x1 x2
            duration y 0 x1 x2 ; cens

Estima um modelo de duração: a variável dependente (que tem que ser
positiva) representa a duração de algum tipo de estado num certo assunto,
por exemplo a duração de episódios de desemprego para uma seção-cruzada
de inquiridos. Por omissão é utilizada a distribuição de Weibull, mas é
possível usar as distribuições exponencial, log-logística e a
log-normal.

Se alguma das medições de durações estiver censurada ('right-censored')
(por exemplo, para um certo índividuo um episódio de desemprego não
chegou ao fim dentro do período de observação) então você pode
acrescentar como último argumento a variável-censora, que é uma série na
qual valores diferentes de zero indicam caso censurados.

Por omissão os valores ajustados obtidos por intermédio do acessor $yhat
são as médias condicionadas das durações, mas se tiver sido dada a
opção --medians, então $yhat devolve as medianas condicionadas.

Para mais detalhes ver the Gretl User's Guide.

Menu path:    /Modelo/Modelos não-lineares/Dados de durações...

# elif Programming

Ver "if".

# else Programming

Ver "if". Note que "else" requer uma linha para ele mesmo, antes do comando
condicional seguinte. Você pode juntar um comentário, como em

	else # Certo, fazer algo diferente

Mas não pode juntar a um comando, como em

	else x = 5 # Errado!

# end Programming

Termina diversos tipos de bloco de comandos. Por exemplo, "end system"
termina uma equação "system".

# endif Programming

Ver "if".

# endloop Programming

Marca o fim de um ciclo de comandos. Ver "loop".

# eqnprint Printing

Argument:   [ -f nome-de-ficheiro ] 
Option:     --complete (Cria um documento completo)

Tem que ser invocado a seguir à estimação de um modelo. Mostra o modelo
estimado na forma de uma equação LaTeX. Se o nome-de-ficheiro tiver sido
especificado usando a opção -f a saída é redirecionada para esse
ficheiro, caso contrário vai para um ficheiro com o nome no formato
equation_N.tex, onde N é o número de modelos estimados até ao momento na
sessão corrente. Ver também "tabprint".

Se a opção --complete tiver sido dada, o ficheiro LaTeX é um documento
completo, pronto para ser processado; de outro modo ele terá que ser
incluído num documento.

Menu path:    Janela do Modelo, /LaTeX

# equation Estimation

Arguments:  variável-dependente variáveis-independentes 
Example:    equation y x1 x2 x3 const

Especifica uma equação dentro de um sistema de equações (ver "system").
A sintaxe para especificar uma equação dentro de um sistema SUR é o mesmo
que em, por exemplo, "ols". Para uma equação dentro de um sistema de
Mínimos Quadrados de Três-Fases você tanto pode (a) fornecer uma
especificação de equação tipo OLS e dar uma lista comum de instrumentos
usando o comando "instr" (mais uma vez, ver "system"), ou (b) usar a mesma
sintaxe de equação como para "tsls".

# estimate Estimation

Arguments:  [ nome-do-sistema ] [ estimador ] 
Options:    --iterate (iterar até à convergência)
            --no-df-corr (não usar correção de graus de liberdade)
            --geomean (ver abaixo)
            --quiet (não mostrar resultados)
            --verbose (mostrar detalhes das iterações)
Examples:   estimate "Klein Model 1" method=fiml
            estimate Sys1 method=sur
            estimate Sys1 method=sur --iterate

Chama a estimação de um sistema de equações, que foi previamente
definido usando o comando "system". O nome do sistema deve ser dado em
primeiro lugar, dentro de aspas caso contenha espaços. O estimador, que tem
que ser um de "ols", "tsls", "sur", "3sls", "fiml" ou "liml", é precedido
pelo texto method=. Estes argumentos são opcionais se o sistema em questão
já foi estimado e ocupa a posição do "último modelo"; nesse caso o
estimador é o mesmo definido anteriormente.

Se o sistema em questão tinha aplicado um conjunto de restrições (ver o
comando "restrict"), a estimação estará sujeita às restrições
especificadas.

Se o método de estimação é "sur" ou "3sls" e a opção --iterate tiver
sido dada, o estimador será iterado. No caso do SUR, se o procedimento
convergir os resultados são estimativas de máxima vesrosimilhança. No
entanto, a iteração de Mínimos Quadrados de Três-Fases, geralmente não
converge para resultados de informação-completa de máxima
verosimilhança. A opção --iterate é ignorada nos outros métodos de
estimação.

Se tiverem sido escolhidos os estimadores equação-a-equação "ols" ou
"tsls", por omissão é aplicada uma correção dos graus de liberdade
quando se calcula os erros padrão. Isto pode ser suprimido usando a opção
--no-df-corr. Esta opção não tem efeito nos outros estimadores; de
qualquer modo não seria aplicada a correção de graus de liberdade.

Por omissão, a equação usada no cálculo dos elementos da matriz de
covariância das equações cruzadas é

  sigma(i,j) = u(i)' * u(j) / T

Se tiver sido dada a opção --geomean, a correção de graus de liberdade
será aplicada: a equação é

  sigma(i,j) = u(i)' * u(j) / sqrt((T - ki) * (T - kj))

onde os ks são o número de parâmetros independentes em cada equação.

Se tiver sido dada a opção --verbose e ter sido especificado um método
iterativo, serão mostrados os detalhes das iterações.

# fcast Prediction

Arguments:  [ observações-iniciais observações-finais ] [ passos-à-frente ] [ nome-de-variável ] 
Options:    --dynamic (criar predição dinâmica)
            --static (criar predição estática)
            --out-of-sample (gerar predição fora-da-amostra)
            --no-stats (não mostrar estatísticas de predição)
            --quiet (não mostrar nada)
            --rolling (ver abaixo)
            --plot[=nome-de-ficheiro] (ver abaixo)
Examples:   fcast 1997:1 2001:4 f1
            fcast fit2
            fcast 2004:1 2008:3 4 rfcast --rolling

Tem que se seguir a um comando de estimação. A predições são geradas
para um certo intervalo de observações: se tiverem sido dados
observações-iniciais e observações-finais, para esse intervalo (se
possível); caso contrário se a opção --out-of-sample tiver sido dada,
para observações a seguir ao intervalo onde o modelo foi estimado; caso
contrário pelo intervalo de amostragem corrente. Se uma predição
fora-da-amostra for pedida mas não haja observações relevantes, será
assinalado um erro. Dependendo da natureza do modelo, poderão ser gerados
erros padrão; ver abaixo. Ver também abaixo o efeito especial da opção
--rolling.

Se o último modelo estimado é de uma única equação, então o argumento
opcional nome-de-variável tem o seguinte efeito: o valores preditos não
são mostrado, mas guardados dentro do conjunto de dados no nome fornecido.
Se o último modelo estimado é um sistema de equações, nome-de-variável
tem um efeito diverente, nomeadamente a seleção de uma variável endógena
específica para a predição (por omissão são produzidas predições para
todas as variáveis endógenas). No caso do sistema, ou se não tiver sido
dado o nome-de-variável, os valores de predição podem ser obtidos usando
o acessor $fcast, e os erros padrão, se disponíveis, pelo $fcerr.

A escolha entre predições estáticas ou dinâmicas aplica-se apenas no
caso de modelos dinâmicos, com processamento autoregressivo de erros ou que
incluam um ou mais valores desfasados da variável dependente como
regressores. As predições estáticas são um passo à frente, baseadas em
valores concretizados no período anterior, enquanto que as predições
dinâmicas usam a regra de encadeamento de predição. Por exemplo, se uma
predição de y em 2008 requer como entrada um valor de y em 2007, uma
predição estática é impossível sem dados reais para 2007. Uma
predição dinâmica para 2008 é possível se uma predição anterior poder
ser substítuida no y em 2007.

Por omissão o normal é produzir uma predição estática para alguma parte
do intervalo de predição que abrange o intervalo da amostra onde o modelo
foi estimado, e uma predição dinâmica (se relevante) para
fora-da-amostra. A opção dynamic chama uma predição dinâmica a partir
da date mais cedo possível, e a opção --static chama uma predição
estática até para fora-da-amosta.

A opção --rolling está atualmente apenas disponível para modelos de um
única equação estimados por Mínimos Quadrados (OLS). Quando esta opção
é dada as predições são recursivas. Isto é, cada predição é gerada a
partir de uma estimativa do modelo dado usando dados de uma ponto de partida
fixo (nomeadamente, a partir do início do intervalo da amostra da
estimação original) até à data de predição menos k, onde k é o
número de passos à frente que têm que ser dados no argumento
passos-à-frente. As predições serão sempre dinâmicas se isso for
aplicável. Note que o argumento passos-à-frente deve ser dado apenas em
conjunto com a opção --rolling.

A opção --plot (disponível apenas no caso de estimação de equação
única) invoca a produção de um ficheiro de gráfico, que contém a
representação gráfica da predição. Quando não é dado o parâmetro
nome-de-ficheiro, gretl escreve os comandos gnuplot para um ficheiro com
nomes do tipo gpttmp01.plt na diretoria de trabalho de gretl do utilizador
(com o número incrementado em gráficos sucessivos). Se o nome-de-ficheiro
é acrescentado, a sua extensão é usada para determinar o tipo de ficheiro
a ser escrito (.eps para EPS, .pdf para PDF, ou .png para PNG; qualquer
outra extensão resulta num ficheiro de comandos gnuplot). Por exemplo,

	fcast --plot=fc.pdf

produzirá um gráfico em formato PDF. Serão respeitados caminhos completos
para ficheiros, senão os ficheiros são escritos na diretoria de trabalho
do gretl.

A natureza dos erros padrão de predição (se disponíveis) depende da
natureza do modelo e da predição. Para modelos lineares estáticos os
erros padrão são determinados usando o método traçado por Davidson e
MacKinnon (2004); eles incorporam tanto a incerteza devida aos processos de
erro como a incerteza dos parâmetros ( resumidos na matriz de covariância
das estimativas dos parâmetros). Para modelos dinâmicos, os erros padrão
de predição são apenas calculados no caso de uma predição dinâmica, e
eles não incorporam incerteza de parâmetros. Para modelos não-lineares,
os erros padrão de predição não estão disponíveis atualmente.

Menu path:    Janela de Modelo, /Análise/Predições...

# foreign Programming

Syntax:     foreign language=linguagem
Options:    --send-data (pré-carregar o conjunto de dados corrente; ver abaixo)
            --quiet (suprimir a saída do programa estrangeiro)

Este comando inicia um modo especial no qual se aceita os comandos a serem
executados por outro programa. Você sai deste modo com end foreign; onde
neste ponto são executados os comandos acumulados.

Presentemente são suportados três programas "estrangeiros", GNU R
(language=R), Ox de Jurgen Doornik (language=Ox) e GNU Octave
(language=Octave). Os nomes de linguagem são reconhecidos sem considerar
capitalização.

A opção --send-data é válida apenas quando em ligação com R e Octave;
tem o efeito de tornar o corrente conjunto de dados de gretl disponível
dentro do programa alvo, usando o nome gretldata.

Para detalhes e exemplos ver the Gretl User's Guide.

# fractint Statistics

Arguments:  série [ ordem ] 
Options:    --gph (fazer o teste de Geweke e Porter-Hudak)
            --all (fazer ambos os testes)
            --quiet (não mostrar resultados)

Testa a integração fracional sobre a série especificada ("memória
longa"). A hipótese nula é de que a ordem de integração da série é
zero. Por omissão é usado o estimador local de Whittle (Robinson, 1995)
mas se tiver sido dada a opção --gph será usado o teste GPH (Geweke e
Porter-Hudak, 1983). Se a opção --all for dada então serão mostrados os
resultados dos dois testes.

Para mais detalhes sobre este tipo de testes, ver Phillips e Shimotsu
(2004).

Se não tiver sido dado o argumento opcional ordem, a ordem para os teste(s)
é automaticamente definida como sendo o menor de T/2 e T^0.6.

Os resultados podem ser obtidos usando os acessores $test e $pvalue. Estes
valores baseiam-se no estimador local de Whittle exceto quando dada a
opção --gph.

Menu path:    /Variável/Testes de raiz unitária/Integração fracional

# freq Statistics

Argument:   variável 
Options:    --nbins=n (especificar o número de classes)
            --min=valor-mínimo (especificar o mínimo, ver abaixo)
            --binwidth=amplitude (especificar a amplitude das classes, ver abaixo)
            --quiet (não mostrar o gráfico)
            --normal (testar a distribuição normal)
            --gamma (testar a distribuição gama)
            --silent (não mostrar nada)
            --show-plot (ver abaixo)
            --matrix=nome (usar coluna da matriz indicada)
Examples:   freq x
            freq x --normal
            freq x --nbins=5
            freq x --min=0 --binwidth=0.10

Se não forem dadas opções, mostra a distribuição de frequência da
série variável (dada por nome ou por número), com o número de classes e
respetivo tamanho escolhidos automaticamente.

Se tiver sido dada a opção --matrix, a variável (que tem que ser um
inteiro) será interpretada com um índice de base 1 que selecciona a coluna
da matriz designada.

Para controlar a apresentação da distribuição você pode especificar
tanto o número de classes ou o valor mínimo e ainda a amplitude das
classes, tal como mostrado nos dois últimos exemplos acima. A opção --min
define o limite inferior da classe mais à esquerda.

Se a opção --normal tiver sido dada, será calculado o teste qui-quadrado
para a normalidade de Doornik-Hansen. Se a opção --gamma tiver sido dada,
o teste de normalidade será substituído pelo teste não paramétrico de
Locke para a hipótese nula de que a variável segue uma distribuição
gama; ver Locke (1976), Shapiro e Chen (2001). Note que a parametrização
da distribuição gama utilizadada em gretl é (forma, escala).

Em modo interactivo, por omissão é apresentado o gráfico da
distribuição. A opção --quiet pode ser usada para suprimir isto. Pelo
contrário, normalmente não é mostrado o gráfico quando se usa a opção
"freq" dentro de uma sequência-de-comandos, mas você pode forçar que seja
apresentado usando a opção --show-plot. (Isto não se aplica quando se usa
o programa em modo de linha-de-comandos, gretlcli.)

A opção --silent suprime toda a saída do programa. Isto apenas faz
sentido quando em conjunto com uma das opções de teste de distribuição:
a estatística de teste e o seu valor p ficam guardados e podem ser obtidos
usando os acessores $test e $pvalue.

Menu path:    /Variável/Distribuição de frequência

# function Programming

Argument:   nome-da-função 

Abre um bloco de declarações no qual é definida a função. Este bloco
tem que ser finalizado com end function. Para mais detalhes ver the Gretl
User's Guide.

# garch Estimation

Arguments:  p q ; variável-dependente [ variáveis-independentes ] 
Options:    --robust (erros padrão robustos)
            --verbose (mostrar detalhes das iterações)
            --vcv (mostrar a matriz de covariância)
            --nc (não incluir uma constante)
            --stdresid (normalizar os resíduos)
            --fcp (usar o algoritmo Fiorentini, Calzolari, Panattoni)
            --arma-init (parâmetros iniciais da variância a partir de ARMA)
Examples:   garch 1 1 ; y
            garch 1 1 ; y 0 x1 x2 --robust

Estima um modelo GARCH (GARCH = Autoregressivo Generalizado de
Heterocedastidade Condicional, "Generalized Autoregressive Conditional
Heteroskedasticity"), que pode ser um modelo univariado, ou multivariado se
especificadas as variáveis-independentes, incluindo as variáveis
exógenas. Os valores inteiros p e q (que podem ser dados na forma numérica
ou como nomes de variáveis escalares pré-existentes) representam as ordens
de desfasamento na equação de variância condicional:

  h(t) = a(0) + sum(i=1 to q) a(i)*u(t-i)^2 + sum(j=1 to p) b(j)*h(t-j)

Portanto, o parâmetro p representa a ordem Generalizada (ou "AR"), enquanto
q representa a ordem normal ARCH (ou "MA"). Se p for não-nulo, q tem
também que ser não-nulo senão o modelo fica não-identificado. No
entanto, você pode estimar um modelo ARCH normal ao definir q para um valor
positivo e p para zero. A soma de p e q não pode ser maior que 5. Note que
é automaticamente incluida uma constante na equação da média, exceto se
tiver sido dada a opção --nc.

Por omissão a estimação de modelos GARCH é feita usando código nativo
gretl, mas você também tem a possibilidade de usar o algoritmo de
Fiorentini, Calzolari e Panattoni (1996). O primeiro usa o maximizador BFGS
enquanto o segundo usa a matriz de informação para maximizar a
verosimilhança, com aperfeiçoamento por via da Hessiana.

Para este comando estão disponíveis diferentes estimadores da matriz de
covariância. Por omissão, usa-se a Hessiana, ou se a opção --robust
tiver sido dada, será usada a matriz de covariança QML (White). Outras
possibilidades podem ser especificadas usando o comando "set" (por exemplo a
matriz de informação, ou o estimador Bollerslev-Wooldridge ).

Por omissão, as estimativas dos parâmetros da variância são
inicializados usando a variância do erro incondicional da estimação OLS
inicial para a constante, e pequenos valores positivos para os coeficientes
dos valores anteriores do quadrado do erro e da variância do erro. A
opção --arma-init faz com que os valores iniciais destes parâmetros sejam
definidos usando inicialmente um modelo ARMA, explorando a relação entre
GARCH e ARMA demosntrado no Capítulo 21 do livro de Hamilton, Time Series
Analysis. Em alguns casos isto pode melhorar as possibilidades de
converência.

Os resíduos GARCH e a variância condicional estimada podem ser obtidos
como $uhat e $h respectivamente. Por exemplo, para obter a variância
condicional:

	genr ht = $h

Se a opção --stdresid tiver sido dada, os valores $uhat são divididos
pela raiz quadrada de h_t.

Menu path:    /Modelo/Série temporal/GARCH

# genr Dataset

Arguments:  nova-variável = expressão 

No contexto apropriado, o nomes; series, scalar e matrix são sinónimos
para este comando.

Cria novas variáveis, frequentemente a partir de transformações de
variáveis já existentes. Ver também os atalhos, "diff", "logs", "lags",
"ldiff", "sdiff" e "square". No contexto de uma expressão genr, as
variáveis existentes têm que ser referenciadas por nome e não por número
ID. A expressão deve ser uma combinação bem construída de nomes de
variáveis, constantes, operadores e funções (descrito adiante). Note que
detalhes adicionais sobre alguns aspetos deste comando podem ser encontrados
em the Gretl User's Guide.

Um comando genr pode resultar tanto num escalar como numa série. Por
exemplo, a expressão x2 = x * 2 naturalmente resulta numa série se a
variável x for uma série e num escalar se x for um escalar. As expressões
x = 0 e mx = mean(x) naturalmente retornam escalares. Em alguma
circusntâncias você poderá querer ter um resultado escalar expandido numa
série ou num vetor. Você pode fazer isso usando series como um "aliás"
para o comando genr. Por exemplo, series x = 0 produz uma série em que
todos os valores são 0. Você também pode usar scalar como sendo um aliás
para genr. Não é possível forçar um resultado do tipo vetor para um
escalar mas o uso desta palavra reservada indica que o resultado deve ser um
escalar: se não for ocorrerá um erro.

Quando uma expressão resulta numa série, o intervalo que será escrito na
variável destino depende do actual intervalo de amostragem. É assim
possível, definir uma série por troços usando o comando smpl conjugado
com genr.

Os operadores aritméticos suportados são, por ordem de precedência: ^
(potenciação); *, / e % (resto da divisão inteira); + e -.

Os operadores Booleanos são (mais uma vez, por ordem de precedência): !
(negação), && (E lógico), || (OU lógico), >, <, =, >= (maior ou igual),
<= (menor ou igual) e != (diferente). Os operadores Booleanos podem ser
usados na construção de variáveis auxiliares ('dummy'): por exemplo (x >
10) retorna 1 se x > 10, 0 caso contrário.

As constantes pré-definidas são pi e NA. Esta última representa um valor
omisso: você pode inicializar uma variável como tendo um valor omisso com
scalar x = NA.

O comando genr suporta uma larga gama de funções matemáticas e
estatísticas, incluindo, para além das usuais, várias que são
especialmente dedicadas à econometria. Adicionalmente oferece acesso a
numerosas variáveis internas que são definidas no decorrer das
regressões, testes de hipóteses e outros. Para uma lista de acessores,
escrever "help functions".

Para além dos operadores e funções mencionados acima, existem alguns usos
especiais de "genr":

  "genr time" cria uma variável de tendência temporal (1,2,3,...) com o
  nome "time". "genr index" faz a mesma coisa exceto em que o nome da
  variável é index.

  "genr dummy" cria variáveis auxiliares ('dummy') até à periodicidade
  dos dados. No caso de dados trimestrais (periodicidade 4), o programa cria
  dq1 = 1 para o primeiro trimestre 0 nos outros timestres, dq2 = 1 para o
  segundo trimestre e 0 para os outros trimestres, e por aí adiante. No
  caso de dados mensais as variáveis auxiliares têm os nomes dm1, dm2, e
  por aí adiante. No caso de outras frequências os nomes são dummy_1,
  dummy_2, etc.

  "genr unitdum" e "genr timedum" criam conjuntos de variáveis auxiliares
  especiais para usar com dados de painel. O primeiro codifica para as
  seções-cruzadas e o segundo para os períodos temporais das
  observações.

Nota: No programa de linha-de-comandos, os comandos "genr" que obtenham
dados de modelo referem-se sempre ao modelo que foi estimado mais
recentemente. Isto também é válido para o programa em ambiente gráfico
(GUI), ao se usar "genr" na "consola gretl" ou ao introduzir uma expressão
usando "Definir nova variável" no menu Acrescentar na janela principal. No
entanto, no GUI, você tem a possibilidade de obter dados a partir de
qualquer modelo que esteja disponível numa janela (independentemente se é
ou não o modelo mais recente). Isso é feito no menu "Gravar" na janela do
modelo.

A variável especial obs serve como um índice das observações. Por
exemplo genr dum = (obs=15) irá gerar uma variável auxiliar que tem valor
1 para a observação 15 e 0 para as outras. Você também pode usar esta
variável para escolher certas observações por data ou nome. Por exemplo,
genr d = (obs>1986:4), genr d = (obs>"2008/04/01"), ou genr d = (obs="CA").
Se se usarem datas diárias ou etiquetas neste contexto, elas devem ser
indicadas dentro de aspas. Datas trimestrais ou mensais (com um dois-pontos)
podem ser usadas sem aspas. Note que no caso de dados de séries temporais
anuais, o ano não se distingue sintáticamente de um simples inteiro; como
tal, se você quiser comparar observações com obs por ano, você tem que
usar a função obsnum para converter o ano para um valor de índice
iniciado em 1, tal como em genr d = (obs>obsnum(1986)).

Valores escalares podem ser extraídos de uma série no contexto de uma
expressão genr, usando a sintaxe varname[obs]. O valor obs pode ser dado
por núnmero ou data. Exemplos: x[5], CPI[1996:01]. Para dados diários,
deve se usar a forma YYYY/MM/DD, por exemplo, ibm[1970/01/23].

Uma observação individual numa série pode ser modificado usando genr.
Para fazer isto, uma observação válida numérica ou de data, tem que ser
acrescentada dentro de parentesis rectos, ao nome da variável no lado
esquerdo da expressão. Por exemplo, genr x[3] = 30 ou genr x[1950:04] =
303.7.

  Expressão             Comentário
  -------                -------
  y = x1^3               x1 ao cubo
  y = ln((x1+x2)/x3)     
  z = x>y                z(t) = 1 if x(t) > y(t), caso contrário 0
  y = x(-2)              x desfasado 2 períodos
  y = x(+2)              x adiantado 2 períodos
  y = diff(x)            y(t) = x(t) - x(t-1)
  y = ldiff(x)           y(t) = log x(t) - log x(t-1), o rácio de crescimento 
                         instantâneo de x
  y = sort(x)            ordena x por ordem crescente e guarda em y
  y = dsort(x)           ordena x por ordem decrescente
  y = int(x)             guarda a parte inteira de x em y
  y = abs(x)             guarda os valores absolutos de x
  y = sum(x)             soma os valores de x excluíndo entradas NA de 
                         valores omissos
  y = cum(x)             acumulado: y(t) = a soma de s=1 a s=t de x(s) 
  aa = $ess              define aa igual ao Erro da Soma de Quadrados da 
                         última regressão
  x = $coeff(sqft)       obtém o coeficiente estimado da variável sqft da 
                         última regressão
  rho4 = $rho(4)         obtém o coeficiente autoregressivo de quarta-ordem 
                         do último modelo (assume um modelo ar)
  cvx1x2 = $vcv(x1, x2)  obtém a covariância estimada dos coeficientes das 
                         variáveis x1 e x2 do último modelo
  foo = uniform()        variável pseudo-aleatória uniforme no intervalo 0-1
  bar = 3 * normal()     variável pseudo-aleatória normal, mu = 0, sigma = 3
  samp = ok(x)           = 1 para observações onde x não está ausente.

Menu path:    /Acrescentar/Definir nova variável
Other access: Menu de contexto da janela principal

# gmm Estimation

Options:    --two-step (estimação em duas fases)
            --iterate (GMM iterado)
            --vcv (mostrar a matriz de covariância)
            --verbose (mostrar detalhes das iterações)
            --lbfgs (usar L-BFGS-B em vez do normal BFGS)

Faz estimação usando o Método dos Momentos Generalizado, 'Generalized
Method of Moments' (GMM) com o algoritmo BFGS (Broyden, Fletcher, Goldfarb,
Shanno). Você tem que especificar um ou mais comandos para a atualização
das quantidades relevantes (tipicamente os resíduos GMM), um ou mais
conjuntos das condições, uma matriz inicial dos pesos, e uma listagem dos
parâmetros a serem estimados, tudo entre os marcadores gmm e end gmm.
Quaisquer opções devem ser acrescentadas à linha end gmm .

Por favor veja mais detalhes sobre este comando em the Gretl User's Guide.
Aqui apenas ilustramos com um exemplo simples.

	gmm e = y - X*b
	  orthog e ; W
	  weights V
	  params b
	end gmm

No exemplo acima nós assumimos que y e X são matrizes, b é um vetor de
tamanho apropriado dos valores dos parâmetros, W é a matriz dos
instrumentos, e V é uma matriz adequada de pesos. A declaração

	orthog e ; W

indica que o vetor dos resíduos e é em princípio ortognal a cada um dos
instromentos que compõem as colunas de W.

Menu path:    /Modelo/GMM

# gnuplot Graphs

Arguments:  variáveis-y variável-x [ variável-auxiliar ] 
Options:    --with-lines[=especificação-de-variáveis] (usar linhas, e não pontos)
            --with-lp[=especificação-de-variáveis] (usar linhas e pontos)
            --with-impulses[=especificação-de-variáveis] (usar linhas verticais)
            --time-series (gráfico temporal)
            --suppress-fitted (não mostrar a linha ajustada)
            --single-yaxis (forçar o uso de apenas um eixo y)
            --linear-fit (mostrar o ajustamento por mínimos quadrados)
            --inverse-fit (mostrar o ajustamento inverso)
            --quadratic-fit (mostrar o ajustamento quadrático)
            --cubic-fit (mostrar o ajustamento cúbico)
            --loess-fit (mostrar o ajustamento loess)
            --semilog-fit (mostrar o ajustamento semilog)
            --dummy (ver abaixo)
            --matrix=nome (representar as colunas da matriz indicada)
            --output=nome-de-ficheiro (enviar a saída para o ficheiro especificado)
            --input=nome-de-ficheiro (obter entrada a partir do ficheiro especificado)
Examples:   gnuplot y1 y2 x
            gnuplot x --time-series --with-lines
            gnuplot wages educ gender --dummy
            gnuplot y1 y2 x --with-lines=y2

As variáveis na lista variáveis-y são representadas contra a variável-x.
Para um gráfico de série temporal você pode indicar tempo como sendo a
variável-x ou usar a opção --time-series.

Por omissão os dados são representados como pontos; isto pode ser alterado
com o uso de uma das opções --with-lines, --with-lp ou --with-impulses. Se
for representada mais que uma variável no eixo dos y, o efeito destas
opções pode ficar confinada a uma subconjunto de variáveis usando o
parâmetro especificação-de-variáveis. Isto deve tomar a forma de uma
lista separada por vírgulas dos nomes ou números das variáveis a serem
representadas por linhas ou impulsos respetivamente. O último exemplo
mostrado acima, mostra como fazer um gráfico de y1 e y2 contra x, de modo a
que y2 é representada por uma linha, mas y1 é por pontos.

Se a opção --dummy tiver sido indicada, terão que ser dadas exatamente
três variáveis: uma única variável y, uma variável x, e uma variável
variável-auxiliar, uma variável discreta. O efeito é o de representar as
variáveis-y contra variável-x com os pontos mostrados com diferentes cores
dependendo do valor da variável-auxiliar na respectiva observação.

Geralmente, as variáveis-y e variável-x referem-se a séries no conjunto
de dados corrente (tanto referenciadas por nome como por número ID). Mas se
o nome de uma matriz for indicado com a opção --matrix estes argumentos
(que têm que ser dados como valores numéricos) indicam indices de colunas
(iniciados em 1) para a matriz fornecida. Assim, por exemplo, se você
quiser um gráfico X-Y da coluna 2 da matriz M contra a coluna 1, você deve
usar:

	gnuplot 2 1 --matrix=M

Em modo interativo o gráfico é apresentado imediatamente. Em modo de
sequência de comandos o comportamento por omissão é o de criar um
ficheiro de comandos gnuplot na directoria de trabalho do utilizador, com um
nome seguindo o padrão gpttmpN.plt, iniciando com N = 01. Os gráficos
podem ser depois gerados usando o programa gnuplot (em MS Windows,
wgnuplot). Este comportamento pode ser modificado com o uso da opção
--output=nome-de-ficheiro. Esta opção controla o nome do ficheiro usado, e
ao mesmo tempo permite-lhe especificar um formato de saída de acordo com a
extensão de três letras no nome do ficheiro, sendo: .eps resultante na
produção de um ficheiro 'Encapsulated PostScript' (EPS); .pdf produz PDF;
.png produz no formato PNG, .emf em formato EMF ('Enhanced MetaFile'), .fig
no formato Xfig, e .svg para o formato SVG ('Scalable Vector Graphics'). Se
usado o nome de ficheiro "display" o gráfico é apresentado no écran tal
como em modo interativo. Se o nome de ficheiro tiver outra qualquer
extensão que não as mencionadas, será escrito um ficheiro de comandos
gnuplot.

As várias opções de "ajustamento" são aplicáveis apenas nos caso de
gráficos de dispersão bivariados e nos de uma única série-temporal. O
comportamento por omissão para um gráfico de dispersão é o de mostrar a
linha de ajustamento de mínimos quadrados se e só se o coeficiente do
declive fôr significativo num nível de 10 porcento. Se a opção
--suppress tiver sido dada, não será mostrada a linha ajustada. O
comportamento por omissão para um gráfico de série-temporal é o de não
mostrar a linha de ajustamento. Se a opção --linear fôr dada, a linha
mínimos quadrados será mostrada independentemente de ser significativa ou
não. As outras opções de ajustamento (--inverse, --quadratic, --cubic,
--loess e --semilog) produzem respetivamente um ajustamento inverso
(regressão de y sobre 1/x), um ajustamento quadrático, um ajustamento
cúbico, um ajustamento loess e um ajustamento semilog. Loess (também por
vezes chamado "lowess") é uma regressão robusta com pesos locais. Por
semilog, nós designamos uma regressão do logaritmo de y sobre x (ou
tempo); a linha ajustada representa o y esperado condicionalmente, obtido
por exponenciação.

Uma outra opção está disponível para este comando: a seguir às
especificações das variáveis a serem representadas e das opções (caso
hajam), você pode acrescentar comandos gnuplot para controlar a aparência
do gráfico (por exemplo, para definir o título e/ou as escalas dos eixos).
Estes comandos devem ser colocados dentro de chavetas, e cada comando
gnuplot tem que ser terminado com um ponto-e-vírgula. Um '\' pode ser usado
para continuar uma conjunto de comandos gnuplot por mais que uma linha. Aqui
está um exemplo da sintaxe:

{ set title 'O Meu Título'; set yrange [0:1000]; }

Menu path:    /Ver/Gráfico das variáveis
Other access: Menu de contexto na janela principal, botão de gráfico na barra de ferramentas

# graphpg Graphs

A "página dos gráficos" de sessão apenas funcionará se você tiver
instalado o sistema de produção de texto LaTeX, e puder gerar e visionar
documentos PDF ou PostScript.

Na janela de sessão por ícones, você pode arrastar até oito gráficos
para dentro de um ícone de página de gráficos. Quando você fizer
duplo-clique na página de gráficos (ou com o botão direito e selecionar
"Mostrar"), será produzida uma página com os gráficos selecionados e
apresentada no visionador adequado. A partir deste você poderá imprimir a
página.

Para limpar a página de gráficos, clicar com o botão direito no seu
ícone e selecionar "Limpar".

Note que em sistemas diferentes do MS Windows, você pode ter que ajustar as
definições dos programas usados para visionar documentos PDF ou
PostScript. Isso encontra-se dentro do separador "Programas" na janela de
diálogo das Preferências do gretl (a partir do menu Ferramentas da janela
principal).

Também é possível trabalhar com a página de gráficos a partir se
sequência de comandos, ou usando a consola (dentro do programa em ambiente
gráfico). São suportados os seguintes comandos e opções:

Para acrescentar um gráfico à página de gráficos, dê o comando graphpg
add depois de o ter gravado como um gráfico com nome, tal como

	grf1 <- gnuplot Y X
	graphpg add

Para ver a página de gráficos: graphpg show.

Para limpar a página de gráficos: graphpg free.

Para ajustar a escala da fonte usada na página de gráficos, use graphpg
fontscale escala, onde escala é um multiplicador (com o valor 1,0 por
omissão). Assim, para tornar a o fonte 50 porcento maior que a por inicial
você pode

	graphpg fontscale 1.5

Para chamar a impressão da página de gráficos para um ficheiro, use a
opção --output= mais um nome de ficheiro; o nome do ficheiro deverá ter o
sufixo ".pdf", ".ps" ou ".eps". Por exemplo:

	graphpg --output="meu_ficheiro.pdf"

Neste contexto, por omissão o resultado usa linhas coloridas; para usar
padrões ponto/traço em vez de cores, você pode acrescentar a opção
--monochrome.

# hausman Tests

Este teste apenas está disponível após e estimar um modelo de mínimos
quadrados (OLS) usando dados de painel (ver também "setobs"). Ele testa o
modelo de amostragem simples ("pooled") contra as alternativas principais,
os modelos de efeitos fixos e efeitos aleatórios.

O modelo de efeitos fixos permite variar a interseção da regressão ao
longo das unidades de seção cruzada. Uma estatística teste-F é
apresentada segundo a hipótese nula de que as interseções não diferem. O
modelo de efeitos aleatórios decompõe a variância dos resíduos em duas
partes, uma parte específica à unidade de seção cruzada e outra
específica para a observação em particular. (Este estimador pode ser
calculado apenas se o número de unidades de seção cruzada nos dados
exceder o número de parâmetros a serem estimados.) A estatística de teste
Breusch-Pagan LM, testa a hipótese nula de que o estimador mínimos
quadrados de amostragem ("pooled") é adequado em oposição ao da
alternativa de efeitos aleatórios.

O modelo mínimos quadrados de amostragem ("pooled") pode ser rejeitado
contra ambas as alternativas, efeitos fixos e efeitos aleatórios. Desde que
o erro específico por unidade ou por grupo seja não correlacionado com as
variáveis independentes, o estimador de efeitos aleatórios é mais
eficiente do que o estimador de efeitos fixos; caso contrário o estimador
de efeitos aleatórios é inconsistente e o estimador de efeitos fixos será
preferido. A hipótese nula para o teste de Hausman é de que o erro
específico de grupo não é tão correlacionado (e como tal o modelo de
efeitos aleatórios é preferível). Um valor p baixo para este teste conta
contra o modelo de efeitos aleatórios e a favor do modelo de efeitos fixos.

Menu path:    Janela do modelo, /Testes/Diagnósticos de Painel

# heckit Estimation

Arguments:  variável-dependente variáveis-independentes ; equação de seleção 
Options:    --quiet (suprimir a escrita de resultados)
            --robust (erros padrão QML)
            --two-step (efetuar estimação de dois passos)
            --vcv (mostrar a matriz de covariância)
            --verbose (mostrar saídas adicionais)
Example:    heckit y 0 x1 x2 ; ys 0 x3 x4
            See also heckit.inp

Seleção do modelo de tipo Heckman. Na especificação, a lista antes do
ponto-e-vírgula representa a equação do resultado. A variável dependente
na equação de seleção (ys no exemplo acima) tem que ser uma variável
binária.

Por omissão, os parâmetros são estimados por máxima verosimilhança. A
matriz de covariância dos parâmetros é calculada usando a inversão
negativa da Hessiana. Se for desejável a estimação, de dois passos, use a
opção --two-step. Neste caso, a matriz de covariância dos parâmetros da
equação resultante é adequadamente ajustada de acordo com Heckman (1979).

Repare que na estimação de Máxima Verosimilhança (ML) é usada uma
aproximação numérica da Hessiana; isto pode levar a inexatidões na
matriz de covariância estimada se a escala das variáveis explanatórias
for para alguns dos coeficientes estimados muito pequena em valor absoluto.
Este problema pode ser abordado em versões futuras; por agora, como
solução temporária, pode-se re-escalar a variável ou variáveis
explanatórias que estão a causar problemas.

Menu path:    /Modelo/Variável dependente limitada/Heckit...

# help Utilities

Variants:   help
            help functions
            help command
            help function
Option:     --func (select functions help)

If no arguments are given, prints a list of available commands. If the
single argument "functions" is given, prints a list of available functions
(see "genr").

help command describes command (e.g. help smpl). help function describes
function (e.g. help ldet). Some functions have the same names as related
commands (e.g. diff): in that case the default is to print help for the
command, but you can get help on the function by using the --func option.

Menu path:    /Help

# hsk Estimation

Arguments:  depvar indepvars 
Option:     --vcv (print covariance matrix)

This command is applicable where heteroskedasticity is present in the form
of an unknown function of the regressors which can be approximated by a
quadratic relationship. In that context it offers the possibility of
consistent standard errors and more efficient parameter estimates as
compared with OLS.

The procedure involves (a) OLS estimation of the model of interest, followed
by (b) an auxiliary regression to generate an estimate of the error
variance, then finally (c) weighted least squares, using as weight the
reciprocal of the estimated variance.

In the auxiliary regression (b) we regress the log of the squared residuals
from the first OLS on the original regressors and their squares. The log
transformation is performed to ensure that the estimated variances are
non-negative. Call the fitted values from this regression u^*. The weight
series for the final WLS is then formed as 1/exp(u^*).

Menu path:    /Model/Other linear models/Heteroskedasticity corrected

# hurst Statistics

Argument:   series 

Calculates the Hurst exponent (a measure of persistence or long memory) for
a time-series variable having at least 128 observations.

The Hurst exponent is discussed by Mandelbrot. In theoretical terms it is
the exponent, H, in the relationship

  RS(x) = an^H

where RS is the "rescaled range" of the variable x in samples of size n and
a is a constant. The rescaled range is the range (maximum minus minimum) of
the cumulated value or partial sum of x over the sample period (after
subtraction of the sample mean), divided by the sample standard deviation.

As a reference point, if x is white noise (zero mean, zero persistence) then
the range of its cumulated "wandering" (which forms a random walk), scaled
by the standard deviation, grows as the square root of the sample size,
giving an expected Hurst exponent of 0.5. Values of the exponent
significantly in excess of 0.5 indicate persistence, and values less than
0.5 indicate anti-persistence (negative autocorrelation). In principle the
exponent is bounded by 0 and 1, although in finite samples it is possible to
get an estimated exponent greater than 1.

In gretl, the exponent is estimated using binary sub-sampling: we start with
the entire data range, then the two halves of the range, then the four
quarters, and so on. For sample sizes smaller than the data range, the RS
value is the mean across the available samples. The exponent is then
estimated as the slope coefficient in a regression of the log of RS on the
log of sample size.

Menu path:    /Variable/Hurst exponent

# if Programming

Flow control for command execution. Three sorts of construction are
supported, as follows.

	# simple form
	if condition
	    commands
	endif

	# two branches
	if condition
	    commands1
	else
	    commands2
        endif

	# three or more branches
	if condition1
	    commands1
	elif condition2
	    commands2
	else
	    commands3
	endif

"condition" must be a Boolean expression, for the syntax of which see
"genr". More than one "elif" block may be included. In addition, if ...
endif blocks may be nested.

# include Programming

Argument:   filename 
Examples:   include myfile.inp
            include sols.gfn

Intended for use in a command script, primarily for including definitions of
functions. Executes the commands in filename then returns control to the
main script. To include a packaged function, be sure to include the filename
extension.

See also "run".

# info Dataset

Prints out any supplementary information stored with the current datafile.

Menu path:    /Data/Dataset info
Other access: Data browser windows

# intreg Estimation

Arguments:   minvar maxvar indepvars 
Options:    --quiet (suppress printing of results)
            --verbose (print details of iterations)
            --robust (robust standard errors)
            --cluster=clustvar (see "logit" for explanation)
Example:    intreg lo hi const x1 x2
            See also wtp.inp

Estimates an interval regression model. This model arises when the dependent
variable is imperfectly observed for some (possibly all) observations. In
other words, the data generating process is assumed to be

  y* = x b + u

but we only observe m <= y* <= M (the interval may be left- or
right-unbounded). Note that for some observations m may equal M. The
variables minvar and maxvar must contain NAs for left- and right-unbounded
observations, respectively.

The model is estimated by maximum likelihood, assuming normality of the
disturbance term.

By default, standard errors are computed using the negative inverse of the
Hessian. If the --robust flag is given, then QML or Huber-White standard
errors are calculated instead. In this case the estimated covariance matrix
is a "sandwich" of the inverse of the estimated Hessian and the outer
product of the gradient.

Menu path:    /Model/Limited dependent variable/Interval regression

# join Dataset

Arguments:  filename varname 
Options:    --data=column-name (see below)
            --filter=expression (see below)
            --ikey=inner-key (see below)
            --okey=outer-key (see below)
            --aggr=method (see below)
            --tkey=column-name,format-string (see below)

This command imports a data series from the source filename (which must be a
delimited text data file) under the name varname. For details please see the
Gretl User's Guide; here we just give a brief summary of the available
options.

The --data option can be used to specify the column heading of the data in
the source file, if this differs from the name by which the data should be
known in gretl.

The --filter option can be used to specify a criterion for filtering the
source data (that is, selecting a subset of observations).

The --ikey and --okey options can be used to specify a mapping between
observations in the current dataset and observations in the source data (for
example, individuals can be matched against the household to which they
belong).

The --aggr option is used when the mapping between observations in the
current dataset and the source is not one-to-one.

The --tkey option is applicable only when the current dataset has a
time-series structure. It can be used to specify the name of a column
containing dates to be matched to the dataset and/or the format in which
dates are represented in that column.

See also "append" for simpler joining operations.

# kalman Estimation

Options:    --cross (allow for cross-correlated disturbances)
            --diffuse (use diffuse initialization)

Opens a block of statements to set up a Kalman filter. This block should end
with the line end kalman, to which the options shown above may be appended.
The intervening lines specify the matrices that compose the filter. For
example,

	kalman 
	  obsy y
	  obsymat H
	  statemat F
	  statevar Q
	end kalman

Please see the Gretl User's Guide for details.

See also "kfilter", "ksimul", "ksmooth".

# kpss Tests

Arguments:  order varlist 
Options:    --trend (include a trend)
            --seasonals (include seasonal dummies)
            --verbose (print regression results)
            --quiet (suppress printing of results)
            --difference (use first difference of variable)
Examples:   kpss 8 y
            kpss 4 x1 --trend

For use of this command with panel data please see the final section in this
entry.

Computes the KPSS test (Kwiatkowski et al, Journal of Econometrics, 1992)
for stationarity, for each of the specified variables (or their first
difference, if the --difference option is selected). The null hypothesis is
that the variable in question is stationary, either around a level or, if
the --trend option is given, around a deterministic linear trend.

The order argument determines the size of the window used for Bartlett
smoothing. If the --verbose option is chosen the results of the auxiliary
regression are printed, along with the estimated variance of the random walk
component of the variable.

The critical values shown for the test statistic are based on the response
surfaces estimated by Sephton (Economics Letters, 1995), which are more
accurate for small samples than the values given in the original KPSS
article. When the test statistic lies between the 10 percent and 1 percent
critical values a p-value is shown; this is obtained by linear interpolation
and should not be taken too literally.

Panel data

When the kpss command is used with panel data, to produce a panel unit root
test, the applicable options and the results shown are somewhat different.
While you may give a list of variables for testing in the regular
time-series case, with panel data only one variable may be tested per
command. And the --verbose option has a different meaning: it produces a
brief account of the test for each individual time series (the default being
to show only the overall result).

When possible, the overall test (null hypothesis: the series in question is
stationary for all the panel units) is calculated using the method of Choi
(Journal of International Money and Finance, 2001). This is not always
straightforward, the difficulty being that while the Choi test is based on
the p-values of the tests on the individual series, we do not currently have
a means of calculating p-values for the KPSS test statistic; we must rely on
a few critical values.

If the test statistic for a given series falls between the 10 percent and 1
percent critical values, we are able to interpolate a p-value. But if the
test falls short of the 10 percent value, or exceeds the 1 percent value, we
cannot interpolate and can at best place a bound on the global Choi test. If
the individual test statistic falls short of the 10 percent value for some
units but exceeds the 1 percent value for others, we cannot even compute a
bound for the global test.

Menu path:    /Variable/Unit root tests/KPSS test

# labels Dataset

Variants:   labels [ varlist ]
            labels --to-file=filename
            labels --from-file=filename
            labels --delete

In the first form, prints out the informative labels (if present) for the
series in varlist, or for all series in the dataset if varlist is not
specified.

With the option --to-file, writes to the named file the labels for all
series in the dataset, one per line. If no labels are present an error is
flagged; if some series have labels and others do not, a blank line is
printed for series with no label.

With the option --from-file, reads the specified file (which should be plain
text) and assigns labels to the series in the dataset, reading one label per
line and taking blank lines to indicate blank labels.

The --delete option does what you'd expect: it removes all the series labels
from the dataset.

Menu path:    /Data/Variable labels

# lad Estimation

Arguments:  depvar indepvars 
Option:     --vcv (print covariance matrix)

Calculates a regression that minimizes the sum of the absolute deviations of
the observed from the fitted values of the dependent variable. Coefficient
estimates are derived using the Barrodale-Roberts simplex algorithm; a
warning is printed if the solution is not unique.

Standard errors are derived using the bootstrap procedure with 500 drawings.
The covariance matrix for the parameter estimates, printed when the --vcv
flag is given, is based on the same bootstrap.

Menu path:    /Model/Robust estimation/Least Absolute Deviation

# lags Transformations

Arguments:  [ order ; ] laglist 
Examples:   lags x y
            lags 12 ; x y

Creates new series which are lagged values of each of the series in varlist.
By default the number of lags created equals the periodicity of the data.
For example, if the periodicity is 4 (quarterly), the command "lags x"
creates

	x_1 = x(t-1)
	x_2 = x(t-2)
	x_3 = x(t-3)
	x_4 = x(t-4)

The number of lags created can be controlled by the optional first parameter
(which, if present, must be followed by a semicolon).

Menu path:    /Add/Lags of selected variables

# ldiff Transformations

Argument:   varlist 

The first difference of the natural log of each series in varlist is
obtained and the result stored in a new series with the prefix ld_. Thus
"ldiff x y" creates the new variables

	ld_x = log(x) - log(x(-1))
	ld_y = log(y) - log(y(-1))

Menu path:    /Add/Log differences of selected variables

# leverage Tests

Options:    --save (save variables)
            --quiet (don't print results)

Must follow an "ols" command. Calculates the leverage (h, which must lie in
the range 0 to 1) for each data point in the sample on which the previous
model was estimated. Displays the residual (u) for each observation along
with its leverage and a measure of its influence on the estimates, uh/(1 -
h). "Leverage points" for which the value of h exceeds 2k/n (where k is the
number of parameters being estimated and n is the sample size) are flagged
with an asterisk. For details on the concepts of leverage and influence see
Davidson and MacKinnon (1993), Chapter 2.

DFFITS values are also computed: these are "studentized residuals"
(predicted residuals divided by their standard errors) multiplied by
sqrt[h/(1 - h)]. For discussions of studentized residuals and DFFITS see
chapter 12 of Maddala's Introduction to Econometrics or Belsley, Kuh and
Welsch (1980).

Briefly, a "predicted residual" is the difference between the observed value
of the dependent variable at observation t, and the fitted value for
observation t obtained from a regression in which that observation is
omitted (or a dummy variable with value 1 for observation t alone has been
added); the studentized residual is obtained by dividing the predicted
residual by its standard error.

If the --save flag is given with this command, then the leverage, influence
and DFFITS values are added to the current data set. In that context the
--quiet flag may be used to suppress the printing of results.

After execution, the $test accessor returns the cross-validation criterion,
which is defined as the sum of squared deviations of the dependent variable
from its forecast value, the forecast for each observation being based on a
sample from which that observation is excluded. (This is known as the
leave-one-out estimator). For a broader discussion of the cross-validation
criterion, see Davidson and MacKinnon's Econometric Theory and Methods,
pages 685-686, and the references therein.

Menu path:    Model window, /Tests/Influential observations

# levinlin Tests

Arguments:  order series 
Options:    --nc (test without a constant)
            --ct (with constant and trend)
            --quiet (suppress printing of results)
Examples:   levinlin 0 y
            levinlin 2 y --ct
            levinlin {2,2,3,3,4,4} y

Carries out the panel unit-root test described by Levin, Lin and Chu (2002).
The null hypothesis is that all of the individual time series exhibit a unit
root, and the alternative is that none of the series has a unit root. (That
is, a common AR(1) coefficient is assumed, although in other respects the
statistical properties of the series are allowed to vary across
individuals.)

By default the test ADF regressions include a constant; to suppress the
constant use the --nc option, or to add a linear trend use the --ct option.
(See the "adf" command for explanation of ADF regressions.)

The (non-negative) order for the test (governing the number of lags of the
dependent variable to include in the ADF regressions) may be given in either
of two forms. If a scalar value is given, this is applied to all the
individuals in the panel. The alternative is to provide a matrix containing
a specific lag order for each individual; this must be a vector with as many
elements as there are individuals in the current sample range. Such a matrix
can be specified by name, or constructed using braces as illustrated in the
last example above.

Menu path:    /Variable/Unit root tests/Levin-Lin-Chu test

# logistic Estimation

Arguments:  depvar indepvars 
Options:    --ymax=value (specify maximum of dependent variable)
            --vcv (print covariance matrix)
Examples:   logistic y const x
            logistic y const x --ymax=50

Logistic regression: carries out an OLS regression using the logistic
transformation of the dependent variable,

  log(y/(y* - y))

The dependent variable must be strictly positive. If all its values lie
between 0 and 1, the default is to use a y^* value (the asymptotic maximum
of the dependent variable) of 1; if its values lie between 0 and 100, the
default y^* is 100.

If you wish to set a different maximum, use the --ymax option. Note that the
supplied value must be greater than all of the observed values of the
dependent variable.

The fitted values and residuals from the regression are automatically
transformed using

  y = y* / (1 + exp(-x))

where x represents either a fitted value or a residual from the OLS
regression using the transformed dependent variable. The reported values are
therefore comparable with the original dependent variable.

Note that if the dependent variable is binary, you should use the "logit"
command instead.

Menu path:    /Model/Limited dependent variable/Logistic

# logit Estimation

Arguments:  depvar indepvars 
Options:    --robust (robust standard errors)
            --cluster=clustvar (clustered standard errors)
            --multinomial (estimate multinomial logit)
            --vcv (print covariance matrix)
            --verbose (print details of iterations)
            --p-values (show p-values instead of slopes)

If the dependent variable is a binary variable (all values are 0 or 1)
maximum likelihood estimates of the coefficients on indepvars are obtained
via the Newton-Raphson method. As the model is nonlinear the slopes depend
on the values of the independent variables. By default the slopes with
respect to each of the independent variables are calculated (at the means of
those variables) and these slopes replace the usual p-values in the
regression output. This behavior can be suppressed my giving the --p-values
option. The chi-square statistic tests the null hypothesis that all
coefficients are zero apart from the constant.

By default, standard errors are computed using the negative inverse of the
Hessian. If the --robust flag is given, then QML or Huber-White standard
errors are calculated instead. In this case the estimated covariance matrix
is a "sandwich" of the inverse of the estimated Hessian and the outer
product of the gradient; see chapter 10 of Davidson and MacKinnon (2004).
But if the --cluster option is given, then "cluster-robust" standard errors
are produced; see the Gretl User's Guide for details.

If the dependent variable is not binary but is discrete, then by default it
is interpreted as an ordinal response, and Ordered Logit estimates are
obtained. However, if the --multinomial option is given, the dependent
variable is interpreted as an unordered response, and Multinomial Logit
estimates are produced. (In either case, if the variable selected as
dependent is not discrete an error is flagged.) In the multinomial case, the
accessor $mnlprobs is available after estimation, to get a matrix containing
the estimated probabilities of the outcomes at each observation
(observations in rows, outcomes in columns).

If you want to use logit for analysis of proportions (where the dependent
variable is the proportion of cases having a certain characteristic, at each
observation, rather than a 1 or 0 variable indicating whether the
characteristic is present or not) you should not use the "logit" command,
but rather construct the logit variable, as in

	series lgt_p = log(p/(1 - p))

and use this as the dependent variable in an OLS regression. See chapter 12
of Ramanathan (2002).

Menu path:    /Model/Limited dependent variable/Logit

# logs Transformations

Argument:   varlist 

The natural log of each of the series in varlist is obtained and the result
stored in a new series with the prefix l_ ("el" underscore). For example,
"logs x y" creates the new variables l_x = ln(x) and l_y = ln(y).

Menu path:    /Add/Logs of selected variables

# loop Programming

Argument:   control 
Options:    --progressive (enable special forms of certain commands)
            --verbose (report details of genr commands)
            --quiet (do not report number of iterations performed)
Examples:   loop 1000
            loop 1000 --progressive
            loop while essdiff > .00001
            loop i=1991..2000
            loop for (r=-.99; r<=.99; r+=.01)
            loop foreach i xlist

This command opens a special mode in which the program accepts commands to
be executed repeatedly. You exit the mode of entering loop commands with
"endloop": at this point the stacked commands are executed.

The parameter "control" may take any of five forms, as shown in the
examples: an integer number of times to repeat the commands within the loop;
"while" plus a boolean condition; a range of integer values for index
variable; "for" plus three expressions in parentheses, separated by
semicolons (which emulates the for statement in the C programming language);
or "foreach" plus an index variable and a list.

See the Gretl User's Guide for further details and examples. The effect of
the --progressive option (which is designed for use in Monte Carlo
simulations) is explained there. Not all gretl commands may be used within a
loop; the commands available in this context are also set out there.

# mahal Statistics

Argument:   varlist 
Options:    --quiet (don't print anything)
            --save (add distances to the dataset)
            --vcv (print covariance matrix)

Computes the Mahalanobis distances between the series in varlist. The
Mahalanobis distance is the distance between two points in a k-dimensional
space, scaled by the statistical variation in each dimension of the space.
For example, if p and q are two observations on a set of k variables with
covariance matrix C, then the Mahalanobis distance between the observations
is given by

  sqrt((p - q)' * C-inverse * (p - q))

where (p - q) is a k-vector. This reduces to Euclidean distance if the
covariance matrix is the identity matrix.

The space for which distances are computed is defined by the selected
variables. For each observation in the current sample range, the distance is
computed between the observation and the centroid of the selected variables.
This distance is the multidimensional counterpart of a standard z-score, and
can be used to judge whether a given observation "belongs" with a group of
other observations.

If the --vcv option is given, the covariance matrix and its inverse are
printed. If the --save option is given, the distances are saved to the
dataset under the name mdist (or mdist1, mdist2 and so on if there is
already a variable of that name).

Menu path:    /View/Mahalanobis distances

# makepkg Programming

Argument:   filename 
Options:    --index (write auxiliary index file)
            --translations (write auxiliary strings file)

Supports creation of a gretl function package via the command line. The
filename argument represents the name of the package to be created, and
should have the .gfn extension. Please see the Gretl User's Guide for
details.

The option flags support the writing of auxiliary files for use with gretl
"addons". The index file is a short XML document containing basic
information about the package; it has the same basename as the package and
the extension .xml. The translations file contains strings from the package
that may be suitable for translation, in C format; for package foo this file
is named foo-i18n.c.

Menu path:    /Tools/Function packages/New package

# markers Dataset

Variants:   markers --to-file=filename
            markers --from-file=filename
            markers --delete

With the option --to-file, writes to the named file the observation marker
strings from the current dataset, one per line. If no such strings are
present an error is flagged.

With the option --from-file, reads the specified file (which should be plain
text) and assigns observation markers to the rows in the dataset, reading
one marker per line. In general there should be at least as many markers in
the file as observations in the dataset, but if the dataset is a panel it is
also acceptable if the number of markers in the file matches the number of
cross-sectional units (in which case the markers are repeated for each time
period.)

The --delete option does what you'd expect: it removes the observation
marker strings from the dataset.

Menu path:    /Data/Observation markers

# meantest Tests

Arguments:  series1 series2 
Option:     --unequal-vars (assume variances are unequal)

Calculates the t statistic for the null hypothesis that the population means
are equal for the variables series1 and series2, and shows its p-value.

By default the test statistic is calculated on the assumption that the
variances are equal for the two variables; with the --unequal-vars option
the variances are assumed to be different. This will make a difference to
the test statistic only if there are different numbers of non-missing
observations for the two series.

Menu path:    /Tools/Test statistic calculator

# mle Estimation

Arguments:  log-likelihood function [ derivatives ] 
Options:    --quiet (don't show estimated model)
            --vcv (print covariance matrix)
            --hessian (base covariance matrix on the Hessian)
            --robust (QML covariance matrix)
            --verbose (print details of iterations)
            --no-gradient-check (see below)
            --lbfgs (use L-BFGS-B instead of regular BFGS)
Example:    weibull.inp

Performs Maximum Likelihood (ML) estimation using either the BFGS (Broyden,
Fletcher, Goldfarb, Shanno) algorithm or Newton's method. The user must
specify the log-likelihood function. The parameters of this function must be
declared and given starting values (using the "genr" command) prior to
estimation. Optionally, the user may specify the derivatives of the
log-likelihood function with respect to each of the parameters; if
analytical derivatives are not supplied, a numerical approximation is
computed.

Simple example: Suppose we have a series X with values 0 or 1 and we wish to
obtain the maximum likelihood estimate of the probability, p, that X = 1.
(In this simple case we can guess in advance that the ML estimate of p will
simply equal the proportion of Xs equal to 1 in the sample.)

The parameter p must first be added to the dataset and given an initial
value. For example, scalar p = 0.5.

We then construct the MLE command block:

	mle loglik = X*log(p) + (1-X)*log(1-p)
	  deriv p = X/p - (1-X)/(1-p)
	end mle

The first line above specifies the log-likelihood function. It starts with
the keyword mle, then a dependent variable is specified and an expression
for the log-likelihood is given (using the same syntax as in the "genr"
command). The next line (which is optional) starts with the keyword deriv
and supplies the derivative of the log-likelihood function with respect to
the parameter p. If no derivatives are given, you should include a statement
using the keyword params which identifies the free parameters: these are
listed on one line, separated by spaces and can be either scalars, or
vectors, or any combination of the two. For example, the above could be
changed to:

	mle loglik = X*log(p) + (1-X)*log(1-p)
	  params p
	end mle

in which case numerical derivatives would be used.

Note that any option flags should be appended to the ending line of the MLE
block.

By default, estimated standard errors are based on the Outer Product of the
Gradient. If the --hessian option is given, they are instead based on the
negative inverse of the Hessian (which is approximated numerically). If the
--robust option is given, a QML estimator is used (namely, a sandwich of the
negative inverse of the Hessian and the covariance matrix of the gradient).

If you supply analytical derivatives, by default gretl runs a numerical
check on their plausibility. Occasionally this may produce false positives,
instances where correct derivatives appear to be wrong and estimation is
refused. To counter this, or to achieve a little extra speed, you can give
the option --no-gradient-check. Obviously, you should do this only if you
are quite confident that the gradient you have specified is right.

For a much more in-depth description of "mle", please refer to the Gretl
User's Guide.

Menu path:    /Model/Maximum likelihood

# modeltab Utilities

Variants:   modeltab add
            modeltab show
            modeltab free
            modeltab --output=filename

Manipulates the gretl "model table". See the Gretl User's Guide for details.
The sub-commands have the following effects: "add" adds the last model
estimated to the model table, if possible; "show" displays the model table
in a window; and "free" clears the table.

To call for printing of the model table, use the flag --output= plus a
filename. If the filename has the suffix ".tex", the output will be in TeX
format; if the suffix is ".rtf" the output will be RTF; otherwise it will be
plain text. In the case of TeX output the default is to produce a
"fragment", suitable for inclusion in a document; if you want a stand-alone
document instead, use the --complete option, for example

	modeltab --output="myfile.tex" --complete

Menu path:    Session icon window, Model table icon

# modprint Printing

Arguments:  coeffmat names [ addstats ] 

Prints the coefficient table and optional additional statistics for a model
estimated "by hand". Mainly useful for user-written functions.

The argument coeffmat should be a k by 2 matrix containing k coefficients
and k associated standard errors, and names should be a string containing at
least k names for the coefficients, separated by commas or spaces. (The
names argument may be either the name of a string variable or a literal
string, enclosed in double quotes.)

The optional argument addstats is a vector containing p additional
statistics to be printed under the coefficient table. If this argument is
given, then names should contain k + p comma-separated strings, the
additional p strings to be associated with the additional statistics.

# modtest Tests

Argument:   [ order ] 
Options:    --normality (normality of residual)
            --logs (non-linearity, logs)
            --autocorr (serial correlation)
            --arch (ARCH)
            --squares (non-linearity, squares)
            --white (heteroskedasticity, White's test)
            --white-nocross (White's test, squares only)
            --breusch-pagan (heteroskedasticity, Breusch-Pagan)
            --robust (robust variance estimate for Breusch-Pagan)
            --panel (heteroskedasticity, groupwise)
            --comfac (common factor restriction, AR1 models only)
            --quiet (don't print details)

Must immediately follow an estimation command. Depending on the option
given, this command carries out one of the following: the Doornik-Hansen
test for the normality of the error term; a Lagrange Multiplier test for
nonlinearity (logs or squares); White's test (with or without
cross-products) or the Breusch-Pagan test (Breusch and Pagan, 1979) for
heteroskedasticity; the LMF test for serial correlation (Kiviet, 1986); a
test for ARCH (Autoregressive Conditional Heteroskedasticity; see also the
"arch" command); or a test of the common factor restriction implied by AR(1)
estimation. With the exception of the normality and common factor test most
of the options are only available for models estimated via OLS, but see
below for details regarding two-stage least squares.

The optional order argument is relevant only in case the --autocorr or
--arch options are selected. The default is to run these tests using a lag
order equal to the periodicity of the data, but this can be adjusted by
supplying a specific lag order.

The --robust option applies only when the Breusch-Pagan test is selected;
its effect is to use the robust variance estimator proposed by Koenker
(1981), making the test less sensitive to the assumption of normality.

The --panel option is available only when the model is estimated on panel
data: in this case a test for groupwise heteroskedasticity is performed
(that is, for a differing error variance across the cross-sectional units).

The --comfac option is available only when the model is estimated via an
AR(1) method such as Hildreth-Lu. The auxiliary regression takes the form of
a relatively unrestricted dynamic model, which is used to test the common
factor restriction implicit in the AR(1) specification.

By default, the program prints the auxiliary regression on which the test
statistic is based, where applicable. This may be suppressed by using the
--quiet flag. The test statistic and its p-value may be retrieved using the
accessors $test and $pvalue respectively.

When a model has been estimated by two-stage least squares (see "tsls"), the
LM principle breaks down and gretl offers some equivalents: the --autocorr
option computes Godfrey's test for autocorrelation (Godfrey, 1994) while the
--white option yields the HET1 heteroskedasticity test (Pesaran and Taylor,
1999).

Menu path:    Model window, /Tests

# mpols Estimation

Arguments:  depvar indepvars 
Options:    --vcv (print covariance matrix)
            --simple-print (do not print auxiliary statistics)
            --quiet (suppress printing of results)

Computes OLS estimates for the specified model using multiple precision
floating-point arithmetic, with the help of the Gnu Multiple Precision (GMP)
library. By default 256 bits of precision are used for the calculations, but
this can be increased via the environment variable GRETL_MP_BITS. For
example, when using the bash shell one could issue the following command,
before starting gretl, to set a precision of 1024 bits.

	export GRETL_MP_BITS=1024

A rather arcane option is available for this command (primarily for testing
purposes): if the indepvars list is followed by a semicolon and a further
list of numbers, those numbers are taken as powers of x to be added to the
regression, where x is the last variable in indepvars. These additional
terms are computed and stored in multiple precision. In the following
example y is regressed on x and the second, third and fourth powers of x:

	mpols y 0 x ; 2 3 4

Menu path:    /Model/Other linear models/High precision OLS

# negbin Estimation

Arguments:  depvar indepvars [ ; offset ] 
Options:    --model1 (use NegBin 1 model)
            --robust (QML covariance matrix)
            --cluster=clustvar (see "logit" for explanation)
            --opg (see below)
            --vcv (print covariance matrix)
            --verbose (print details of iterations)

Estimates a Negative Binomial model. The dependent variable is taken to
represent a count of the occurrence of events of some sort, and must have
only non-negative integer values. By default the model NegBin 2 is used, in
which the conditional variance of the count is given by mu(1 + αmu), where
mu denotes the conditional mean. But if the --model1 option is given the
conditional variance is mu(1 + α).

The optional offset series works in the same way as for the "poisson"
command. The Poisson model is a restricted form of the Negative Binomial in
which α = 0 by construction.

By default, standard errors are computed using a numerical approximation to
the Hessian at convergence. But if the --opg option is given the covariance
matrix is based on the Outer Product of the Gradient (OPG), or if the
--robust option is given QML standard errors are calculated, using a
"sandwich" of the inverse of the Hessian and the OPG.

Menu path:    /Model/Limited dependent variable/Count data...

# nls Estimation

Arguments:  function [ derivatives ] 
Options:    --quiet (don't show estimated model)
            --robust (robust standard errors)
            --vcv (print covariance matrix)
            --verbose (print details of iterations)
Example:    wg_nls.inp

Performs Nonlinear Least Squares (NLS) estimation using a modified version
of the Levenberg-Marquardt algorithm. You must supply a function
specification. The parameters of this function must be declared and given
starting values (using the "genr" command) prior to estimation. Optionally,
you may specify the derivatives of the regression function with respect to
each of the parameters. If you do not supply derivatives you should instead
give a list of the parameters to be estimated (separated by spaces or
commas), preceded by the keyword params. In the latter case a numerical
approximation to the Jacobian is computed.

It is easiest to show what is required by example. The following is a
complete script to estimate the nonlinear consumption function set out in
William Greene's Econometric Analysis (Chapter 11 of the 4th edition, or
Chapter 9 of the 5th). The numbers to the left of the lines are for
reference and are not part of the commands. Note that any option flags, such
as --vcv for printing the covariance matrix of the parameter estimates,
should be appended to the final command, end nls.

	1   open greene11_3.gdt
	2   ols C 0 Y
	3   scalar a = $coeff(0)
	4   scalar b = $coeff(Y)
	5   scalar g = 1.0
	6   nls C = a + b * Y^g
	7    deriv a = 1
	8    deriv b = Y^g
	9    deriv g = b * Y^g * log(Y)
	10  end nls --vcv

It is often convenient to initialize the parameters by reference to a
related linear model; that is accomplished here on lines 2 to 5. The
parameters alpha, beta and gamma could be set to any initial values (not
necessarily based on a model estimated with OLS), although convergence of
the NLS procedure is not guaranteed for an arbitrary starting point.

The actual NLS commands occupy lines 6 to 10. On line 6 the "nls" command is
given: a dependent variable is specified, followed by an equals sign,
followed by a function specification. The syntax for the expression on the
right is the same as that for the "genr" command. The next three lines
specify the derivatives of the regression function with respect to each of
the parameters in turn. Each line begins with the keyword "deriv", gives the
name of a parameter, an equals sign, and an expression whereby the
derivative can be calculated (again, the syntax here is the same as for
"genr"). As an alternative to supplying numerical derivatives, you could
substitute the following for lines 7 to 9:

	params a b g

Line 10, "end nls", completes the command and calls for estimation. Any
options should be appended to this line.

For further details on NLS estimation please see the Gretl User's Guide.

Menu path:    /Model/Nonlinear Least Squares

# normtest Tests

Argument:   series 
Options:    --dhansen (Doornik-Hansen test, the default)
            --swilk (Shapiro-Wilk test)
            --lillie (Lilliefors test)
            --jbera (Jarque-Bera test)
            --all (do all tests)
            --quiet (suppress printed output)

Carries out a test for normality for the given series. The specific test is
controlled by the option flags (but if no flag is given, the Doornik-Hansen
test is performed). Note: the Doornik-Hansen and Shapiro-Wilk tests are
recommended over the others, on account of their superior small-sample
properties.

The test statistic and its p-value may be retrieved using the accessors
$test and $pvalue. Please note that if the --all option is given, the result
recorded is that from the Doornik-Hansen test.

Menu path:    /Variable/Normality test

# nulldata Dataset

Argument:   series_length 
Option:     --preserve (preserve matrices)
Example:    nulldata 500

Establishes a "blank" data set, containing only a constant and an index
variable, with periodicity 1 and the specified number of observations. This
may be used for simulation purposes: some of the "genr" commands (e.g. "genr
uniform()", "genr normal()") will generate dummy data from scratch to fill
out the data set. This command may be useful in conjunction with "loop". See
also the "seed" option to the "set" command.

By default, this command cleans out all data in gretl's current workspace.
If you give the --preserve option, however, any currently defined matrices
are retained.

Menu path:    /File/New data set

# ols Estimation

Arguments:  depvar indepvars 
Options:    --vcv (print covariance matrix)
            --robust (robust standard errors)
            --cluster=clustvar (clustered standard errors)
            --jackknife (see below)
            --simple-print (do not print auxiliary statistics)
            --quiet (suppress printing of results)
            --anova (print an ANOVA table)
            --no-df-corr (suppress degrees of freedom correction)
            --print-final (see below)
Examples:   ols 1 0 2 4 6 7
            ols y 0 x1 x2 x3 --vcv
            ols y 0 x1 x2 x3 --quiet

Computes ordinary least squares (OLS) estimates with depvar as the dependent
variable and indepvars as the list of independent variables. Variables may
be specified by name or number; use the number zero for a constant term.

Besides coefficient estimates and standard errors, the program also prints
p-values for t (two-tailed) and F-statistics. A p-value below 0.01 indicates
statistical significance at the 1 percent level and is marked with ***. **
indicates significance between 1 and 5 percent and * indicates significance
between the 5 and 10 percent levels. Model selection statistics (the Akaike
Information Criterion or AIC and Schwarz's Bayesian Information Criterion)
are also printed. The formula used for the AIC is that given by Akaike
(1974), namely minus two times the maximized log-likelihood plus two times
the number of parameters estimated.

If the option --no-df-corr is given, the usual degrees of freedom correction
is not applied when calculating the estimated error variance (and hence also
the standard errors of the parameter estimates).

The option --print-final is applicable only in the context of a "loop". It
arranges for the regression to be run silently on all but the final
iteration of the loop. See the Gretl User's Guide for details.

Various internal variables may be retrieved following estimation. For
example

	series uh = $uhat

saves the residuals under the name uh. See the "accessors" section of the
gretl function reference for details.

The specific formula ("HC" version) used for generating robust standard
errors when the --robust option is given can be adjusted via the "set"
command. The --jackknife option has the effect of selecting an hc_version of
3a. The --cluster overrides the selection of HC version, and produces robust
standard errors by grouping the observations by the distinct values of
clustvar; see the Gretl User's Guide for details.

Menu path:    /Model/Ordinary Least Squares
Other access: Beta-hat button on toolbar

# omit Tests

Argument:   varlist 
Options:    --test-only (don't replace the current model)
            --chi-square (give chi-square form of Wald test)
            --quiet (print only the basic test result)
            --silent (don't print anything)
            --vcv (print covariance matrix for reduced model)
            --auto[=alpha] (sequential elimination, see below)
Examples:   omit 5 7 9
            omit seasonals --quiet
            omit --auto
            omit --auto=0.05

This command must follow an estimation command. It calculates a Wald test
for the joint significance of the variables in varlist, which should be a
subset of the independent variables in the model last estimated. The results
of the test may be retrieved using the accessors $test and $pvalue.

By default the restricted model is estimated and it replaces the original as
the "current model" for the purposes of, for example, retrieving the
residuals as $uhat or doing further tests. This behavior may be suppressed
via the --test-only option.

By default the F-form of the Wald test is recorded; the --chi-square option
may be used to record the chi-square form instead.

If the restricted model is both estimated and printed, the --vcv option has
the effect of printing its covariance matrix, otherwise this option is
ignored.

Alternatively, if the --auto flag is given, sequential elimination is
performed: at each step the variable with the highest p-value is omitted,
until all remaining variables have a p-value no greater than some cutoff.
The default cutoff is 10 percent (two-sided); this can be adjusted by
appending "=" and a value between 0 and 1 (with no spaces), as in the fourth
example above. If varlist is given this process is confined to the listed
variables, otherwise all variables are treated as candidates for omission.
Note that the --auto and --test-only options cannot be combined.

Menu path:    Model window, /Tests/Omit variables

# open Dataset

Argument:   filename 
Options:    --quiet (don't print list of series)
            --preserve (preserve any matrices and scalars)
            --www (use a database on the gretl server)
            See below for additional specialized options
Examples:   open data4-1
            open voter.dta
            open fedbog --www

Opens a data file. If a data file is already open, it is replaced by the
newly opened one. To add data to the current dataset, see "append" and (for
greater flexibility) "join".

If a full path is not given, the program will search some relevant paths to
try to find the file. If no filename suffix is given (as in the first
example above), gretl assumes a native datafile with suffix .gdt. Based on
the name of the file and various heuristics, gretl will try to detect the
format of the data file (native, plain text, CSV, MS Excel, Stata, SPSS,
etc.).

If the filename argument takes the form of a URI starting with http://, then
gretl will attempt to download the indicated data file before opening it.

By default, opening a new data file clears the current gretl session, which
includes deletion of any named matrices and scalars. If you wish to keep any
currently defined matrices and scalars, use the --preserve option.

The open command can also be used to open a database (gretl, RATS 4.0 or
PcGive) for reading. In that case it should be followed by the "data"
command to extract particular series from the database. If the www option is
given, the program will try to access a database of the given name on the
gretl server -- for instance the Federal Reserve interest rates database in
the third example above.

When opening a spreadsheet file (Gnumeric, Open Document or MS Excel), you
may give up to three additional parameters following the filename. First,
you can select a particular worksheet within the file. This is done either
by giving its (1-based) number, using the syntax, e.g., --sheet=2, or, if
you know the name of the sheet, by giving the name in double quotes, as in
--sheet="MacroData". The default is to read the first worksheet. You can
also specify a column and/or row offset into the worksheet via, e.g.,

	--coloffset=3 --rowoffset=2

which would cause gretl to ignore the first 3 columns and the first 2 rows.
The default is an offset of 0 in both dimensions, that is, to start reading
at the top-left cell.

With plain text files, gretl generally expects to find the data columns
delimited in some standard manner. But there is also a special facility for
reading "fixed format" files, in which there are no delimiters but there is
a known specification of the form, e.g., "variable k occupies 8 columns
starting at column 24". To read such files, you should append a string
--fixed-cols=colspec, where colspec is composed of comma-separated integers.
These integers are interpreted as a set of pairs. The first element of each
pair denotes a starting column, measured in bytes from the beginning of the
line with 1 indicating the first byte; and the second element indicates how
many bytes should be read for the given field. So, for example, if you say

	open fixed.txt --fixed-cols=1,6,20,3

then for variable 1 gretl will read 6 bytes starting at column 1; and for
variable 2, 3 bytes starting at column 20. Lines that are blank, or that
begin with #, are ignored, but otherwise the column-reading template is
applied, and if anything other than a valid numerical value is found an
error is flagged. If the data are read successfully, the variables will be
named v1, v2, etc. It's up to the user to provide meaningful names and/or
descriptions using the commands "rename" and/or "setinfo".

Menu path:    /File/Open data
Other access: Drag a data file into gretl (MS Windows or Gnome)

# orthdev Transformations

Argument:   varlist 

Applicable with panel data only. A series of forward orthogonal deviations
is obtained for each variable in varlist and stored in a new variable with
the prefix o_. Thus "orthdev x y" creates the new variables o_x and o_y.

The values are stored one step ahead of their true temporal location (that
is, o_x at observation t holds the deviation that, strictly speaking,
belongs at t - 1). This is for compatibility with first differences: one
loses the first observation in each time series, not the last.

# outfile Printing

Variants:   outfile filename option
            outfile --close
Options:    --append (append to file)
            --write (overwrite file)
            --quiet (see below)
Examples:   outfile regress.txt --write
            outfile --close

Diverts output to filename, until further notice. Use the flag --append to
append output to an existing file or --write to start a new file (or
overwrite an existing one). Only one file can be opened in this way at any
given time.

The --close flag is used to close an output file that was previously opened
as above. Output will then revert to the default stream.

In the first example command above, the file regress.txt is opened for
writing, and in the second it is closed. This would make sense as a sequence
only if some commands were issued before the --close. For example if an
"ols" command intervened, its output would go to regress.txt rather than the
screen.

Three special variants on the above are available. If you give the keyword
null in place of a real filename along with the --write option, the effect
is to suppress all printed output until redirection is ended. If either of
the keywords stdout or stderr are given in place of a regular filename the
effect is to redirect output to standard output or standard error output
respectively.

The --quiet option is for use with --write or --append: its effect is to
turn off the echoing of commands and the printing of auxiliary messages
while output is redirected. It is equivalent to doing

	set echo off
	set messages off

except that when redirection is ended the original values of the echo and
messages variables are restored.

# panel Estimation

Arguments:  depvar indepvars 
Options:    --vcv (print covariance matrix)
            --fixed-effects (estimate with group fixed effects)
            --random-effects (random effects or GLS model)
            --nerlove (use the Nerlove transformation)
            --between (estimate the between-groups model)
            --robust (robust standard errors; see below)
            --time-dummies (include time dummy variables)
            --unit-weights (weighted least squares)
            --iterate (iterative estimation)
            --matrix-diff (use matrix-difference method for Hausman test)
            --quiet (less verbose output)
            --verbose (more verbose output)

Estimates a panel model. By default the fixed effects estimator is used;
this is implemented by subtracting the group or unit means from the original
data.

If the --random-effects flag is given, random effects estimates are
computed, by default using the method of Swamy and Arora (1972). In this
case (only) the option --matrix-diff forces use of the matrix-difference
method (as opposed to the regression method) for carrying out the Hausman
test for the consistency of the random effects estimator. Also specific to
the random effects estimator is the --nerlove flag, which selects the method
of Nerlove (1971) as opposed to Swamy and Arora.

Alternatively, if the --unit-weights flag is given, the model is estimated
via weighted least squares, with the weights based on the residual variance
for the respective cross-sectional units in the sample. In this case (only)
the --iterate flag may be added to produce iterative estimates: if the
iteration converges, the resulting estimates are Maximum Likelihood.

As a further alternative, if the --between flag is given, the between-groups
model is estimated (that is, an OLS regression using the group means).

The --robust option is available only for fixed effects models. The default
variant is the Arellano HAC estimator, but Beck-Katz "Panel Corrected
Standard Errors" can be selected via the command set pcse on.

For more details on panel estimation, please see the Gretl User's Guide.

Menu path:    /Model/Panel

# pca Statistics

Argument:   varlist 
Options:    --covariance (use the covariance matrix)
            --save[=n] (save major components)
            --save-all (save all components)
            --quiet (don't print results)

Principal Components Analysis. Unless the --quiet option is given, prints
the eigenvalues of the correlation matrix (or the covariance matrix if the
--covariance option is given) for the variables in varlist, along with the
proportion of the joint variance accounted for by each component. Also
prints the corresponding eigenvectors (or "component loadings").

If you give the --save-all option then all components are saved to the
dataset as series, with names PC1, PC2 and so on. These artificial variables
are formed as the sum of (component loading) times (standardized X_i), where
X_i denotes the ith variable in varlist.

If you give the --save option without a parameter value, components with
eigenvalues greater than the mean (which means greater than 1.0 if the
analysis is based on the correlation matrix) are saved to the dataset as
described above. If you provide a value for n with this option then the most
important n components are saved.

See also the "princomp" function.

Menu path:    /View/Principal components
Other access: Main window pop-up (multiple selection)

# pergm Statistics

Arguments:  series [ bandwidth ] 
Options:    --bartlett (use Bartlett lag window)
            --log (use log scale)
            --radians (show frequency in radians)
            --degrees (show frequency in degrees)
            --plot=mode-or-filename (see below)

Computes and displays the spectrum of the specified series. By default the
sample periodogram is given, but optionally a Bartlett lag window is used in
estimating the spectrum (see, for example, Greene's Econometric Analysis for
a discussion of this). The default width of the Bartlett window is twice the
square root of the sample size but this can be set manually using the
bandwidth parameter, up to a maximum of half the sample size.

If the --log option is given the spectrum is represented on a logarithmic
scale.

The (mutually exclusive) options --radians and --degrees influence the
appearance of the frequency axis when the periodogram is graphed. By default
the frequency is scaled by the number of periods in the sample, but these
options cause the axis to be labeled from 0 to pi radians or from 0 to
180degrees, respectively.

By default, if the program is not in batch mode a plot of the periodogram is
shown. This can be adjusted via the --plot option. The acceptable parameters
to this option are none (to suppress the plot); display (to display a plot
even when in batch mode); or a file name. The effect of providing a file
name is as described for the --output option of the "gnuplot" command.

Menu path:    /Variable/Periodogram
Other access: Main window pop-up menu (single selection)

# poisson Estimation

Arguments:  depvar indepvars [ ; offset ] 
Options:    --robust (robust standard errors)
            --cluster=clustvar (see "logit" for explanation)
            --vcv (print covariance matrix)
            --verbose (print details of iterations)
Examples:   poisson y 0 x1 x2
            poisson y 0 x1 x2 ; S

Estimates a poisson regression. The dependent variable is taken to represent
the occurrence of events of some sort, and must take on only non-negative
integer values.

If a discrete random variable Y follows the Poisson distribution, then

  Pr(Y = y) = exp(-v) * v^y / y!

for y = 0, 1, 2,.... The mean and variance of the distribution are both
equal to v. In the Poisson regression model, the parameter v is represented
as a function of one or more independent variables. The most common version
(and the only one supported by gretl) has

  v = exp(b0 + b1*x1 + b2*x2 + ...)

or in other words the log of v is a linear function of the independent
variables.

Optionally, you may add an "offset" variable to the specification. This is a
scale variable, the log of which is added to the linear regression function
(implicitly, with a coefficient of 1.0). This makes sense if you expect the
number of occurrences of the event in question to be proportional, other
things equal, to some known factor. For example, the number of traffic
accidents might be supposed to be proportional to traffic volume, other
things equal, and in that case traffic volume could be specified as an
"offset" in a Poisson model of the accident rate. The offset variable must
be strictly positive.

By default, standard errors are computed using the negative inverse of the
Hessian. If the --robust flag is given, then QML or Huber-White standard
errors are calculated instead. In this case the estimated covariance matrix
is a "sandwich" of the inverse of the estimated Hessian and the outer
product of the gradient.

See also "negbin".

Menu path:    /Model/Limited dependent variable/Count data...

# print Printing

Variants:   print varlist
            print
            print object_name
            print string_literal
Options:    --byobs (by observations)
            --no-dates (use simple observation numbers)
Examples:   print x1 x2 --byobs
            print my_matrix
            print "This is a string"

If varlist is given, prints the values of the specified series, or if no
argument is given, prints the values of all series in the current dataset.
If the --byobs flag is added the data are printed by observation, otherwise
they are printed by variable. When printing by observation, the default is
to show the date (with time-series data) or the observation marker string
(if any) at the start of each line. The --no-dates option suppresses the
printing of dates or markers; a simple observation number is shown instead.

Besides printing series, you may give the name of a (single) matrix or
scalar variable for printing. Or you may give a literal string argument,
enclosed in double quotes, to be printed as is. In these case the option
flags are not applicable.

Note that you can gain greater control over the printing format (and so, for
example, expose a greater number of digits than are shown by default) by
using "printf".

Menu path:    /Data/Display values

# printf Printing

Arguments:  format , args 

Prints scalar values, series, matrices, or strings under the control of a
format string (providing a subset of the printf() statement in the C
programming language). Recognized numeric formats are %e, %E, %f, %g, %G and
%d, in each case with the various modifiers available in C. Examples: the
format %.10g prints a value to 10 significant figures; %12.6f prints a value
to 6 decimal places, with a width of 12 characters. The format %s should be
used for strings.

The format string itself must be enclosed in double quotes. The values to be
printed must follow the format string, separated by commas. These values
should take the form of either (a) the names of variables, (b) expressions
that are valid for the "genr" command, or (c) the special functions
varname() or date(). The following example prints the values of two
variables plus that of a calculated expression:

	ols 1 0 2 3
	scalar b = $coeff[2]
	scalar se_b = $stderr[2]
	printf "b = %.8g, standard error %.8g, t = %.4f\n", 
          b, se_b, b/se_b

The next lines illustrate the use of the varname and date functions, which
respectively print the name of a variable, given its ID number, and a date
string, given a 1-based observation number.

	printf "The name of variable %d is %s\n", i, varname(i)
	printf "The date of observation %d is %s\n", j, date(j)

If a matrix argument is given in association with a numeric format, the
entire matrix is printed using the specified format for each element. The
same applies to series, except that the range of values printed is governed
by the current sample setting.

The maximum length of a format string is 127 characters. The escape
sequences \n (newline), \t (tab), \v (vertical tab) and \\ (literal
backslash) are recognized. To print a literal percent sign, use %%.

As in C, numerical values that form part of the format (width and or
precision) may be given directly as numbers, as in %10.4f, or they may be
given as variables. In the latter case, one puts asterisks into the format
string and supplies corresponding arguments in order. For example,

	scalar width = 12
	scalar precision = 6
	printf "x = %*.*f\n", width, precision, x

# probit Estimation

Arguments:  depvar indepvars 
Options:    --robust (robust standard errors)
            --cluster=clustvar (see "logit" for explanation)
            --vcv (print covariance matrix)
            --verbose (print details of iterations)
            --p-values (show p-values instead of slopes)
            --random-effects (estimates a random effects panel probit model)
            --quadpoints=k (number of quadrature points for RE estimation)

If the dependent variable is a binary variable (all values are 0 or 1)
maximum likelihood estimates of the coefficients on indepvars are obtained
via the Newton-Raphson method. As the model is nonlinear the slopes depend
on the values of the independent variables. By default the slopes with
respect to each of the independent variables are calculated (at the means of
those variables) and these slopes replace the usual p-values in the
regression output. This behavior can be suppressed my giving the --p-values
option. The chi-square statistic tests the null hypothesis that all
coefficients are zero apart from the constant.

By default, standard errors are computed using the negative inverse of the
Hessian. If the --robust flag is given, then QML or Huber-White standard
errors are calculated instead. In this case the estimated covariance matrix
is a "sandwich" of the inverse of the estimated Hessian and the outer
product of the gradient. See chapter 10 of Davidson and MacKinnon for
details.

If the dependent variable is not binary but is discrete, then Ordered Probit
estimates are obtained. (If the variable selected as dependent is not
discrete, an error is flagged.)

With the --random-effects option, the error term is assumed to be composed
of two normally distributed components: one time-invariant term that is
specific to the cross-sectional unit or "individual" (and is known as the
individual effect); and one term that is specific to the particular
observation.

Evaluation of the likelihood for this model involves the use of
Gauss-Hermite quadrature for approximating the value of expectations of
functions of normal variates. The number of quadrature points used can be
chosen through the --quadpoints option (the default is 32). Using more
points will increase the accuracy of the results, but at the cost of longer
compute time; with many quadrature points and a large dataset estimation may
be quite time consuming.

Besides the usual parameter estimates (and associated statistics) relating
to the included regressors, certain additional information is presented on
estimation of this sort of model:

  lnsigma2: the maximum likelihood estimate of the log of the variance of
  the individual effect;

  sigma_u: the estimated standard deviation of the individual effect; and

  rho: the estimated share of the individual effect in the composite error
  variance (also known as the intra-class correlation).

The Likelihood Ratio test of the null hypothesis that rho equals zero
provides a means of assessing whether the random effects specification is
needed. If the null is not rejected that suggests that a simple pooled
probit specification is adequate.

Probit for analysis of proportions is not implemented in gretl at this
point.

Menu path:    /Model/Limited dependent variable/Probit

# pvalue Utilities

Arguments:  dist [ params ] xval 
Examples:   pvalue z zscore
            pvalue t 25 3.0
            pvalue X 3 5.6
            pvalue F 4 58 fval
            pvalue G shape scale x
            pvalue B bprob 10 6
            pvalue P lambda x
            pvalue W shape scale x

Computes the area to the right of xval in the specified distribution (z for
Gaussian, t for Student's t, X for chi-square, F for F, G for gamma, B for
binomial, P for Poisson, or W for Weibull).

Depending on the distribution, the following information must be given,
before the xval: for the t and chi-square distributions, the degrees of
freedom; for F, the numerator and denominator degrees of freedom; for gamma,
the shape and scale parameters; for the binomial distribution, the "success"
probability and the number of trials; for the Poisson distribution, the
parameter lambda (which is both the mean and the variance); and for the
Weibull distribution, shape and scale parameters. As shown in the examples
above, the numerical parameters may be given in numeric form or as the names
of variables.

The parameters for the gamma distribution are sometimes given as mean and
variance rather than shape and scale. The mean is the product of the shape
and the scale; the variance is the product of the shape and the square of
the scale. So the scale may be found as the variance divided by the mean,
and the shape as the mean divided by the scale.

Menu path:    /Tools/P-value finder

# qlrtest Tests

For a model estimated on time-series data via OLS, performs the Quandt
likelihood ratio (QLR) test for a structural break at an unknown point in
time, with 15 percent trimming at the beginning and end of the sample
period.

For each potential break point within the central 70 percent of the
observations, a Chow test is performed. See "chow" for details; as with the
regular Chow test, this is a robust Wald test if the original model was
estimated with the --robust option, an F-test otherwise. The QLR statistic
is then the maximum of the individual test statistics.

An asymptotic p-value is obtained using the method of Bruce Hansen (1997).

Menu path:    Model window, /Tests/QLR test

# qqplot Graphs

Variants:   qqplot y
            qqplot y x
Options:    --z-scores (see below)
            --raw (see below)
            --output=filename (send output to specified file)

Given just one series argument, displays a plot of the empirical quantiles
of the selected series (given by name or ID number) against the quantiles of
the normal distribution. The series must include at least 20 valid
observations in the current sample range. By default the empirical quantiles
are plotted against quantiles of the normal distribution having the same
mean and variance as the sample data, but two alternatives are available: if
the --z-scores option is given the data are standardized, while if the --raw
option is given the "raw" empirical quantiles are plotted against the
quantiles of the standard normal distribution.

The option --output has the effect to send the output to the desiderd
filename; use "display" to force output to the screen, for example during a
loop.

Given two series arguments, y and x, displays a plot of the empirical
quantiles of y against those of x. The data values are not standardized.

Menu path:    /Variable/Normal Q-Q plot
Menu path:    /View/Graph specified vars/Q-Q plot

# quantreg Estimation

Arguments:  tau depvar indepvars 
Options:    --robust (robust standard errors)
            --intervals[=level] (compute confidence intervals)
            --vcv (print covariance matrix)
            --quiet (suppress printing of results)
Examples:   quantreg 0.25 y 0 xlist
            quantreg 0.5 y 0 xlist --intervals
            quantreg 0.5 y 0 xlist --intervals=.95
            quantreg tauvec y 0 xlist --robust
            See also mrw_qr.inp

Quantile regression. The first argument, tau, is the conditional quantile
for which estimates are wanted. It may be given either as a numerical value
or as the name of a pre-defined scalar variable; the value must be in the
range 0.01 to 0.99. (Alternatively, a vector of values may be given for tau;
see below for details.) The second and subsequent arguments compose a
regression list on the same pattern as "ols".

Without the --intervals option, standard errors are printed for the quantile
estimates. By default, these are computed according to the asymptotic
formula given by Koenker and Bassett (1978), but if the --robust option is
given, standard errors that are robust with respect to heteroskedasticity
are calculated using the method of Koenker and Zhao (1994).

When the --intervals option is chosen, confidence intervals are given for
the parameter estimates instead of standard errors. These intervals are
computed using the rank inversion method, and in general they are
asymmetrical about the point estimates. The specifics of the calculation are
inflected by the --robust option: without this, the intervals are computed
on the assumption of IID errors (Koenker, 1994); with it, they use the
robust estimator developed by Koenker and Machado (1999).

By default, 90 percent confidence intervals are produced. You can change
this by appending a confidence level (expressed as a decimal fraction) to
the intervals option, as in --intervals=0.95.

Vector-valued tau: instead of supplying a scalar, you may give the name of a
pre-defined matrix. In this case estimates are computed for all the given
tau values and the results are printed in a special format, showing the
sequence of quantile estimates for each regressor in turn.

Menu path:    /Model/Robust estimation/Quantile regression

# quit Utilities

Exits from the program, giving you the option of saving the output from the
session on the way out.

Menu path:    /File/Exit

# rename Dataset

Arguments:  series newname 

Changes the name of series (identified by name or ID number) to newname. The
new name must be of 31 characters maximum, must start with a letter, and
must be composed of only letters, digits, and the underscore character.

Menu path:    /Variable/Edit attributes
Other access: Main window pop-up menu (single selection)

# reset Tests

Options:    --quiet (don't print the auxiliary regression)
            --squares-only (compute the test using only the squares)
            --cubes-only (compute the test using only the cubes)

Must follow the estimation of a model via OLS. Carries out Ramsey's RESET
test for model specification (non-linearity) by adding the square and/or the
cube of the fitted values to the regression and calculating the F statistic
for the null hypothesis that the parameters on the added terms are zero.

Both the square and the cube are added, unless one of the options
--squares-only or --cubes-only is given.

Menu path:    Model window, /Tests/Ramsey's RESET

# restrict Tests

Options:    --quiet (don't print restricted estimates)
            --silent (don't print anything)
            --wald (system estimators only - see below)
            --bootstrap (bootstrap the test if possible)
            --full (OLS and VECMs only, see below)

Imposes a set of (usually linear) restrictions on either (a) the model last
estimated or (b) a system of equations previously defined and named. In all
cases the set of restrictions should be started with the keyword "restrict"
and terminated with "end restrict".

In the single equation case the restrictions are always implicitly to be
applied to the last model, and they are evaluated as soon as the restrict
block is closed.

In the case of a system of equations (defined via the "system" command), the
initial "restrict" may be followed by the name of a previously defined
system of equations. If this is omitted and the last model was a system then
the restrictions are applied to the last model. By default the restrictions
are evaluated when the system is next estimated, using the "estimate"
command. But if the --wald option is given the restriction is tested right
away, via a Wald chi-square test on the covariance matrix. Note that this
option will produce an error if a system has been defined but not yet
estimated.

Depending on the context, the restrictions to be tested may be expressed in
various ways. The simplest form is as follows: each restriction is given as
an equation, with a linear combination of parameters on the left and a
scalar value to the right of the equals sign (either a numerical constant or
the name of a scalar variable).

In the single-equation case, parameters may be referenced in the form b[i],
where i represents the position in the list of regressors (starting at 1),
or b[varname], where varname is the name of the regressor in question. In
the system case, parameters are referenced using b plus two numbers in
square brackets. The leading number represents the position of the equation
within the system and the second number indicates position in the list of
regressors. For example b[2,1] denotes the first parameter in the second
equation, and b[3,2] the second parameter in the third equation. The b terms
in the equation representing a restriction may be prefixed with a numeric
multiplier, for example 3.5*b[4].

Here is an example of a set of restrictions for a previously estimated
model:

	restrict
	 b[1] = 0
	 b[2] - b[3] = 0
	 b[4] + 2*b[5] = 1
	end restrict

And here is an example of a set of restrictions to be applied to a named
system. (If the name of the system does not contain spaces, the surrounding
quotes are not required.)

	restrict "System 1"
	 b[1,1] = 0
	 b[1,2] - b[2,2] = 0
	 b[3,4] + 2*b[3,5] = 1
	end restrict

In the single-equation case the restrictions are by default evaluated via a
Wald test, using the covariance matrix of the model in question. If the
original model was estimated via OLS then the restricted coefficient
estimates are printed; to suppress this, append the --quiet option flag to
the initial restrict command. As an alternative to the Wald test, for models
estimated via OLS or WLS only, you can give the --bootstrap option to
perform a bootstrapped test of the restriction.

In the system case, the test statistic depends on the estimator chosen: a
Likelihood Ratio test if the system is estimated using a Maximum Likelihood
method, or an asymptotic F-test otherwise.

There are two alternatives to the method of expressing restrictions
discussed above. First, a set of g linear restrictions on a k-vector of
parameters, beta, may be written compactly as Rbeta - q = 0, where R is an g
x k matrix and q is a g-vector. You can specify a restriction by giving the
names of pre-defined, conformable matrices to be used as R and q, as in

	restrict 
	  R = Rmat
	  q = qvec
	end restrict

Secondly, if you wish to test a nonlinear restriction (this is currently
available for single-equation models only) you should give the restriction
as the name of a function, preceded by "rfunc = ", as in

	restrict
	  rfunc = myfunction
	end restrict

The constraint function should take a single const matrix argument; this
will be automatically filled out with the parameter vector. And it should
return a vector which is zero under the null hypothesis, non-zero otherwise.
The length of the vector is the number of restrictions. This function is
used as a "callback" by gretl's numerical Jacobian routine, which calculates
a Wald test statistic via the delta method.

Here is a simple example of a function suitable for testing one nonlinear
restriction, namely that two pairs of parameter values have a common ratio.

	function matrix restr (const matrix b)
	  matrix v = b[1]/b[2] - b[4]/b[5]
	  return v
	end function

On successful completion of the restrict command the accessors $test and
$pvalue give the test statistic and its p-value.

When testing restrictions on a single-equation model estimated via OLS, or
on a VECM, the --full option can be used to set the restricted estimates as
the "last model" for the purposes of further testing or the use of accessors
such as $coeff and $vcv. Note that some special considerations apply in the
case of testing restrictions on Vector Error Correction Models. Please see
the Gretl User's Guide for details.

Menu path:    Model window, /Tests/Linear restrictions

# rmplot Graphs

Argument:   series 
Options:    --trim (see below)
            --quiet (suppress printed output)

Range-mean plot: this command creates a simple graph to help in deciding
whether a time series, y(t), has constant variance or not. We take the full
sample t=1,...,T and divide it into small subsamples of arbitrary size k.
The first subsample is formed by y(1),...,y(k), the second is y(k+1), ...,
y(2k), and so on. For each subsample we calculate the sample mean and range
(= maximum minus minimum), and we construct a graph with the means on the
horizontal axis and the ranges on the vertical. So each subsample is
represented by a point in this plane. If the variance of the series is
constant we would expect the subsample range to be independent of the
subsample mean; if we see the points approximate an upward-sloping line this
suggests the variance of the series is increasing in its mean; and if the
points approximate a downward sloping line this suggests the variance is
decreasing in the mean.

Besides the graph, gretl displays the means and ranges for each subsample,
along with the slope coefficient for an OLS regression of the range on the
mean and the p-value for the null hypothesis that this slope is zero. If the
slope coefficient is significant at the 10 percent significance level then
the fitted line from the regression of range on mean is shown on the graph.
The t-statistic for the null, and the corresponding p-value, are recorded
and may be retrieved using the accessors $test and $pvalue respectively.

If the --trim option is given, the minimum and maximum values in each
sub-sample are discarded before calculating the mean and range. This makes
it less likely that outliers will distort the analysis.

If the --quiet option is given, no graph is shown and no output is printed;
only the t-statistic and p-value are recorded.

Menu path:    /Variable/Range-mean graph

# run Programming

Argument:   filename 

Executes the commands in filename then returns control to the interactive
prompt. This command is intended for use with the command-line program
gretlcli, or at the "gretl console" in the GUI program.

See also "include".

Menu path:    Run icon in script window

# runs Tests

Argument:   series 
Options:    --difference (use first difference of variable)
            --equal (positive and negative values are equiprobable)

Carries out the nonparametric "runs" test for randomness of the specified
series, where runs are defined as sequences of consecutive positive or
negative values. If you want to test for randomness of deviations from the
median, for a variable named x1 with a non-zero median, you can do the
following:

	series signx1 = x1 - median(x1)
	runs signx1

If the --difference option is given, the variable is differenced prior to
the analysis, hence the runs are interpreted as sequences of consecutive
increases or decreases in the value of the variable.

If the --equal option is given, the null hypothesis incorporates the
assumption that positive and negative values are equiprobable, otherwise the
test statistic is invariant with respect to the "fairness" of the process
generating the sequence, and the test focuses on independence alone.

Menu path:    /Tools/Nonparametric tests

# scatters Graphs

Arguments:  yvar ; xvars  or yvars ; xvar 
Options:    --with-lines (create line graphs)
            --matrix=name (plot columns of named matrix)
            --output=filename (send output to specified file)
            --output=filename (send output to specified file)
Examples:   scatters 1 ; 2 3 4 5
            scatters 1 2 3 4 5 6 ; 7
            scatters y1 y2 y3 ; x --with-lines

Generates pairwise graphs of yvar against all the variables in xvars, or of
all the variables in yvars against xvar. The first example above puts
variable 1 on the y-axis and draws four graphs, the first having variable 2
on the x-axis, the second variable 3 on the x-axis, and so on. The second
example plots each of variables 1 through 6 against variable 7 on the
x-axis. Scanning a set of such plots can be a useful step in exploratory
data analysis. The maximum number of plots is 16; any extra variable in the
list will be ignored.

By default the graphs are scatterplots, but if you give the --with-lines
flag they will be line graphs.

For details on usage of the --output option, please see the "gnuplot"
command.

If a named matrix is specified as the data source the x and y lists should
be given as 1-based column numbers; or alternatively, if no such numbers are
given, all the columns are plotted against time or an index variable.

If the dataset is time-series, then the second sub-list can be omitted, in
which case it will implicitly be taken as "time", so you can plot multiple
time series in separated sub-graphs

Menu path:    /View/Multiple graphs

# sdiff Transformations

Argument:   varlist 

The seasonal difference of each variable in varlist is obtained and the
result stored in a new variable with the prefix sd_. This command is
available only for seasonal time series.

Menu path:    /Add/Seasonal differences of selected variables

# set Programming

Variants:   set variable value
            set --to-file=filename
            set --from-file=filename
            set stopwatch
            set
Examples:   set svd on
            set csv_delim tab
            set horizon 10
            set --to-file=mysettings.inp

The most common use of this command is the first variant shown above, where
it is used to set the value of a selected program parameter. This is
discussed in detail below. The other uses are: with --to-file, to write a
script file containing all the current parameter settings; with --from-file
to read a script file containing parameter settings and apply them to the
current session; with stopwatch to zero the gretl "stopwatch" which can be
used to measure CPU time (see the entry for the $stopwatch accessor in the
gretl function reference); or, if the word set is given alone, to print the
current settings.

Values set via this comand remain in force for the duration of the gretl
session unless they are changed by a further call to "set". The parameters
that can be set in this way are enumerated below. Note that the settings of
hc_version, hac_lag and hac_kernel are used when the --robust option is
given to an estimation command.

The available settings are grouped under the following categories: program
interaction and behavior, numerical methods, random number generation,
robust estimation, filtering, time series estimation, and interaction with
GNU R.

Program interaction and behavior

These settings are used for controlling various aspects of the way gretl
interacts with the user.

  csv_delim: either comma (the default), space, tab or semicolon. Sets the
  column delimiter used when saving data to file in CSV format.

  csv_write_na: the string used to represent missing values when writing
  data to file in CSV format. Maximum 7 characters; the default is NA.

  csv_read_na: the string taken to represent missing values (NAs) when
  reading data in CSV format. Maximum 7 characters. The default depends on
  whether a data column is found to contain numerical data (mostly) or
  string values. For numerical data the following are taken as indicating
  NAs: an empty cell, or any of the strings NA, N.A., na, n.a., N/A, #N/A,
  NaN, .NaN, ., .., -999, and -9999. For string-valued data only a blank
  cell, or a cell containing an empty string, is counted as NA. These
  defaults can be reimposed by giving default as the value for csv_read_na.
  To specify that only empty cells are read as NAs, give a value of "". Note
  that empty cells are always read as NAs regardless of the setting of this
  variable.

  csv_digits: a positive integer specifying the number of significant digits
  to use when writing data in CSV format. By default up to 12 digits are
  used depending on the precision of the original data. Note that CSV output
  employs the C library's fprintf function with "%g" conversion, which means
  that trailing zeros are dropped.

  echo: off or on (the default). Suppress or resume the echoing of commands
  in gretl's output.

  force_decpoint: on or off (the default). Force gretl to use the decimal
  point character, in a locale where another character (most likely the
  comma) is the standard decimal separator.

  halt_on_error: off or on (the default). By default, when an error is
  encountered in the course of executing a script, execution is halted (and
  if the command-line program is operating in batch mode, it exits with a
  non-zero return status). You can force gretl to continue on error by
  setting halt_on_error to off (or by setting the environment variable
  GRETL_KEEP_GOING to 1). If an error occurs while "compiling" a loop or
  user-defined function, however, execution is halted regardless.

  loop_maxiter: one non-negative integer value (default 100000). Sets the
  maximum number of iterations that a while loop is allowed before halting
  (see "loop"). Note that this setting only affects the while variant; its
  purpose is to guard against inadvertently infinite loops. Setting this
  value to 0 has the effect of disabling the limit; use with caution.

  max_verbose: on or off (the default). Toggles verbose output for the
  BFGSmax and NRmax functions (see the User's Guide for details).

  messages: off or on (the default). Suppress or resume the printing of
  non-error messages associated with various commands, for example when a
  new variable is generated or when the sample range is changed.

  warnings: off or on (the default). Suppress or resume the printing of
  warning messages issued when arithmetical operations produce non-finite
  values.

  debug: 1, 2 or 0 (the default). This is for use with user-defined
  functions. Setting debug to 1 is equivalent to turning messages on within
  all such functions; setting this variable to 2 has the additional effect
  of turning on max_verbose within all functions.

  shell_ok: on or off (the default). Enable launching external programs from
  gretl via the system shell. This is disabled by default for security
  reasons, and can only be enabled via the graphical user interface
  (Tools/Preferences/General). However, once set to on, this setting will
  remain active for future sessions until explicitly disabled.

  shelldir: path. Sets the current working directory for shell commands.

  use_cwd: on or off (the default). This setting affects the behavior of the
  "outfile" and "store" commands, which write external files. Normally, the
  file will be written in the user's default data directory; if use_cwd is
  on, on the contrary, the file will be created in the working directory
  when gretl was started.

  bfgs_verbskip: one integer. This setting affects the behavior of the
  --verbose option to those commands that use BFGS as an optimization
  algorithm and is used to compact output. if bfgs_verbskip is set to, say,
  3, then the --verbose switch will only print iterations 3, 6, 9 and so on.

  skip_missing: on (the default) or off. Controls gretl's behavior when
  contructing a matrix from data series: the default is to skip data rows
  that contain one or more missing values but if skip_missing is set off
  missing values are converted to NaNs.

  matrix_mask: the name of a series, or the keyword null. Offers greater
  control than skip_missing when constructing matrices from series: the data
  rows selected for matrices are those with non-zero (and non-missing)
  values in the specified series. The selected mask remains in force until
  it is replaced, or removed via the null keyword.

  huge: a large positive number (by default, 1.0E100). This setting controls
  the value returned by the accessor "$huge".

Numerical methods

These settings are used for controlling the numerical algorithms that gretl
uses for estimation.

  optimizer: either auto (the default), BFGS or newton. Sets the
  optimization algorithm used for various ML estimators, in cases where both
  BFGS and Newton-Raphson are applicable. The default is to use
  Newton-Raphson where an analytical Hessian is available, otherwise BFGS.

  bhhh_maxiter: one integer, the maximum number of iterations for gretl's
  internal BHHH routine, which is used in the "arma" command for conditional
  ML estimation. If convergence is not achieved after bhhh_maxiter, the
  program returns an error. The default is set at 500.

  bhhh_toler: one floating point value, or the string default. This is used
  in gretl's internal BHHH routine to check if convergence has occurred. The
  algorithm stops iterating as soon as the increment in the log-likelihood
  between iterations is smaller than bhhh_toler. The default value is
  1.0E-06; this value may be re-established by typing default in place of a
  numeric value.

  bfgs_maxiter: one integer, the maximum number of iterations for gretl's
  BFGS routine, which is used for "mle", "gmm" and several specific
  estimators. If convergence is not achieved in the specified number of
  iterations, the program returns an error. The default value depends on the
  context, but is typically of the order of 500.

  bfgs_toler: one floating point value, or the string default. This is used
  in gretl's BFGS routine to check if convergence has occurred. The
  algorithm stops as soon as the relative improvement in the objective
  function between iterations is smaller than bfgs_toler. The default value
  is the machine precision to the power 3/4; this value may be
  re-established by typing default in place of a numeric value.

  bfgs_maxgrad: one floating point value. This is used in gretl's BFGS
  routine to check if the norm of the gradient is reasonably close to zero
  when the bfgs_toler criterion is met. A warning is printed if the norm of
  the gradient exceeds 1; an error is flagged if the norm exceeds
  bfgs_maxgrad. At present the default is the permissive value of 5.0.

  bfgs_richardson: on or off (the default). Use Richardson extrapolation
  when computing numerical derivatives in the context of BFGS maximization.

  initvals: either auto (the default) or the name of a pre-specified matrix.
  Allows manual setting of the initial parameter estimates for numerical
  optimization problems (such as ARMA estimation). For details see the Gretl
  User's Guide.

  lbfgs: on or off (the default). Use the limited-memory version of BFGS
  (L-BFGS-B) instead of the ordinary algorithm. This may be advantageous
  when the function to be maximized is not globally concave.

  lbfgs_mem: an integer value in the range 3 to 20 (with a default value of
  8). This determines the number of corrections used in the limited memory
  matrix when L-BFGS-B is employed.

  nls_toler: a floating-point value (the default is the machine precision to
  the power 3/4). Sets the tolerance used in judging whether or not
  convergence has occurred in nonlinear least squares estimation using the
  "nls" command.

  svd: on or off (the default). Use SVD rather than Cholesky or QR
  decomposition in least squares calculations. This option applies to the
  mols function as well as various internal calculations, but not to the
  regular "ols" command.

  fcp: on or off (the default). Use the algorithm of Fiorentini, Calzolari
  and Panattoni rather than native gretl code when computing GARCH
  estimates.

  gmm_maxiter: one integer, the maximum number of iterations for gretl's
  "gmm" command when in iterated mode (as opposed to one- or two-step). The
  default value is 250.

  nadarwat_trim: one integer, the trim parameter used in the "nadarwat"
  function.

  fdjac_quality: one integer between 0 and 2, the algorithm used by the
  "fdjac" function.

Random number generation

  seed: an unsigned integer. Sets the seed for the pseudo-random number
  generator. By default this is set from the system time; if you want to
  generate repeatable sequences of random numbers you must set the seed
  manually.

  normal_rand: ziggurat (the default) or box-muller. Sets the method for
  generating random normal samples based on uniform input.

Robust estimation

  bootrep: an integer. Sets the number of replications for the "restrict"
  command with the --bootstrap option.

  garch_vcv: unset, hessian, im (information matrix) , op (outer product
  matrix), qml (QML estimator), bw (Bollerslev-Wooldridge). Specifies the
  variant that will be used for estimating the coefficient covariance
  matrix, for GARCH models. If unset is given (the default) then the Hessian
  is used unless the "robust" option is given for the garch command, in
  which case QML is used.

  arma_vcv: hessian (the default) or op (outer product matrix). Specifies
  the variant to be used when computing the covariance matrix for ARIMA
  models.

  force_hc: off (the default) or on. By default, with time-series data and
  when the --robust option is given with ols, the HAC estimator is used. If
  you set force_hc to "on", this forces calculation of the regular
  Heteroskedasticity Consistent Covariance Matrix (HCCM), which does not
  take autocorrelation into account. Note that VARs are treated as a special
  case: when the --robust option is given the default method is regular
  HCCM, but the --robust-hac flag can be used to force the use of a HAC
  estimator.

  hac_lag: nw1 (the default), nw2, nw3 or an integer. Sets the maximum lag
  value or bandwidth, p, used when calculating HAC (Heteroskedasticity and
  Autocorrelation Consistent) standard errors using the Newey-West approach,
  for time series data. nw1 and nw2 represent two variant automatic
  calculations based on the sample size, T: for nw1, p = 0.75 * T^(1/3), and
  for nw2, p = 4 * (T/100)^(2/9). nw3 calls for data-based bandwidth
  selection. See also qs_bandwidth and hac_prewhiten below.

  hac_kernel: bartlett (the default), parzen, or qs (Quadratic Spectral).
  Sets the kernel, or pattern of weights, used when calculating HAC standard
  errors.

  hac_prewhiten: on or off (the default). Use Andrews-Monahan prewhitening
  and re-coloring when computing HAC standard errors. This also implies use
  of data-based bandwidth selection.

  hc_version: 0 (the default), 1, 2, 3 or 3a. Sets the variant used when
  calculating Heteroskedasticity Consistent standard errors with
  cross-sectional data. The first four options correspond to the HC0, HC1,
  HC2 and HC3 discussed by Davidson and MacKinnon in Econometric Theory and
  Methods, chapter 5. HC0 produces what are usually called "White's standard
  errors". Variant 3a is the MacKinnon-White "jackknife" procedure.

  pcse: off (the default) or on. By default, when estimating a model using
  pooled OLS on panel data with the --robust option, the Arellano estimator
  is used for the covariance matrix. If you set pcse to "on", this forces
  use of the Beck and Katz Panel Corrected Standard Errors (which do not
  take autocorrelation into account).

  qs_bandwidth: Bandwidth for HAC estimation in the case where the Quadratic
  Spectral kernel is selected. (Unlike the Bartlett and Parzen kernels, the
  QS bandwidth need not be an integer.)

Time series

  horizon: one integer (the default is based on the frequency of the data).
  Sets the horizon for impulse responses and forecast variance
  decompositions in the context of vector autoregressions.

  vecm_norm: phillips (the default), diag, first or none. Used in the
  context of VECM estimation via the "vecm" command for identifying the
  cointegration vectors. See the the Gretl User's Guide for details.

Interaction with R

  R_lib: on (the default) or off. When sending instructions to be executed
  by R, use the R shared library by preference to the R executable, if the
  library is available.

  R_functions: off (the default) or on. Recognize functions defined in R as
  if they were native functions (the namespace prefix "R." is required). See
  the Gretl User's Guide for details on this and the previous item.

# setinfo Dataset

Argument:   series 
Options:    --description=string (set description)
            --graph-name=string (set graph name)
            --discrete (mark series as discrete)
            --continuous (mark series as continuous)
Examples:   setinfo x1 --description="Description of x1"
            setinfo y --graph-name="Some string"
            setinfo z --discrete

Sets up to three attributes of series, given by name or ID number, as
follows.

If the --description flag is given followed by a string in double quotes,
that string is used to set the variable's descriptive label. This label is
shown in response to the "labels" command, and is also shown in the main
window of the GUI program.

If the --graph-name flag is given followed by a quoted string, that string
will be used in place of the variable's name in graphs.

If one or other of the --discrete or --continuous option flags is given, the
variable's numerical character is set accordingly. The default is to treat
all series as continuous; setting a series as discrete affects the way the
variable is handled in frequency plots.

Menu path:    /Variable/Edit attributes
Other access: Main window pop-up menu

# setmiss Dataset

Arguments:  value [ varlist ] 
Examples:   setmiss -1
            setmiss 100 x2

Get the program to interpret some specific numerical data value (the first
parameter to the command) as a code for "missing", in the case of imported
data. If this value is the only parameter, as in the first example above,
the interpretation will be applied to all series in the data set. If "value"
is followed by a list of variables, by name or number, the interpretation is
confined to the specified variable(s). Thus in the second example the data
value 100 is interpreted as a code for "missing", but only for the variable
x2.

Menu path:    /Data/Set missing value code

# setobs Dataset

Variants:   setobs periodicity startobs
            setobs unitvar timevar --panel-vars
Options:    --cross-section (interpret as cross section)
            --time-series (interpret as time series)
            --stacked-cross-section (interpret as panel data)
            --stacked-time-series (interpret as panel data)
            --panel-vars (use index variables, see below)
            --panel-time (see below)
            --panel-groups (see below)
Examples:   setobs 4 1990:1 --time-series
            setobs 12 1978:03
            setobs 1 1 --cross-section
            setobs 20 1:1 --stacked-time-series
            setobs unit year --panel-vars

This command forces the program to interpret the current data set as having
a specified structure.

In the first form of the command the periodicity, which must be an integer,
represents frequency in the case of time-series data (1 = annual; 4 =
quarterly; 12 = monthly; 52 = weekly; 5, 6, or 7 = daily; 24 = hourly). In
the case of panel data the periodicity means the number of lines per data
block: this corresponds to the number of cross-sectional units in the case
of stacked cross-sections, or the number of time periods in the case of
stacked time series. In the case of simple cross-sectional data the
periodicity should be set to 1.

The starting observation represents the starting date in the case of time
series data. Years may be given with two or four digits; subperiods (for
example, quarters or months) should be separated from the year with a colon.
In the case of panel data the starting observation should be given as 1:1;
and in the case of cross-sectional data, as 1. Starting observations for
daily or weekly data should be given in the form YYYY-MM-DD (or simply as 1
for undated data).

If no explicit option flag is given to indicate the structure of the data
the program will attempt to guess the structure from the information given.

The second form of the command (which requires the --panel-vars flag) may be
used to impose a panel interpretation when the data set contains variables
that uniquely identify the cross-sectional units and the time periods. The
data set will be sorted as stacked time series, by ascending values of the
units variable, unitvar.

Panel-specific options

The --panel-time and --panel-groups options can only be used with a dataset
which has already been defined as a panel.

The purpose of --panel-time is to set extra information regarding the time
dimension of the panel. This should be given on the pattern of the first
form of setobs noted above. For example, the following may be used to
indicate that the time dimension of a panel is quarterly, starting in the
first quarter of 1990.

	setobs 4 1990:1 --panel-time

The purpose of --panel-groups is to create a string-valued series holding
names for the groups (individuals, cross-sectional units) in the panel. With
this option you must supply a name for the series and a string variable
holding a list of group names (in that order). The names should be separated
by spaces; if a name includes spaces it should be wrapped in
backslash-escaped double-quotes. For example, the following will create a
series named country in which the names in cstrs are each repeated T times,
T being the time-series length of the panel.

	string cstrs
	sprintf cstrs "France Germany Italy \"United Kingdom\""
	setobs country cstrs --panel-groups

Menu path:    /Data/Dataset structure

# shell Utilities

Argument:   shellcommand 
Examples:   ! ls -al
            ! notepad
            launch notepad

A "!", or the keyword "launch", at the beginning of a command line is
interpreted as an escape to the user's shell. Thus arbitrary shell commands
can be executed from within gretl. When "!" is used, the external command is
executed synchronously. That is, gretl waits for it to complete before
proceeding. If you want to start another program from within gretl and not
wait for its completion (asynchronous operation), use "launch" instead.

For reasons of security this facility is not enabled by default. To activate
it, check the box titled "Allow shell commands" under the File, Preferences
menu in the GUI program. This also makes shell commands available in the
command-line program (and is the only way to do so).

# smpl Dataset

Variants:   smpl startobs endobs
            smpl +i -j
            smpl dumvar --dummy
            smpl condition --restrict
            smpl --no-missing [ varlist ]
            smpl --contiguous [ varlist ]
            smpl n --random
            smpl full
Options:    --dummy (argument is a dummy variable)
            --restrict (apply boolean restriction)
            --replace (replace any existing boolean restriction)
            --no-missing (restrict to valid observations)
            --contiguous (see below)
            --random (form random sub-sample)
            --balanced (panel data: try to retain balanced panel)
Examples:   smpl 3 10
            smpl 1960:2 1982:4
            smpl +1 -1
            smpl x > 3000 --restrict
            smpl y > 3000 --restrict --replace
            smpl 100 --random

Resets the sample range. The new range can be defined in several ways. In
the first alternate form (and the first two examples) above, startobs and
endobs must be consistent with the periodicity of the data. Either one may
be replaced by a semicolon to leave the value unchanged. In the second form,
the integers i and j (which may be positive or negative, and should be
signed) are taken as offsets relative to the existing sample range. In the
third form dummyvar must be an indicator variable with values 0 or 1 at each
observation; the sample will be restricted to observations where the value
is 1. The fourth form, using --restrict, restricts the sample to
observations that satisfy the given Boolean condition (which is specified
according to the syntax of the "genr" command).

With the --no-missing form, if varlist is specified observations are
selected on condition that all variables in varlist have valid values at
that observation; otherwise, if no varlist is given, observations are
selected on condition that all variables have valid (non-missing) values.

The --contiguous form of smpl is intended for use with time series data. The
effect is to trim any observations at the start and end of the current
sample range that contain missing values (either for the variables in
varlist, or for all data series if no varlist is given). Then a check is
performed to see if there are any missing values in the remaining range; if
so, an error is flagged.

With the --random flag, the specified number of cases are selected from the
current dataset at random (without replacement). If you wish to be able to
replicate this selection you should set the seed for the random number
generator first (see the "set" command).

The final form, smpl full, restores the full data range.

Note that sample restrictions are, by default, cumulative: the baseline for
any smpl command is the current sample. If you wish the command to act so as
to replace any existing restriction you can add the option flag --replace to
the end of the command. (But this option is not compatible with the
--contiguous option.)

The internal variable obs may be used with the --restrict form of smpl to
exclude particular observations from the sample. For example

	smpl obs!=4 --restrict

will drop just the fourth observation. If the data points are identified by
labels,

	smpl obs!="USA" --restrict

will drop the observation with label "USA".

One point should be noted about the --dummy, --restrict and --no-missing
forms of smpl: "structural" information in the data file (regarding the time
series or panel nature of the data) is likely to be lost when this command
is issued. You may reimpose structure with the "setobs" command. A related
option, for use with panel data, is the --balanced flag: this requests that
a balanced panel is reconstituted after sub-sampling, via the insertion of
"missing rows" if need be. But note that it is not always possible to comply
with this request.

Please see the Gretl User's Guide for further details.

Menu path:    /Sample

# spearman Statistics

Arguments:  series1 series2 
Option:     --verbose (print ranked data)

Prints Spearman's rank correlation coefficient for the series series1 and
series2. The variables do not have to be ranked manually in advance; the
function takes care of this.

The automatic ranking is from largest to smallest (i.e. the largest data
value gets rank 1). If you need to invert this ranking, create a new
variable which is the negative of the original. For example:

	series altx = -x
	spearman altx y

Menu path:    /Model/Robust estimation/Rank correlation

# sprintf Printing

Arguments:  stringvar format , args 

This command works exactly like the "printf" command, printing the given
arguments under the control of the format string, except that the result is
written into the named string, stringvar.

# square Transformations

Argument:   varlist 
Option:     --cross (generate cross-products as well as squares)

Generates new series which are squares of the series in varlist (plus
cross-products if the --cross option is given). For example, "square x y"
will generate sq_x = x squared, sq_y = y squared and (optionally) x_y = x
times y. If a particular variable is a dummy variable it is not squared
because we will get the same variable.

Menu path:    /Add/Squares of selected variables

# store Dataset

Arguments:  filename [ varlist ] 
Options:    --csv (use CSV format)
            --omit-obs (see below, on CSV format)
            --no-header (see below, on CSV format)
            --gnu-octave (use GNU Octave format)
            --gnu-R (use GNU R format)
            --gzipped[=level] (apply gzip compression)
            --jmulti (use JMulti ASCII format)
            --dat (use PcGive ASCII format)
            --decimal-comma (use comma as decimal character)
            --database (use gretl database format)
            --overwrite (see below, on database format)
            --comment=string (see below)

Save data to filename. By default all currently defined series are saved but
the optional varlist argument can be used to select a subset of series. If
the dataset is sub-sampled, only the observations in the current sample
range are saved.

The format in which the data are written may be controlled in the first
instance by the extension or suffix of filename, as follows:

  .gdt, or no extension: gretl's native XML data format. (If no extension is
  provided, ".gdt" is added automatically.)

  .gtdb: gretl's native binary data format.

  .csv: comma-separated values (CSV).

  .txt or .asc: space-separated values.

  .R: GNU R format.

  .m: GNU Octave format.

The format-related option flags shown above can be used to force the issue
of the save format independently of the filename (or to get gretl to write
in the formats of PcGive or JMulTi). However, if filename has extension .gdt
or .gdtb this necessarily implies use of native format and the addition of a
conflicting option flag will generate an error.

When data are saved in native format (only), the --gzipped option may be
used for data compression, which can be useful for large datasets. The
optional parameter for this flag controls the level of compression (from 0
to 9): higher levels produce a smaller file, but compression takes longer.
The default level is 1; a level of 0 means that no compression is applied.

The option flags --omit-obs and --no-header are applicable only when saving
data in CSV format. By default, if the data are time series or panel, or if
the dataset includes specific observation markers, the CSV file includes a
first column identifying the observations (e.g. by date). If the --omit-obs
flag is given this column is omitted. The --no-header flag suppresses the
usual printing of the names of the variables at the top of the columns.

The option flag --decimal-comma is also confined to the case of saving data
in CSV format. The effect of this option is to replace the decimal point
with the decimal comma; in addition the column separator is forced to be a
semicolon.

The option of saving in gretl database format is intended to help with the
construction of large sets of series, possibly having mixed frequencies and
ranges of observations. At present this option is available only for annual,
quarterly or monthly time-series data. If you save to a file that already
exists, the default action is to append the newly saved series to the
existing content of the database. In this context it is an error if one or
more of the variables to be saved has the same name as a variable that is
already present in the database. The --overwrite flag has the effect that,
if there are variable names in common, the newly saved variable replaces the
variable of the same name in the original dataset.

The --comment option is available when saving data as a database or in CSV
format. The required parameter is a double-quoted one-line string, attached
to the option flag with an equals sign. The string is inserted as a comment
into the database index file or at the top of the CSV output.

The store command behaves in a special manner in the context of a
"progressive loop". See the Gretl User's Guide for details.

Menu path:    /File/Save data; /File/Export data

# summary Statistics

Variants:   summary [ varlist ]
            summary --matrix=matname
Options:    --simple (basic statistics only)
            --weight=wvar (weighting variable)
            --by=byvar (see below)

In its first form, this command prints summary statistics for the variables
in varlist, or for all the variables in the data set if varlist is omitted.
By default, output consists of the mean, standard deviation (sd),
coefficient of variation (= sd/mean), median, minimum, maximum, skewness
coefficient, and excess kurtosis. If the --simple option is given, output is
restricted to the mean, minimum, maximum and standard deviation.

If the --by option is given (in which case the parameter byvar should be the
name of a discrete variable), then statistics are printed for sub-samples
corresponding to the distinct values taken on by byvar. For example, if
byvar is a (binary) dummy variable, statistics are given for the cases byvar
= 0 and byvar = 1. Note: at present, this option is incompatible with the
--weight option.

If the alternative form is given, using a named matrix, then summary
statistics are printed for each column of the matrix. The --by option is not
available in this case.

Menu path:    /View/Summary statistics
Other access: Main window pop-up menu

# system Estimation

Variants:   system method=estimator
            sysname <- system
Examples:   "Klein Model 1" <- system
            system method=sur
            system method=3sls
            See also klein.inp, kmenta.inp, greene14_2.inp

Starts a system of equations. Either of two forms of the command may be
given, depending on whether you wish to save the system for estimation in
more than one way or just estimate the system once.

To save the system you should assign it a name, as in the first example (if
the name contains spaces it must be surrounded by double quotes). In this
case you estimate the system using the "estimate" command. With a saved
system of equations, you are able to impose restrictions (including
cross-equation restrictions) using the "restrict" command.

Alternatively you can specify an estimator for the system using method=
followed by a string identifying one of the supported estimators: "ols"
(Ordinary Least Squares), "tsls" (Two-Stage Least Squares) "sur" (Seemingly
Unrelated Regressions), "3sls" (Three-Stage Least Squares), "fiml" (Full
Information Maximum Likelihood) or "liml" (Limited Information Maximum
Likelihood). In this case the system is estimated once its definition is
complete.

An equation system is terminated by the line "end system". Within the system
four sorts of statement may be given, as follows.

  "equation": specify an equation within the system. At least two such
  statements must be provided.

  "instr": for a system to be estimated via Three-Stage Least Squares, a
  list of instruments (by variable name or number). Alternatively, you can
  put this information into the "equation" line using the same syntax as in
  the "tsls" command.

  "endog": for a system of simultaneous equations, a list of endogenous
  variables. This is primarily intended for use with FIML estimation, but
  with Three-Stage Least Squares this approach may be used instead of giving
  an "instr" list; then all the variables not identified as endogenous will
  be used as instruments.

  "identity": for use with FIML, an identity linking two or more of the
  variables in the system. This sort of statement is ignored when an
  estimator other than FIML is used.

After estimation using the "system" or "estimate" commands the following
accessors can be used to retrieve additional information:

  $uhat: the matrix of residuals, one column per equation.

  $yhat: matrix of fitted values, one column per equation.

  $coeff: column vector of coefficients (all the coefficients from the first
  equation, followed by those from the second equation, and so on).

  $vcv: covariance matrix of the coefficients. If there are k elements in
  the $coeff vector, this matrix is k by k.

  $sigma: cross-equation residual covariance matrix.

  $sysGamma, $sysA and $sysB: structural-form coefficient matrices (see
  below).

If you want to retrieve the residuals or fitted values for a specific
equation as a data series, select a column from the $uhat or $yhat matrix
and assign it to a series, as in

	series uh1 = $uhat[,1]

The structural-form matrices correspond to the following representation of a
simultaneous equations model:

  Gamma y(t) = A y(t-1) + B x(t) + e(t)

If there are n endogenous variables and k exogenous variables, Gamma is an n
x n matrix and B is n x k. If the system contains no lags of the endogenous
variables then the A matrix is not present. If the maximum lag of an
endogenous regressor is p, the A matrix is n x np.

Menu path:    /Model/Simultaneous equations

# tabprint Printing

Argument:   [ -f filename ] 
Options:    --rtf (Produce RTF instead of LaTeX)
            --csv (Produce CSV instead of LaTeX)
            --complete (Create a complete document)
            --format="f1|f2|f3|f4" (Specify a custom format)

Must follow the estimation of a model. Prints the estimated model in tabular
form -- by default as LaTeX, but as RTF if the --rtf flag is given or as CSV
is the --csv flag is given. If a filename is specified using the -f flag
output goes to that file, otherwise it goes to a file with a name of the
form model_N followed by the extension tex, rtf or csv, where N is the
number of models estimated to date in the current session.

If CSV format is selected, values are comma-separated unless the decimal
comma is in force, in which case the separator is the semicolon. Note that
CSV output may be less complete than the other formats.

The further options discussed below are available only when printing the
model as LaTeX.

If the --complete flag is given the LaTeX file is a complete document, ready
for processing; otherwise it must be included in a document.

If you wish alter the appearance of the tabular output, you can specify a
custom row format using the --format flag. The format string must be
enclosed in double quotes and must be tied to the flag with an equals sign.
The pattern for the format string is as follows. There are four fields,
representing the coefficient, standard error, t-ratio and p-value
respectively. These fields should be separated by vertical bars; they may
contain a printf-type specification for the formatting of the numeric value
in question, or may be left blank to suppress the printing of that column
(subject to the constraint that you can't leave all the columns blank). Here
are a few examples:

	--format="%.4f|%.4f|%.4f|%.4f"
	--format="%.4f|%.4f|%.3f|"
	--format="%.5f|%.4f||%.4f"
	--format="%.8g|%.8g||%.4f"

The first of these specifications prints the values in all columns using 4
decimal places. The second suppresses the p-value and prints the t-ratio to
3 places. The third omits the t-ratio. The last one again omits the t, and
prints both coefficient and standard error to 8 significant figures.

Once you set a custom format in this way, it is remembered and used for the
duration of the gretl session. To revert to the default format you can use
the special variant --format=default.

Menu path:    Model window, /LaTeX

# textplot Graphs

Argument:   varlist 
Options:    --time-series (plot by observation)
            --one-scale (force a single scale)
            --tall (use 40 rows)

Quick and simple ASCII graphics. Without the --time-series flag, varlist
must contain at least two series, the last of which is taken as the variable
for the x axis, and a scatter plot is produced. In this case the --tall
option may be used to produce a graph in which the y axis is represented by
40 rows of characters (the default is 20 rows).

With the --time-series, a plot by observation is produced. In this case the
option --one-scale may be used to force the use of a single scale; otherwise
if varlist contains more than one series the data may be scaled. Each line
represents an observation, with the data values plotted horizontally.

See also "gnuplot".

# tobit Estimation

Arguments:  depvar indepvars 
Options:    --llimit=lval (specify left bound)
            --rlimit=rval (specify right bound)
            --vcv (print covariance matrix)
            --robust (robust standard errors)
            --cluster=clustvar (see "logit" for explanation)
            --verbose (print details of iterations)

Estimates a Tobit model, which may be appropriate when the dependent
variable is "censored". For example, positive and zero values of purchases
of durable goods on the part of individual households are observed, and no
negative values, yet decisions on such purchases may be thought of as
outcomes of an underlying, unobserved disposition to purchase that may be
negative in some cases.

By default it is assumed that the dependent variable is censored at zero on
the left and is uncensored on the right. However you can use the options
--llimit and --rlimit to specify a different pattern of censoring. Note that
if you specify a right bound only, the assumption is then that the dependent
variable is uncensored on the left.

The Tobit model is a special case of interval regression, which is supported
via the "intreg" command.

Menu path:    /Model/Limited dependent variable/Tobit

# tsls Estimation

Arguments:  depvar indepvars ; instruments 
Options:    --no-tests (don't do diagnostic tests)
            --vcv (print covariance matrix)
            --robust (robust standard errors)
            --cluster=clustvar (clustered standard errors)
            --liml (use Limited Information Maximum Likelihood)
            --gmm (use the Generalized Method of Moments)
Example:    tsls y1 0 y2 y3 x1 x2 ; 0 x1 x2 x3 x4 x5 x6

Computes Instrumental Variables (IV) estimates, by default using two-stage
least squares (TSLS) but see below for further options. The dependent
variable is depvar, indepvars is the list of regressors (which is presumed
to include at least one endogenous variable); and instruments is the list of
instruments (exogenous and/or predetermined variables). If the instruments
list is not at least as long as indepvars, the model is not identified.

In the above example, the ys are endogenous and the xs are the exogenous
variables. Note that exogenous regressors should appear in both lists.

Output for two-stage least squares estimates includes the Hausman test and,
if the model is over-identified, the Sargan over-identification test. In the
Hausman test, the null hypothesis is that OLS estimates are consistent, or
in other words estimation by means of instrumental variables is not really
required. A model of this sort is over-identified if there are more
instruments than are strictly required. The Sargan test is based on an
auxiliary regression of the residuals from the two-stage least squares model
on the full list of instruments. The null hypothesis is that all the
instruments are valid, and suspicion is thrown on this hypothesis if the
auxiliary regression has a significant degree of explanatory power. For a
good explanation of both tests see chapter 8 of Davidson and MacKinnon
(2004).

For both TSLS and LIML estimation, an additional test result is shown
provided that the model is estimated under the assumption of i.i.d. errors
(that is, the --robust option is not selected). This is a test for weakness
of the instruments. Weak instruments can lead to serious problems in IV
regression: biased estimates and/or incorrect size of hypothesis tests based
on the covariance matrix, with rejection rates well in excess of the nominal
significance level (Stock, Wright and Yogo, 2002). The test statistic is the
first-stage F-test if the model contains just one endogenous regressor,
otherwise it is the smallest eigenvalue of the matrix counterpart of the
first stage F. Critical values based on the Monte Carlo analysis of Stock
and Yogo (2003) are shown when available.

The R-squared value printed for models estimated via two-stage least squares
is the square of the correlation between the dependent variable and the
fitted values.

For details on the effects of the --robust and --cluster options, please see
the help for "ols".

As alternatives to TSLS, the model may be estimated via Limited Information
Maximum Likelihood (the --liml option) or via the Generalized Method of
Moments (--gmm option). Note that if the model is just identified these
methods should produce the same results as TSLS, but if it is
over-identified the results will differ in general.

If GMM estimation is selected, the following additional options become
available:

  --two-step: perform two-step GMM rather than the default of one-step.

  --iterate: Iterate GMM to convergence.

  --weights=Wmat: specify a square matrix of weights to be used when
  computing the GMM criterion function. The dimension of this matrix must
  equal the number of instruments. The default is an appropriately sized
  identity matrix.

Menu path:    /Model/Instrumental variables

# var Estimation

Arguments:  order ylist [ ; xlist ] 
Options:    --nc (do not include a constant)
            --trend (include a linear trend)
            --seasonals (include seasonal dummy variables)
            --robust (robust standard errors)
            --robust-hac (HAC standard errors)
            --quiet (skip output of individual equations)
            --silent (don't print anything)
            --impulse-responses (print impulse responses)
            --variance-decomp (print variance decompositions)
            --lagselect (show criteria for lag selection)
Examples:   var 4 x1 x2 x3 ; time mydum
            var 4 x1 x2 x3 --seasonals
            var 12 x1 x2 x3 --lagselect

Sets up and estimates (using OLS) a vector autoregression (VAR). The first
argument specifies the lag order -- or the maximum lag order in case the
--lagselect option is given (see below). The order may be given numerically,
or as the name of a pre-existing scalar variable. Then follows the setup for
the first equation. Do not include lags among the elements of ylist -- they
will be added automatically. The semi-colon separates the stochastic
variables, for which order lags will be included, from any exogenous
variables in xlist. Note that a constant is included automatically unless
you give the --nc flag, a trend can be added with the --trend flag, and
seasonal dummy variables may be added using the --seasonals flag.

While a VAR specification usually includes all lags from 1 to a given
maximum, it is possible to select a specific set of lags. To do this,
substitute for the regular (scalar) order argument either the name of a
predefined vector or a comma-separated list of lags, enclosed in braces. We
show below two ways of specifying that a VAR should include lags 1, 2 and 4
(but not lag 3):

	var {1,2,4} ylist
	matrix p = {1,2,4}
	var p ylist

A separate regression is reported for each variable in ylist. Output for
each equation includes F-tests for zero restrictions on all lags of each of
the variables, an F-test for the significance of the maximum lag, and, if
the --impulse-responses flag is given, forecast variance decompositions and
impulse responses.

Forecast variance decompositions and impulse responses are based on the
Cholesky decomposition of the contemporaneous covariance matrix, and in this
context the order in which the (stochastic) variables are given matters. The
first variable in the list is assumed to be "most exogenous" within-period.
The horizon for variance decompositions and impulse responses can be set
using the "set" command. For retrieval of a specified impulse response
function in matrix form, see the "irf" function.

If the --robust option is given, standard errors are corrected for
heteroskedasticity. Alternatively, the --robust-hac option can be given to
produce standard errors that are robust with respect to both
heteroskedasticity and autocorrelation (HAC). In general the latter
correction should not be needed if the VAR includes sufficient lags.

If the --lagselect option is given, the first parameter to the var command
is taken as the maximum lag order. Output consists of a table showing the
values of the Akaike (AIC), Schwartz (BIC) and Hannan-Quinn (HQC)
information criteria computed from VARs of order 1 to the given maximum.
This is intended to help with the selection of the optimal lag order. The
usual VAR output is not presented. The table of information criteria may be
retrieved as a matrix via the $test accessor.

Menu path:    /Model/Time series/Vector autoregression

# varlist Dataset

Options:    --scalars (list scalars)
            --accessors (list accessor variables)

By default, prints a listing of the (series) variables currently available.
"list" and "ls" are synonyms.

If the --scalars option is given, prints a listing of any currently defined
scalar variables and their values. Otherwise, if the --accessors option is
given, prints a list of the internal variables currently available via
accessors such as "$nobs" and "$uhat".

# vartest Tests

Arguments:  series1 series2 

Calculates the F statistic for the null hypothesis that the population
variances for the variables series1 and series2 are equal, and shows its
p-value.

Menu path:    /Tools/Test statistic calculator

# vecm Estimation

Arguments:  order rank ylist [ ; xlist ] [ ; rxlist ] 
Options:    --nc (no constant)
            --rc (restricted constant)
            --uc (unrestricted constant)
            --crt (constant and restricted trend)
            --ct (constant and unrestricted trend)
            --seasonals (include centered seasonal dummies)
            --quiet (skip output of individual equations)
            --silent (don't print anything)
            --impulse-responses (print impulse responses)
            --variance-decomp (print variance decompositions)
Examples:   vecm 4 1 Y1 Y2 Y3
            vecm 3 2 Y1 Y2 Y3 --rc
            vecm 3 2 Y1 Y2 Y3 ; X1 --rc
            See also denmark.inp, hamilton.inp

A VECM is a form of vector autoregression or VAR (see "var"), applicable
where the variables in the model are individually integrated of order 1
(that is, are random walks, with or without drift), but exhibit
cointegration. This command is closely related to the Johansen test for
cointegration (see "coint2").

The order parameter to this command represents the lag order of the VAR
system. The number of lags in the VECM itself (where the dependent variable
is given as a first difference) is one less than order.

The rank parameter represents the cointegration rank, or in other words the
number of cointegrating vectors. This must be greater than zero and less
than or equal to (generally, less than) the number of endogenous variables
given in ylist.

ylist supplies the list of endogenous variables, in levels. The inclusion of
deterministic terms in the model is controlled by the option flags. The
default if no option is specified is to include an "unrestricted constant",
which allows for the presence of a non-zero intercept in the cointegrating
relations as well as a trend in the levels of the endogenous variables. In
the literature stemming from the work of Johansen (see for example his 1995
book) this is often referred to as "case 3". The first four options given
above, which are mutually exclusive, produce cases 1, 2, 4 and 5
respectively. The meaning of these cases and the criteria for selecting a
case are explained in the Gretl User's Guide.

The optional lists xlist and rxlist allow you to specify sets of exogenous
variables which enter the model either unrestrictedly (xlist) or restricted
to the cointegration space (rxlist). These lists are separated from ylist
and from each other by semicolons.

The --seasonals option, which may be combined with any of the other options,
specifies the inclusion of a set of centered seasonal dummy variables. This
option is available only for quarterly or monthly data.

The first example above specifies a VECM with lag order 4 and a single
cointegrating vector. The endogenous variables are Y1, Y2 and Y3. The second
example uses the same variables but specifies a lag order of 3 and two
cointegrating vectors; it also specifies a "restricted constant", which is
appropriate if the cointegrating vectors may have a non-zero intercept but
the Y variables have no trend.

Following estimation of a VECM some special accessors are available:
$jalpha, $jbeta and $jvbeta retrieve, respectively, the α and beta matrices
and the estimated variance of beta. For retrieval of a specified impulse
response function in matrix form, see the "irf" function.

Menu path:    /Model/Time series/VECM

# vif Tests

Must follow the estimation of a model which includes at least two
independent variables. Calculates and displays the Variance Inflation
Factors (VIFs) for the regressors. The VIF for regressor j is defined as

  1/(1 - Rj^2)

where R_j is the coefficient of multiple correlation between regressor j and
the other regressors. The factor has a minimum value of 1.0 when the
variable in question is orthogonal to the other independent variables.
Neter, Wasserman, and Kutner (1990) suggest inspecting the largest VIF as a
diagnostic for collinearity; a value greater than 10 is sometimes taken as
indicating a problematic degree of collinearity.

Menu path:    Model window, /Tests/Collinearity

# wls Estimation

Arguments:  wtvar depvar indepvars 
Options:    --vcv (print covariance matrix)
            --robust (robust standard errors)
            --quiet (suppress printing of results)

Computes weighted least squares (WLS) estimates using wtvar as the weight,
depvar as the dependent variable, and indepvars as the list of independent
variables. Let w denote the positive square root of wtvar; then WLS is
basically equivalent to an OLS regression of w * depvar on w * indepvars.
The R-squared, however, is calculated in a special manner, namely as

  R^2 = 1 - ESS / WTSS

where ESS is the error sum of squares (sum of squared residuals) from the
weighted regression and WTSS denotes the "weighted total sum of squares",
which equals the sum of squared residuals from a regression of the weighted
dependent variable on the weighted constant alone.

If wtvar is a dummy variable, WLS estimation is equivalent to eliminating
all observations with value zero for wtvar.

Menu path:    /Model/Other linear models/Weighted Least Squares

# xcorrgm Statistics

Arguments:  series1 series2 [ order ] 
Option:     --plot=mode-or-filename (see below)
Example:    xcorrgm x y 12

Prints and graphs the cross-correlogram for series1 and series2, which may
be specified by name or number. The values are the sample correlation
coefficients between the current value of series1 and successive leads and
lags of series2.

If an order value is specified the length of the cross-correlogram is
limited to at most that number of leads and lags, otherwise the length is
determined automatically, as a function of the frequency of the data and the
number of observations.

By default, a plot of the cross-correlogram is produced: a gnuplot graph in
interactive mode or an ASCII graphic in batch mode. This can be adjusted via
the --plot option. The acceptable parameters to this option are none (to
suppress the plot); ascii (to produce a text graphic even when in
interactive mode); display (to produce a gnuplot graph even when in batch
mode); or a file name. The effect of providing a file name is as described
for the --output option of the "gnuplot" command.

Menu path:    /View/Cross-correlogram
Other access: Main window pop-up menu (multiple selection)

# xtab Statistics

Arguments:  ylist [ ; xlist ] 
Options:    --row (display row percentages)
            --column (display column percentages)
            --zeros (display zero entries)
            --matrix=matname (use frequencies from named matrix)

Displays a contingency table or cross-tabulation for each combination of the
variables included in ylist; if a second list xlist is given, each variable
in ylist is cross-tabulated by row against each variable in xlist (by
column). Variables in these lists can be referenced by name or by number.
Note that all the variables must have been marked as discrete.
Alternatively, if the --matrix option is given, treat the named matrix as a
precomputed set of frequencies and display this as a cross-tabulation.

By default the cell entries are given as frequency counts. The --row and
--column options (which are mutually exclusive), replace the counts with the
percentages for each row or column, respectively. By default, cells with a
zero count are left blank; the --zeros option, which has the effect of
showing zero counts explicitly, may be useful for importing the table into
another program, such as a spreadsheet.

Pearson's chi-square test for independence is displayed if the expected
frequency under independence is at least 1.0e-7 for all cells. A common rule
of thumb for the validity of this statistic is that at least 80 percent of
cells should have expected frequencies of 5 or greater; if this criterion is
not met a warning is printed.

If the contingency table is 2 by 2, Fisher's Exact Test for independence is
computed. Note that this test is based on the assumption that the row and
column totals are fixed, which may or may not be appropriate depending on
how the data were generated. The left p-value should be used when the
alternative to independence is negative association (values tend to cluster
in the lower left and upper right cells); the right p-value should be used
if the alternative is positive association. The two-tailed p-value for this
test is calculated by method (b) in section 2.1 of Agresti (1992): it is the
sum of the probabilities of all possible tables having the given row and
column totals and having a probability less than or equal to that of the
observed table.

